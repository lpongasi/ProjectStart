webpackJsonp([ 1 ], {
    /***/
    109: /***/
    function(e, t, n) {
        n(110);
        n(111);
        n(112);
        e.exports = n(117);
    },
    /***/
    110: /***/
    function(e, t) {},
    /***/
    111: /***/
    function(e, t) {},
    /***/
    112: /***/
    function(e, t, n) {
        function i(e, t) {
            if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function");
        }
        var r, o;
        var a, o;
        var o;
        var a, r, o;
        /*!
 * Materialize v0.100.1 (http://materializecss.com)
 * Copyright 2014-2017 Materialize
 * MIT License (https://raw.githubusercontent.com/Dogfalo/materialize/master/LICENSE)
 */
        var s = function() {
            function e(e, t) {
                for (var n = 0; n < t.length; n++) {
                    var i = t[n];
                    i.enumerable = i.enumerable || !1;
                    i.configurable = !0;
                    if ("value" in i) i.writable = !0;
                    Object.defineProperty(e, i.key, i);
                }
            }
            return function(t, n, i) {
                if (n) e(t.prototype, n);
                if (i) e(t, i);
                return t;
            };
        }();
        // Check for jQuery.
        if ("undefined" === typeof l) {
            var l;
            // Check if require is a defined function.
            if (!0) l = $ = n(39); else l = $;
        }
        /*
  * jQuery Easing v1.4.0 - http://gsgd.co.uk/sandbox/jquery/easing/
  * Open source under the BSD License.
  * Copyright Â© 2008 George McGinley Smith
  * All rights reserved.
  * https://raw.github.com/gdsmith/jquery-easing/master/LICENSE
  */
        !function(i) {
            if (!0) r = [ n(39) ], (o = function(e) {
                return i(e);
            }.apply(t, r)) !== undefined && (e.exports = o); else if ("object" === typeof e && "object" === typeof e.exports) t = i(require("jquery")); else i(l);
        }(function(e) {
            // x is the fraction of animation progress, in the range 0..1
            function t(e) {
                var t = 7.5625, n = 2.75;
                if (e < 1 / n) return t * e * e; else if (e < 2 / n) return t * (e -= 1.5 / n) * e + .75; else if (e < 2.5 / n) return t * (e -= 2.25 / n) * e + .9375; else return t * (e -= 2.625 / n) * e + .984375;
            }
            // Preserve the original jQuery "swing" easing as "jswing"
            e.easing.jswing = e.easing.swing;
            var n = Math.pow, i = Math.sqrt, r = Math.sin, o = Math.cos, a = Math.PI, s = 1.70158, l = 1.525 * s, u = s + 1, c = 2 * a / 3, f = 2 * a / 4.5;
            e.extend(e.easing, {
                def: "easeOutQuad",
                swing: function(t) {
                    return e.easing[e.easing.def](t);
                },
                easeInQuad: function(e) {
                    return e * e;
                },
                easeOutQuad: function(e) {
                    return 1 - (1 - e) * (1 - e);
                },
                easeInOutQuad: function(e) {
                    return e < .5 ? 2 * e * e : 1 - n(-2 * e + 2, 2) / 2;
                },
                easeInCubic: function(e) {
                    return e * e * e;
                },
                easeOutCubic: function(e) {
                    return 1 - n(1 - e, 3);
                },
                easeInOutCubic: function(e) {
                    return e < .5 ? 4 * e * e * e : 1 - n(-2 * e + 2, 3) / 2;
                },
                easeInQuart: function(e) {
                    return e * e * e * e;
                },
                easeOutQuart: function(e) {
                    return 1 - n(1 - e, 4);
                },
                easeInOutQuart: function(e) {
                    return e < .5 ? 8 * e * e * e * e : 1 - n(-2 * e + 2, 4) / 2;
                },
                easeInQuint: function(e) {
                    return e * e * e * e * e;
                },
                easeOutQuint: function(e) {
                    return 1 - n(1 - e, 5);
                },
                easeInOutQuint: function(e) {
                    return e < .5 ? 16 * e * e * e * e * e : 1 - n(-2 * e + 2, 5) / 2;
                },
                easeInSine: function(e) {
                    return 1 - o(e * a / 2);
                },
                easeOutSine: function(e) {
                    return r(e * a / 2);
                },
                easeInOutSine: function(e) {
                    return -(o(a * e) - 1) / 2;
                },
                easeInExpo: function(e) {
                    return 0 === e ? 0 : n(2, 10 * e - 10);
                },
                easeOutExpo: function(e) {
                    return 1 === e ? 1 : 1 - n(2, -10 * e);
                },
                easeInOutExpo: function(e) {
                    return 0 === e ? 0 : 1 === e ? 1 : e < .5 ? n(2, 20 * e - 10) / 2 : (2 - n(2, -20 * e + 10)) / 2;
                },
                easeInCirc: function(e) {
                    return 1 - i(1 - n(e, 2));
                },
                easeOutCirc: function(e) {
                    return i(1 - n(e - 1, 2));
                },
                easeInOutCirc: function(e) {
                    return e < .5 ? (1 - i(1 - n(2 * e, 2))) / 2 : (i(1 - n(-2 * e + 2, 2)) + 1) / 2;
                },
                easeInElastic: function(e) {
                    return 0 === e ? 0 : 1 === e ? 1 : -n(2, 10 * e - 10) * r((10 * e - 10.75) * c);
                },
                easeOutElastic: function(e) {
                    return 0 === e ? 0 : 1 === e ? 1 : n(2, -10 * e) * r((10 * e - .75) * c) + 1;
                },
                easeInOutElastic: function(e) {
                    return 0 === e ? 0 : 1 === e ? 1 : e < .5 ? -n(2, 20 * e - 10) * r((20 * e - 11.125) * f) / 2 : n(2, -20 * e + 10) * r((20 * e - 11.125) * f) / 2 + 1;
                },
                easeInBack: function(e) {
                    return u * e * e * e - s * e * e;
                },
                easeOutBack: function(e) {
                    return 1 + u * n(e - 1, 3) + s * n(e - 1, 2);
                },
                easeInOutBack: function(e) {
                    return e < .5 ? n(2 * e, 2) * (2 * (l + 1) * e - l) / 2 : (n(2 * e - 2, 2) * ((l + 1) * (2 * e - 2) + l) + 2) / 2;
                },
                easeInBounce: function(e) {
                    return 1 - t(1 - e);
                },
                easeOutBounce: t,
                easeInOutBounce: function(e) {
                    return e < .5 ? (1 - t(1 - 2 * e)) / 2 : (1 + t(2 * e - 1)) / 2;
                }
            });
        });
        // Custom Easing
        l.extend(l.easing, {
            easeInOutMaterial: function(e, t, n, i, r) {
                if ((t /= r / 2) < 1) return i / 2 * t * t + n;
                return i / 4 * ((t -= 2) * t * t + 2) + n;
            }
        });
        /*! VelocityJS.org (1.2.3). (C) 2014 Julian Shapiro. MIT @license: en.wikipedia.org/wiki/MIT_License */
        /*! VelocityJS.org jQuery Shim (1.0.1). (C) 2014 The jQuery Foundation. MIT @license: en.wikipedia.org/wiki/MIT_License. */
        /*! Note that this has been modified by Materialize to confirm that Velocity is not already being imported. */
        l.Velocity ? console.log("Velocity is already loaded. You may be needlessly importing Velocity again; note that Materialize includes Velocity.") : (function(e) {
            function t(e) {
                var t = e.length, i = n.type(e);
                return "function" === i || n.isWindow(e) ? !1 : 1 === e.nodeType && t ? !0 : "array" === i || 0 === t || "number" == typeof t && t > 0 && t - 1 in e;
            }
            if (!e.jQuery) {
                var n = function(e, t) {
                    return new n.fn.init(e, t);
                };
                n.isWindow = function(e) {
                    return null != e && e == e.window;
                }, n.type = function(e) {
                    return null == e ? e + "" : "object" == typeof e || "function" == typeof e ? r[a.call(e)] || "object" : typeof e;
                }, n.isArray = Array.isArray || function(e) {
                    return "array" === n.type(e);
                }, n.isPlainObject = function(e) {
                    var t;
                    if (!e || "object" !== n.type(e) || e.nodeType || n.isWindow(e)) return !1;
                    try {
                        if (e.constructor && !o.call(e, "constructor") && !o.call(e.constructor.prototype, "isPrototypeOf")) return !1;
                    } catch (i) {
                        return !1;
                    }
                    for (t in e) ;
                    return void 0 === t || o.call(e, t);
                }, n.each = function(e, n, i) {
                    var r, o = 0, a = e.length, s = t(e);
                    if (i) {
                        if (s) for (;a > o && !1 !== (r = n.apply(e[o], i)); o++) ; else for (o in e) if (!1 === (r = n.apply(e[o], i))) break;
                    } else if (s) for (;a > o && !1 !== (r = n.call(e[o], o, e[o])); o++) ; else for (o in e) if (!1 === (r = n.call(e[o], o, e[o]))) break;
                    return e;
                }, n.data = function(e, t, r) {
                    if (void 0 === r) {
                        var o = e[n.expando], a = o && i[o];
                        if (void 0 === t) return a;
                        if (a && t in a) return a[t];
                    } else if (void 0 !== t) {
                        var o = e[n.expando] || (e[n.expando] = ++n.uuid);
                        return i[o] = i[o] || {}, i[o][t] = r, r;
                    }
                }, n.removeData = function(e, t) {
                    var r = e[n.expando], o = r && i[r];
                    o && n.each(t, function(e, t) {
                        delete o[t];
                    });
                }, n.extend = function() {
                    var e, t, i, r, o, a, s = arguments[0] || {}, l = 1, u = arguments.length, c = !1;
                    for ("boolean" == typeof s && (c = s, s = arguments[l] || {}, l++), "object" != typeof s && "function" !== n.type(s) && (s = {}), 
                    l === u && (s = this, l--); u > l; l++) if (null != (o = arguments[l])) for (r in o) e = s[r], 
                    i = o[r], s !== i && (c && i && (n.isPlainObject(i) || (t = n.isArray(i))) ? (t ? (t = !1, 
                    a = e && n.isArray(e) ? e : []) : a = e && n.isPlainObject(e) ? e : {}, s[r] = n.extend(c, a, i)) : void 0 !== i && (s[r] = i));
                    return s;
                }, n.queue = function(e, i, r) {
                    function o(e, n) {
                        var i = n || [];
                        return null != e && (t(Object(e)) ? function(e, t) {
                            for (var n = +t.length, i = 0, r = e.length; n > i; ) e[r++] = t[i++];
                            if (n !== n) for (;void 0 !== t[i]; ) e[r++] = t[i++];
                            e.length = r;
                        }(i, "string" == typeof e ? [ e ] : e) : [].push.call(i, e)), i;
                    }
                    if (e) {
                        i = (i || "fx") + "queue";
                        var a = n.data(e, i);
                        return r ? (!a || n.isArray(r) ? a = n.data(e, i, o(r)) : a.push(r), a) : a || [];
                    }
                }, n.dequeue = function(e, t) {
                    n.each(e.nodeType ? [ e ] : e, function(e, i) {
                        t = t || "fx";
                        var r = n.queue(i, t), o = r.shift();
                        "inprogress" === o && (o = r.shift()), o && ("fx" === t && r.unshift("inprogress"), 
                        o.call(i, function() {
                            n.dequeue(i, t);
                        }));
                    });
                }, n.fn = n.prototype = {
                    init: function(e) {
                        if (e.nodeType) return this[0] = e, this;
                        throw new Error("Not a DOM node.");
                    },
                    offset: function() {
                        var t = this[0].getBoundingClientRect ? this[0].getBoundingClientRect() : {
                            top: 0,
                            left: 0
                        };
                        return {
                            top: t.top + (e.pageYOffset || document.scrollTop || 0) - (document.clientTop || 0),
                            left: t.left + (e.pageXOffset || document.scrollLeft || 0) - (document.clientLeft || 0)
                        };
                    },
                    position: function() {
                        function e() {
                            for (var e = this.offsetParent || document; e && "html" === !e.nodeType.toLowerCase && "static" === e.style.position; ) e = e.offsetParent;
                            return e || document;
                        }
                        var t = this[0], e = e.apply(t), i = this.offset(), r = /^(?:body|html)$/i.test(e.nodeName) ? {
                            top: 0,
                            left: 0
                        } : n(e).offset();
                        return i.top -= parseFloat(t.style.marginTop) || 0, i.left -= parseFloat(t.style.marginLeft) || 0, 
                        e.style && (r.top += parseFloat(e.style.borderTopWidth) || 0, r.left += parseFloat(e.style.borderLeftWidth) || 0), 
                        {
                            top: i.top - r.top,
                            left: i.left - r.left
                        };
                    }
                };
                var i = {};
                n.expando = "velocity" + new Date().getTime(), n.uuid = 0;
                for (var r = {}, o = r.hasOwnProperty, a = r.toString, s = "Boolean Number String Function Array Date RegExp Object Error".split(" "), l = 0; l < s.length; l++) r["[object " + s[l] + "]"] = s[l].toLowerCase();
                n.fn.init.prototype = n.fn, e.Velocity = {
                    Utilities: n
                };
            }
        }(window), function(i) {
            "object" == typeof e && "object" == typeof e.exports ? e.exports = i() : !0 ? (a = i, 
            (o = "function" === typeof a ? a.call(t, n, t, e) : a) !== undefined && (e.exports = o)) : i();
        }(function() {
            return function(e, t, n, i) {
                function r(e) {
                    for (var t = -1, n = e ? e.length : 0, i = []; ++t < n; ) {
                        var r = e[t];
                        r && i.push(r);
                    }
                    return i;
                }
                function o(e) {
                    return g.isWrapped(e) ? e = [].slice.call(e) : g.isNode(e) && (e = [ e ]), e;
                }
                function a(e) {
                    var t = p.data(e, "velocity");
                    return null === t ? i : t;
                }
                function s(e) {
                    return function(t) {
                        return Math.round(t * e) * (1 / e);
                    };
                }
                function u(e, n, i, r) {
                    function o(e, t) {
                        return 1 - 3 * t + 3 * e;
                    }
                    function a(e, t) {
                        return 3 * t - 6 * e;
                    }
                    function s(e) {
                        return 3 * e;
                    }
                    function l(e, t, n) {
                        return ((o(t, n) * e + a(t, n)) * e + s(t)) * e;
                    }
                    function u(e, t, n) {
                        return 3 * o(t, n) * e * e + 2 * a(t, n) * e + s(t);
                    }
                    function c(t, n) {
                        for (var r = 0; v > r; ++r) {
                            var o = u(n, e, i);
                            if (0 === o) return n;
                            n -= (l(n, e, i) - t) / o;
                        }
                        return n;
                    }
                    function f() {
                        for (var t = 0; b > t; ++t) C[t] = l(t * x, e, i);
                    }
                    function d(t, n, r) {
                        var o, a, s = 0;
                        do {
                            a = n + (r - n) / 2, o = l(a, e, i) - t, o > 0 ? r = a : n = a;
                        } while (Math.abs(o) > m && ++s < y);
                        return a;
                    }
                    function p(t) {
                        for (var n = 0, r = 1, o = b - 1; r != o && C[r] <= t; ++r) n += x;
                        --r;
                        var a = (t - C[r]) / (C[r + 1] - C[r]), s = n + a * x, l = u(s, e, i);
                        return l >= g ? c(t, s) : 0 == l ? s : d(t, n, n + x);
                    }
                    function h() {
                        k = !0, (e != n || i != r) && f();
                    }
                    var v = 4, g = .001, m = 1e-7, y = 10, b = 11, x = 1 / (b - 1), w = "Float32Array" in t;
                    if (4 !== arguments.length) return !1;
                    for (var T = 0; 4 > T; ++T) if ("number" != typeof arguments[T] || isNaN(arguments[T]) || !isFinite(arguments[T])) return !1;
                    e = Math.min(e, 1), i = Math.min(i, 1), e = Math.max(e, 0), i = Math.max(i, 0);
                    var C = w ? new Float32Array(b) : new Array(b), k = !1, S = function(t) {
                        return k || h(), e === n && i === r ? t : 0 === t ? 0 : 1 === t ? 1 : l(p(t), n, r);
                    };
                    S.getControlPoints = function() {
                        return [ {
                            x: e,
                            y: n
                        }, {
                            x: i,
                            y: r
                        } ];
                    };
                    var E = "generateBezier(" + [ e, n, i, r ] + ")";
                    return S.toString = function() {
                        return E;
                    }, S;
                }
                function c(e, t) {
                    var n = e;
                    return g.isString(e) ? x.Easings[e] || (n = !1) : n = g.isArray(e) && 1 === e.length ? s.apply(null, e) : g.isArray(e) && 2 === e.length ? w.apply(null, e.concat([ t ])) : g.isArray(e) && 4 === e.length ? u.apply(null, e) : !1, 
                    !1 === n && (n = x.Easings[x.defaults.easing] ? x.defaults.easing : b), n;
                }
                function f(e) {
                    if (e) {
                        var t = new Date().getTime(), n = x.State.calls.length;
                        n > 1e4 && (x.State.calls = r(x.State.calls));
                        for (var o = 0; n > o; o++) if (x.State.calls[o]) {
                            var s = x.State.calls[o], l = s[0], u = s[2], c = s[3], h = !!c, v = null;
                            c || (c = x.State.calls[o][3] = t - 16);
                            for (var m = Math.min((t - c) / u.duration, 1), y = 0, b = l.length; b > y; y++) {
                                var w = l[y], C = w.element;
                                if (a(C)) {
                                    var S = !1;
                                    if (u.display !== i && null !== u.display && "none" !== u.display) {
                                        if ("flex" === u.display) {
                                            var E = [ "-webkit-box", "-moz-box", "-ms-flexbox", "-webkit-flex" ];
                                            p.each(E, function(e, t) {
                                                T.setPropertyValue(C, "display", t);
                                            });
                                        }
                                        T.setPropertyValue(C, "display", u.display);
                                    }
                                    u.visibility !== i && "hidden" !== u.visibility && T.setPropertyValue(C, "visibility", u.visibility);
                                    for (var A in w) if ("element" !== A) {
                                        var P, D = w[A], O = g.isString(D.easing) ? x.Easings[D.easing] : D.easing;
                                        if (1 === m) P = D.endValue; else {
                                            var N = D.endValue - D.startValue;
                                            if (P = D.startValue + N * O(m, u, N), !h && P === D.currentValue) continue;
                                        }
                                        if (D.currentValue = P, "tween" === A) v = P; else {
                                            if (T.Hooks.registered[A]) {
                                                var q = T.Hooks.getRoot(A), j = a(C).rootPropertyValueCache[q];
                                                j && (D.rootPropertyValue = j);
                                            }
                                            var M = T.setPropertyValue(C, A, D.currentValue + (0 === parseFloat(P) ? "" : D.unitType), D.rootPropertyValue, D.scrollData);
                                            T.Hooks.registered[A] && (a(C).rootPropertyValueCache[q] = T.Normalizations.registered[q] ? T.Normalizations.registered[q]("extract", null, M[1]) : M[1]), 
                                            "transform" === M[0] && (S = !0);
                                        }
                                    }
                                    u.mobileHA && a(C).transformCache.translate3d === i && (a(C).transformCache.translate3d = "(0px, 0px, 0px)", 
                                    S = !0), S && T.flushTransformCache(C);
                                }
                            }
                            u.display !== i && "none" !== u.display && (x.State.calls[o][2].display = !1), u.visibility !== i && "hidden" !== u.visibility && (x.State.calls[o][2].visibility = !1), 
                            u.progress && u.progress.call(s[1], s[1], m, Math.max(0, c + u.duration - t), c, v), 
                            1 === m && d(o);
                        }
                    }
                    x.State.isTicking && k(f);
                }
                function d(e, t) {
                    if (!x.State.calls[e]) return !1;
                    for (var n = x.State.calls[e][0], r = x.State.calls[e][1], o = x.State.calls[e][2], s = x.State.calls[e][4], l = !1, u = 0, c = n.length; c > u; u++) {
                        var f = n[u].element;
                        if (t || o.loop || ("none" === o.display && T.setPropertyValue(f, "display", o.display), 
                        "hidden" === o.visibility && T.setPropertyValue(f, "visibility", o.visibility)), 
                        !0 !== o.loop && (p.queue(f)[1] === i || !/\.velocityQueueEntryFlag/i.test(p.queue(f)[1])) && a(f)) {
                            a(f).isAnimating = !1, a(f).rootPropertyValueCache = {};
                            var d = !1;
                            p.each(T.Lists.transforms3D, function(e, t) {
                                var n = /^scale/.test(t) ? 1 : 0, r = a(f).transformCache[t];
                                a(f).transformCache[t] !== i && new RegExp("^\\(" + n + "[^.]").test(r) && (d = !0, 
                                delete a(f).transformCache[t]);
                            }), o.mobileHA && (d = !0, delete a(f).transformCache.translate3d), d && T.flushTransformCache(f), 
                            T.Values.removeClass(f, "velocity-animating");
                        }
                        if (!t && o.complete && !o.loop && u === c - 1) try {
                            o.complete.call(r, r);
                        } catch (v) {
                            setTimeout(function() {
                                throw v;
                            }, 1);
                        }
                        s && !0 !== o.loop && s(r), a(f) && !0 === o.loop && !t && (p.each(a(f).tweensContainer, function(e, t) {
                            /^rotate/.test(e) && 360 === parseFloat(t.endValue) && (t.endValue = 0, t.startValue = 360), 
                            /^backgroundPosition/.test(e) && 100 === parseFloat(t.endValue) && "%" === t.unitType && (t.endValue = 0, 
                            t.startValue = 100);
                        }), x(f, "reverse", {
                            loop: !0,
                            delay: o.delay
                        })), !1 !== o.queue && p.dequeue(f, o.queue);
                    }
                    x.State.calls[e] = !1;
                    for (var h = 0, g = x.State.calls.length; g > h; h++) if (!1 !== x.State.calls[h]) {
                        l = !0;
                        break;
                    }
                    !1 === l && (x.State.isTicking = !1, delete x.State.calls, x.State.calls = []);
                }
                var p, h = function() {
                    if (n.documentMode) return n.documentMode;
                    for (var e = 7; e > 4; e--) {
                        var t = n.createElement("div");
                        if (t.innerHTML = "\x3c!--[if IE " + e + "]><span></span><![endif]--\x3e", t.getElementsByTagName("span").length) return t = null, 
                        e;
                    }
                    return i;
                }(), v = function() {
                    var e = 0;
                    return t.webkitRequestAnimationFrame || t.mozRequestAnimationFrame || function(t) {
                        var n, i = new Date().getTime();
                        return n = Math.max(0, 16 - (i - e)), e = i + n, setTimeout(function() {
                            t(i + n);
                        }, n);
                    };
                }(), g = {
                    isString: function(e) {
                        return "string" == typeof e;
                    },
                    isArray: Array.isArray || function(e) {
                        return "[object Array]" === Object.prototype.toString.call(e);
                    },
                    isFunction: function(e) {
                        return "[object Function]" === Object.prototype.toString.call(e);
                    },
                    isNode: function(e) {
                        return e && e.nodeType;
                    },
                    isNodeList: function(e) {
                        return "object" == typeof e && /^\[object (HTMLCollection|NodeList|Object)\]$/.test(Object.prototype.toString.call(e)) && e.length !== i && (0 === e.length || "object" == typeof e[0] && e[0].nodeType > 0);
                    },
                    isWrapped: function(e) {
                        return e && (e.jquery || t.Zepto && t.Zepto.zepto.isZ(e));
                    },
                    isSVG: function(e) {
                        return t.SVGElement && e instanceof t.SVGElement;
                    },
                    isEmptyObject: function(e) {
                        for (var t in e) return !1;
                        return !0;
                    }
                }, m = !1;
                if (e.fn && e.fn.jquery ? (p = e, m = !0) : p = t.Velocity.Utilities, 8 >= h && !m) throw new Error("Velocity: IE8 and below require jQuery to be loaded before Velocity.");
                if (7 >= h) return void (l.fn.velocity = l.fn.animate);
                var y = 400, b = "swing", x = {
                    State: {
                        isMobile: /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent),
                        isAndroid: /Android/i.test(navigator.userAgent),
                        isGingerbread: /Android 2\.3\.[3-7]/i.test(navigator.userAgent),
                        isChrome: t.chrome,
                        isFirefox: /Firefox/i.test(navigator.userAgent),
                        prefixElement: n.createElement("div"),
                        prefixMatches: {},
                        scrollAnchor: null,
                        scrollPropertyLeft: null,
                        scrollPropertyTop: null,
                        isTicking: !1,
                        calls: []
                    },
                    CSS: {},
                    Utilities: p,
                    Redirects: {},
                    Easings: {},
                    Promise: t.Promise,
                    defaults: {
                        queue: "",
                        duration: y,
                        easing: b,
                        begin: i,
                        complete: i,
                        progress: i,
                        display: i,
                        visibility: i,
                        loop: !1,
                        delay: !1,
                        mobileHA: !0,
                        _cacheValues: !0
                    },
                    init: function(e) {
                        p.data(e, "velocity", {
                            isSVG: g.isSVG(e),
                            isAnimating: !1,
                            computedStyle: null,
                            tweensContainer: null,
                            rootPropertyValueCache: {},
                            transformCache: {}
                        });
                    },
                    hook: null,
                    mock: !1,
                    version: {
                        major: 1,
                        minor: 2,
                        patch: 2
                    },
                    debug: !1
                };
                t.pageYOffset !== i ? (x.State.scrollAnchor = t, x.State.scrollPropertyLeft = "pageXOffset", 
                x.State.scrollPropertyTop = "pageYOffset") : (x.State.scrollAnchor = n.documentElement || n.body.parentNode || n.body, 
                x.State.scrollPropertyLeft = "scrollLeft", x.State.scrollPropertyTop = "scrollTop");
                var w = function() {
                    function e(e) {
                        return -e.tension * e.x - e.friction * e.v;
                    }
                    function t(t, n, i) {
                        var r = {
                            x: t.x + i.dx * n,
                            v: t.v + i.dv * n,
                            tension: t.tension,
                            friction: t.friction
                        };
                        return {
                            dx: r.v,
                            dv: e(r)
                        };
                    }
                    function n(n, i) {
                        var r = {
                            dx: n.v,
                            dv: e(n)
                        }, o = t(n, .5 * i, r), a = t(n, .5 * i, o), s = t(n, i, a), l = 1 / 6 * (r.dx + 2 * (o.dx + a.dx) + s.dx), u = 1 / 6 * (r.dv + 2 * (o.dv + a.dv) + s.dv);
                        return n.x = n.x + l * i, n.v = n.v + u * i, n;
                    }
                    return function i(e, t, r) {
                        var o, a, s, l = {
                            x: -1,
                            v: 0,
                            tension: null,
                            friction: null
                        }, u = [ 0 ], c = 0, f = 1e-4, d = .016;
                        for (e = parseFloat(e) || 500, t = parseFloat(t) || 20, r = r || null, l.tension = e, 
                        l.friction = t, o = null !== r, o ? (c = i(e, t), a = c / r * d) : a = d; s = n(s || l, a), 
                        u.push(1 + s.x), c += 16, Math.abs(s.x) > f && Math.abs(s.v) > f; ) ;
                        return o ? function(e) {
                            return u[e * (u.length - 1) | 0];
                        } : c;
                    };
                }();
                x.Easings = {
                    linear: function(e) {
                        return e;
                    },
                    swing: function(e) {
                        return .5 - Math.cos(e * Math.PI) / 2;
                    },
                    spring: function(e) {
                        return 1 - Math.cos(4.5 * e * Math.PI) * Math.exp(6 * -e);
                    }
                }, p.each([ [ "ease", [ .25, .1, .25, 1 ] ], [ "ease-in", [ .42, 0, 1, 1 ] ], [ "ease-out", [ 0, 0, .58, 1 ] ], [ "ease-in-out", [ .42, 0, .58, 1 ] ], [ "easeInSine", [ .47, 0, .745, .715 ] ], [ "easeOutSine", [ .39, .575, .565, 1 ] ], [ "easeInOutSine", [ .445, .05, .55, .95 ] ], [ "easeInQuad", [ .55, .085, .68, .53 ] ], [ "easeOutQuad", [ .25, .46, .45, .94 ] ], [ "easeInOutQuad", [ .455, .03, .515, .955 ] ], [ "easeInCubic", [ .55, .055, .675, .19 ] ], [ "easeOutCubic", [ .215, .61, .355, 1 ] ], [ "easeInOutCubic", [ .645, .045, .355, 1 ] ], [ "easeInQuart", [ .895, .03, .685, .22 ] ], [ "easeOutQuart", [ .165, .84, .44, 1 ] ], [ "easeInOutQuart", [ .77, 0, .175, 1 ] ], [ "easeInQuint", [ .755, .05, .855, .06 ] ], [ "easeOutQuint", [ .23, 1, .32, 1 ] ], [ "easeInOutQuint", [ .86, 0, .07, 1 ] ], [ "easeInExpo", [ .95, .05, .795, .035 ] ], [ "easeOutExpo", [ .19, 1, .22, 1 ] ], [ "easeInOutExpo", [ 1, 0, 0, 1 ] ], [ "easeInCirc", [ .6, .04, .98, .335 ] ], [ "easeOutCirc", [ .075, .82, .165, 1 ] ], [ "easeInOutCirc", [ .785, .135, .15, .86 ] ] ], function(e, t) {
                    x.Easings[t[0]] = u.apply(null, t[1]);
                });
                var T = x.CSS = {
                    RegEx: {
                        isHex: /^#([A-f\d]{3}){1,2}$/i,
                        valueUnwrap: /^[A-z]+\((.*)\)$/i,
                        wrappedValueAlreadyExtracted: /[0-9.]+ [0-9.]+ [0-9.]+( [0-9.]+)?/,
                        valueSplit: /([A-z]+\(.+\))|(([A-z0-9#-.]+?)(?=\s|$))/gi
                    },
                    Lists: {
                        colors: [ "fill", "stroke", "stopColor", "color", "backgroundColor", "borderColor", "borderTopColor", "borderRightColor", "borderBottomColor", "borderLeftColor", "outlineColor" ],
                        transformsBase: [ "translateX", "translateY", "scale", "scaleX", "scaleY", "skewX", "skewY", "rotateZ" ],
                        transforms3D: [ "transformPerspective", "translateZ", "scaleZ", "rotateX", "rotateY" ]
                    },
                    Hooks: {
                        templates: {
                            textShadow: [ "Color X Y Blur", "black 0px 0px 0px" ],
                            boxShadow: [ "Color X Y Blur Spread", "black 0px 0px 0px 0px" ],
                            clip: [ "Top Right Bottom Left", "0px 0px 0px 0px" ],
                            backgroundPosition: [ "X Y", "0% 0%" ],
                            transformOrigin: [ "X Y Z", "50% 50% 0px" ],
                            perspectiveOrigin: [ "X Y", "50% 50%" ]
                        },
                        registered: {},
                        register: function() {
                            for (var e = 0; e < T.Lists.colors.length; e++) {
                                var t = "color" === T.Lists.colors[e] ? "0 0 0 1" : "255 255 255 1";
                                T.Hooks.templates[T.Lists.colors[e]] = [ "Red Green Blue Alpha", t ];
                            }
                            var n, i, r;
                            if (h) for (n in T.Hooks.templates) {
                                i = T.Hooks.templates[n], r = i[0].split(" ");
                                var o = i[1].match(T.RegEx.valueSplit);
                                "Color" === r[0] && (r.push(r.shift()), o.push(o.shift()), T.Hooks.templates[n] = [ r.join(" "), o.join(" ") ]);
                            }
                            for (n in T.Hooks.templates) {
                                i = T.Hooks.templates[n], r = i[0].split(" ");
                                for (var e in r) {
                                    var a = n + r[e], s = e;
                                    T.Hooks.registered[a] = [ n, s ];
                                }
                            }
                        },
                        getRoot: function(e) {
                            var t = T.Hooks.registered[e];
                            return t ? t[0] : e;
                        },
                        cleanRootPropertyValue: function(e, t) {
                            return T.RegEx.valueUnwrap.test(t) && (t = t.match(T.RegEx.valueUnwrap)[1]), T.Values.isCSSNullValue(t) && (t = T.Hooks.templates[e][1]), 
                            t;
                        },
                        extractValue: function(e, t) {
                            var n = T.Hooks.registered[e];
                            if (n) {
                                var i = n[0], r = n[1];
                                return t = T.Hooks.cleanRootPropertyValue(i, t), t.toString().match(T.RegEx.valueSplit)[r];
                            }
                            return t;
                        },
                        injectValue: function(e, t, n) {
                            var i = T.Hooks.registered[e];
                            if (i) {
                                var r, o, a = i[0], s = i[1];
                                return n = T.Hooks.cleanRootPropertyValue(a, n), r = n.toString().match(T.RegEx.valueSplit), 
                                r[s] = t, o = r.join(" ");
                            }
                            return n;
                        }
                    },
                    Normalizations: {
                        registered: {
                            clip: function(e, t, n) {
                                switch (e) {
                                  case "name":
                                    return "clip";

                                  case "extract":
                                    var i;
                                    return T.RegEx.wrappedValueAlreadyExtracted.test(n) ? i = n : (i = n.toString().match(T.RegEx.valueUnwrap), 
                                    i = i ? i[1].replace(/,(\s+)?/g, " ") : n), i;

                                  case "inject":
                                    return "rect(" + n + ")";
                                }
                            },
                            blur: function(e, t, n) {
                                switch (e) {
                                  case "name":
                                    return x.State.isFirefox ? "filter" : "-webkit-filter";

                                  case "extract":
                                    var i = parseFloat(n);
                                    if (!i && 0 !== i) {
                                        var r = n.toString().match(/blur\(([0-9]+[A-z]+)\)/i);
                                        i = r ? r[1] : 0;
                                    }
                                    return i;

                                  case "inject":
                                    return parseFloat(n) ? "blur(" + n + ")" : "none";
                                }
                            },
                            opacity: function(e, t, n) {
                                if (8 >= h) switch (e) {
                                  case "name":
                                    return "filter";

                                  case "extract":
                                    var i = n.toString().match(/alpha\(opacity=(.*)\)/i);
                                    return n = i ? i[1] / 100 : 1;

                                  case "inject":
                                    return t.style.zoom = 1, parseFloat(n) >= 1 ? "" : "alpha(opacity=" + parseInt(100 * parseFloat(n), 10) + ")";
                                } else switch (e) {
                                  case "name":
                                    return "opacity";

                                  case "extract":
                                    return n;

                                  case "inject":
                                    return n;
                                }
                            }
                        },
                        register: function() {
                            9 >= h || x.State.isGingerbread || (T.Lists.transformsBase = T.Lists.transformsBase.concat(T.Lists.transforms3D));
                            for (var e = 0; e < T.Lists.transformsBase.length; e++) !function() {
                                var t = T.Lists.transformsBase[e];
                                T.Normalizations.registered[t] = function(e, n, r) {
                                    switch (e) {
                                      case "name":
                                        return "transform";

                                      case "extract":
                                        return a(n) === i || a(n).transformCache[t] === i ? /^scale/i.test(t) ? 1 : 0 : a(n).transformCache[t].replace(/[()]/g, "");

                                      case "inject":
                                        var o = !1;
                                        switch (t.substr(0, t.length - 1)) {
                                          case "translate":
                                            o = !/(%|px|em|rem|vw|vh|\d)$/i.test(r);
                                            break;

                                          case "scal":
                                          case "scale":
                                            x.State.isAndroid && a(n).transformCache[t] === i && 1 > r && (r = 1), o = !/(\d)$/i.test(r);
                                            break;

                                          case "skew":
                                            o = !/(deg|\d)$/i.test(r);
                                            break;

                                          case "rotate":
                                            o = !/(deg|\d)$/i.test(r);
                                        }
                                        return o || (a(n).transformCache[t] = "(" + r + ")"), a(n).transformCache[t];
                                    }
                                };
                            }();
                            for (var e = 0; e < T.Lists.colors.length; e++) !function() {
                                var t = T.Lists.colors[e];
                                T.Normalizations.registered[t] = function(e, n, r) {
                                    switch (e) {
                                      case "name":
                                        return t;

                                      case "extract":
                                        var o;
                                        if (T.RegEx.wrappedValueAlreadyExtracted.test(r)) o = r; else {
                                            var a, s = {
                                                black: "rgb(0, 0, 0)",
                                                blue: "rgb(0, 0, 255)",
                                                gray: "rgb(128, 128, 128)",
                                                green: "rgb(0, 128, 0)",
                                                red: "rgb(255, 0, 0)",
                                                white: "rgb(255, 255, 255)"
                                            };
                                            /^[A-z]+$/i.test(r) ? a = s[r] !== i ? s[r] : s.black : T.RegEx.isHex.test(r) ? a = "rgb(" + T.Values.hexToRgb(r).join(" ") + ")" : /^rgba?\(/i.test(r) || (a = s.black), 
                                            o = (a || r).toString().match(T.RegEx.valueUnwrap)[1].replace(/,(\s+)?/g, " ");
                                        }
                                        return 8 >= h || 3 !== o.split(" ").length || (o += " 1"), o;

                                      case "inject":
                                        return 8 >= h ? 4 === r.split(" ").length && (r = r.split(/\s+/).slice(0, 3).join(" ")) : 3 === r.split(" ").length && (r += " 1"), 
                                        (8 >= h ? "rgb" : "rgba") + "(" + r.replace(/\s+/g, ",").replace(/\.(\d)+(?=,)/g, "") + ")";
                                    }
                                };
                            }();
                        }
                    },
                    Names: {
                        camelCase: function(e) {
                            return e.replace(/-(\w)/g, function(e, t) {
                                return t.toUpperCase();
                            });
                        },
                        SVGAttribute: function(e) {
                            var t = "width|height|x|y|cx|cy|r|rx|ry|x1|x2|y1|y2";
                            return (h || x.State.isAndroid && !x.State.isChrome) && (t += "|transform"), new RegExp("^(" + t + ")$", "i").test(e);
                        },
                        prefixCheck: function(e) {
                            if (x.State.prefixMatches[e]) return [ x.State.prefixMatches[e], !0 ];
                            for (var t = [ "", "Webkit", "Moz", "ms", "O" ], n = 0, i = t.length; i > n; n++) {
                                var r;
                                if (r = 0 === n ? e : t[n] + e.replace(/^\w/, function(e) {
                                    return e.toUpperCase();
                                }), g.isString(x.State.prefixElement.style[r])) return x.State.prefixMatches[e] = r, 
                                [ r, !0 ];
                            }
                            return [ e, !1 ];
                        }
                    },
                    Values: {
                        hexToRgb: function(e) {
                            var t, n = /^#?([a-f\d])([a-f\d])([a-f\d])$/i, i = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i;
                            return e = e.replace(n, function(e, t, n, i) {
                                return t + t + n + n + i + i;
                            }), t = i.exec(e), t ? [ parseInt(t[1], 16), parseInt(t[2], 16), parseInt(t[3], 16) ] : [ 0, 0, 0 ];
                        },
                        isCSSNullValue: function(e) {
                            return 0 == e || /^(none|auto|transparent|(rgba\(0, ?0, ?0, ?0\)))$/i.test(e);
                        },
                        getUnitType: function(e) {
                            return /^(rotate|skew)/i.test(e) ? "deg" : /(^(scale|scaleX|scaleY|scaleZ|alpha|flexGrow|flexHeight|zIndex|fontWeight)$)|((opacity|red|green|blue|alpha)$)/i.test(e) ? "" : "px";
                        },
                        getDisplayType: function(e) {
                            var t = e && e.tagName.toString().toLowerCase();
                            return /^(b|big|i|small|tt|abbr|acronym|cite|code|dfn|em|kbd|strong|samp|var|a|bdo|br|img|map|object|q|script|span|sub|sup|button|input|label|select|textarea)$/i.test(t) ? "inline" : /^(li)$/i.test(t) ? "list-item" : /^(tr)$/i.test(t) ? "table-row" : /^(table)$/i.test(t) ? "table" : /^(tbody)$/i.test(t) ? "table-row-group" : "block";
                        },
                        addClass: function(e, t) {
                            e.classList ? e.classList.add(t) : e.className += (e.className.length ? " " : "") + t;
                        },
                        removeClass: function(e, t) {
                            e.classList ? e.classList.remove(t) : e.className = e.className.toString().replace(new RegExp("(^|\\s)" + t.split(" ").join("|") + "(\\s|$)", "gi"), " ");
                        }
                    },
                    getPropertyValue: function(e, n, r, o) {
                        function s(e, n) {
                            function r() {
                                u && T.setPropertyValue(e, "display", "none");
                            }
                            var l = 0;
                            if (8 >= h) l = p.css(e, n); else {
                                var u = !1;
                                if (/^(width|height)$/.test(n) && 0 === T.getPropertyValue(e, "display") && (u = !0, 
                                T.setPropertyValue(e, "display", T.Values.getDisplayType(e))), !o) {
                                    if ("height" === n && "border-box" !== T.getPropertyValue(e, "boxSizing").toString().toLowerCase()) {
                                        var c = e.offsetHeight - (parseFloat(T.getPropertyValue(e, "borderTopWidth")) || 0) - (parseFloat(T.getPropertyValue(e, "borderBottomWidth")) || 0) - (parseFloat(T.getPropertyValue(e, "paddingTop")) || 0) - (parseFloat(T.getPropertyValue(e, "paddingBottom")) || 0);
                                        return r(), c;
                                    }
                                    if ("width" === n && "border-box" !== T.getPropertyValue(e, "boxSizing").toString().toLowerCase()) {
                                        var f = e.offsetWidth - (parseFloat(T.getPropertyValue(e, "borderLeftWidth")) || 0) - (parseFloat(T.getPropertyValue(e, "borderRightWidth")) || 0) - (parseFloat(T.getPropertyValue(e, "paddingLeft")) || 0) - (parseFloat(T.getPropertyValue(e, "paddingRight")) || 0);
                                        return r(), f;
                                    }
                                }
                                var d;
                                d = a(e) === i ? t.getComputedStyle(e, null) : a(e).computedStyle ? a(e).computedStyle : a(e).computedStyle = t.getComputedStyle(e, null), 
                                "borderColor" === n && (n = "borderTopColor"), l = 9 === h && "filter" === n ? d.getPropertyValue(n) : d[n], 
                                ("" === l || null === l) && (l = e.style[n]), r();
                            }
                            if ("auto" === l && /^(top|right|bottom|left)$/i.test(n)) {
                                var v = s(e, "position");
                                ("fixed" === v || "absolute" === v && /top|left/i.test(n)) && (l = p(e).position()[n] + "px");
                            }
                            return l;
                        }
                        var l;
                        if (T.Hooks.registered[n]) {
                            var u = n, c = T.Hooks.getRoot(u);
                            r === i && (r = T.getPropertyValue(e, T.Names.prefixCheck(c)[0])), T.Normalizations.registered[c] && (r = T.Normalizations.registered[c]("extract", e, r)), 
                            l = T.Hooks.extractValue(u, r);
                        } else if (T.Normalizations.registered[n]) {
                            var f, d;
                            f = T.Normalizations.registered[n]("name", e), "transform" !== f && (d = s(e, T.Names.prefixCheck(f)[0]), 
                            T.Values.isCSSNullValue(d) && T.Hooks.templates[n] && (d = T.Hooks.templates[n][1])), 
                            l = T.Normalizations.registered[n]("extract", e, d);
                        }
                        if (!/^[\d-]/.test(l)) if (a(e) && a(e).isSVG && T.Names.SVGAttribute(n)) if (/^(height|width)$/i.test(n)) try {
                            l = e.getBBox()[n];
                        } catch (g) {
                            l = 0;
                        } else l = e.getAttribute(n); else l = s(e, T.Names.prefixCheck(n)[0]);
                        return T.Values.isCSSNullValue(l) && (l = 0), x.debug >= 2 && console.log("Get " + n + ": " + l), 
                        l;
                    },
                    setPropertyValue: function(e, n, i, r, o) {
                        var s = n;
                        if ("scroll" === n) o.container ? o.container["scroll" + o.direction] = i : "Left" === o.direction ? t.scrollTo(i, o.alternateValue) : t.scrollTo(o.alternateValue, i); else if (T.Normalizations.registered[n] && "transform" === T.Normalizations.registered[n]("name", e)) T.Normalizations.registered[n]("inject", e, i), 
                        s = "transform", i = a(e).transformCache[n]; else {
                            if (T.Hooks.registered[n]) {
                                var l = n, u = T.Hooks.getRoot(n);
                                r = r || T.getPropertyValue(e, u), i = T.Hooks.injectValue(l, i, r), n = u;
                            }
                            if (T.Normalizations.registered[n] && (i = T.Normalizations.registered[n]("inject", e, i), 
                            n = T.Normalizations.registered[n]("name", e)), s = T.Names.prefixCheck(n)[0], 8 >= h) try {
                                e.style[s] = i;
                            } catch (f) {
                                x.debug && console.log("Browser does not support [" + i + "] for [" + s + "]");
                            } else a(e) && a(e).isSVG && T.Names.SVGAttribute(n) ? e.setAttribute(n, i) : e.style[s] = i;
                            x.debug >= 2 && console.log("Set " + n + " (" + s + "): " + i);
                        }
                        return [ s, i ];
                    },
                    flushTransformCache: function(e) {
                        function t(t) {
                            return parseFloat(T.getPropertyValue(e, t));
                        }
                        var n = "";
                        if ((h || x.State.isAndroid && !x.State.isChrome) && a(e).isSVG) {
                            var i = {
                                translate: [ t("translateX"), t("translateY") ],
                                skewX: [ t("skewX") ],
                                skewY: [ t("skewY") ],
                                scale: 1 !== t("scale") ? [ t("scale"), t("scale") ] : [ t("scaleX"), t("scaleY") ],
                                rotate: [ t("rotateZ"), 0, 0 ]
                            };
                            p.each(a(e).transformCache, function(e) {
                                /^translate/i.test(e) ? e = "translate" : /^scale/i.test(e) ? e = "scale" : /^rotate/i.test(e) && (e = "rotate"), 
                                i[e] && (n += e + "(" + i[e].join(" ") + ") ", delete i[e]);
                            });
                        } else {
                            var r, o;
                            p.each(a(e).transformCache, function(t) {
                                return r = a(e).transformCache[t], "transformPerspective" === t ? (o = r, !0) : (9 === h && "rotateZ" === t && (t = "rotate"), 
                                void (n += t + r + " "));
                            }), o && (n = "perspective" + o + " " + n);
                        }
                        T.setPropertyValue(e, "transform", n);
                    }
                };
                T.Hooks.register(), T.Normalizations.register(), x.hook = function(e, t, n) {
                    var r = i;
                    return e = o(e), p.each(e, function(e, o) {
                        if (a(o) === i && x.init(o), n === i) r === i && (r = x.CSS.getPropertyValue(o, t)); else {
                            var s = x.CSS.setPropertyValue(o, t, n);
                            "transform" === s[0] && x.CSS.flushTransformCache(o), r = s;
                        }
                    }), r;
                };
                var C = function() {
                    function e() {
                        return s ? A.promise || null : l;
                    }
                    function r() {
                        function e(e) {
                            function u(e, t) {
                                var n = i, r = i, a = i;
                                return g.isArray(e) ? (n = e[0], !g.isArray(e[1]) && /^[\d-]/.test(e[1]) || g.isFunction(e[1]) || T.RegEx.isHex.test(e[1]) ? a = e[1] : (g.isString(e[1]) && !T.RegEx.isHex.test(e[1]) || g.isArray(e[1])) && (r = t ? e[1] : c(e[1], s.duration), 
                                e[2] !== i && (a = e[2]))) : n = e, t || (r = r || s.easing), g.isFunction(n) && (n = n.call(o, k, w)), 
                                g.isFunction(a) && (a = a.call(o, k, w)), [ n || 0, r, a ];
                            }
                            function d(e, t) {
                                var n, i;
                                return i = (t || "0").toString().toLowerCase().replace(/[%A-z]+$/, function(e) {
                                    return n = e, "";
                                }), n || (n = T.Values.getUnitType(e)), [ i, n ];
                            }
                            function y() {
                                var e = {
                                    myParent: o.parentNode || n.body,
                                    position: T.getPropertyValue(o, "position"),
                                    fontSize: T.getPropertyValue(o, "fontSize")
                                }, i = e.position === M.lastPosition && e.myParent === M.lastParent, r = e.fontSize === M.lastFontSize;
                                M.lastParent = e.myParent, M.lastPosition = e.position, M.lastFontSize = e.fontSize;
                                var s = 100, l = {};
                                if (r && i) l.emToPx = M.lastEmToPx, l.percentToPxWidth = M.lastPercentToPxWidth, 
                                l.percentToPxHeight = M.lastPercentToPxHeight; else {
                                    var u = a(o).isSVG ? n.createElementNS("http://www.w3.org/2000/svg", "rect") : n.createElement("div");
                                    x.init(u), e.myParent.appendChild(u), p.each([ "overflow", "overflowX", "overflowY" ], function(e, t) {
                                        x.CSS.setPropertyValue(u, t, "hidden");
                                    }), x.CSS.setPropertyValue(u, "position", e.position), x.CSS.setPropertyValue(u, "fontSize", e.fontSize), 
                                    x.CSS.setPropertyValue(u, "boxSizing", "content-box"), p.each([ "minWidth", "maxWidth", "width", "minHeight", "maxHeight", "height" ], function(e, t) {
                                        x.CSS.setPropertyValue(u, t, s + "%");
                                    }), x.CSS.setPropertyValue(u, "paddingLeft", s + "em"), l.percentToPxWidth = M.lastPercentToPxWidth = (parseFloat(T.getPropertyValue(u, "width", null, !0)) || 1) / s, 
                                    l.percentToPxHeight = M.lastPercentToPxHeight = (parseFloat(T.getPropertyValue(u, "height", null, !0)) || 1) / s, 
                                    l.emToPx = M.lastEmToPx = (parseFloat(T.getPropertyValue(u, "paddingLeft")) || 1) / s, 
                                    e.myParent.removeChild(u);
                                }
                                return null === M.remToPx && (M.remToPx = parseFloat(T.getPropertyValue(n.body, "fontSize")) || 16), 
                                null === M.vwToPx && (M.vwToPx = parseFloat(t.innerWidth) / 100, M.vhToPx = parseFloat(t.innerHeight) / 100), 
                                l.remToPx = M.remToPx, l.vwToPx = M.vwToPx, l.vhToPx = M.vhToPx, x.debug >= 1 && console.log("Unit ratios: " + JSON.stringify(l), o), 
                                l;
                            }
                            if (s.begin && 0 === k) try {
                                s.begin.call(h, h);
                            } catch (b) {
                                setTimeout(function() {
                                    throw b;
                                }, 1);
                            }
                            if ("scroll" === P) {
                                var C, S, E, D = /^x$/i.test(s.axis) ? "Left" : "Top", O = parseFloat(s.offset) || 0;
                                s.container ? g.isWrapped(s.container) || g.isNode(s.container) ? (s.container = s.container[0] || s.container, 
                                C = s.container["scroll" + D], E = C + p(o).position()[D.toLowerCase()] + O) : s.container = null : (C = x.State.scrollAnchor[x.State["scrollProperty" + D]], 
                                S = x.State.scrollAnchor[x.State["scrollProperty" + ("Left" === D ? "Top" : "Left")]], 
                                E = p(o).offset()[D.toLowerCase()] + O), l = {
                                    scroll: {
                                        rootPropertyValue: !1,
                                        startValue: C,
                                        currentValue: C,
                                        endValue: E,
                                        unitType: "",
                                        easing: s.easing,
                                        scrollData: {
                                            container: s.container,
                                            direction: D,
                                            alternateValue: S
                                        }
                                    },
                                    element: o
                                }, x.debug && console.log("tweensContainer (scroll): ", l.scroll, o);
                            } else if ("reverse" === P) {
                                if (!a(o).tweensContainer) return void p.dequeue(o, s.queue);
                                "none" === a(o).opts.display && (a(o).opts.display = "auto"), "hidden" === a(o).opts.visibility && (a(o).opts.visibility = "visible"), 
                                a(o).opts.loop = !1, a(o).opts.begin = null, a(o).opts.complete = null, m.easing || delete s.easing, 
                                m.duration || delete s.duration, s = p.extend({}, a(o).opts, s);
                                var N = p.extend(!0, {}, a(o).tweensContainer);
                                for (var q in N) if ("element" !== q) {
                                    var j = N[q].startValue;
                                    N[q].startValue = N[q].currentValue = N[q].endValue, N[q].endValue = j, g.isEmptyObject(m) || (N[q].easing = s.easing), 
                                    x.debug && console.log("reverse tweensContainer (" + q + "): " + JSON.stringify(N[q]), o);
                                }
                                l = N;
                            } else if ("start" === P) {
                                var N;
                                a(o).tweensContainer && !0 === a(o).isAnimating && (N = a(o).tweensContainer), p.each(v, function(e, t) {
                                    if (RegExp("^" + T.Lists.colors.join("$|^") + "$").test(e)) {
                                        var n = u(t, !0), r = n[0], o = n[1], a = n[2];
                                        if (T.RegEx.isHex.test(r)) {
                                            for (var s = [ "Red", "Green", "Blue" ], l = T.Values.hexToRgb(r), c = a ? T.Values.hexToRgb(a) : i, f = 0; f < s.length; f++) {
                                                var d = [ l[f] ];
                                                o && d.push(o), c !== i && d.push(c[f]), v[e + s[f]] = d;
                                            }
                                            delete v[e];
                                        }
                                    }
                                });
                                for (var I in v) {
                                    var H = u(v[I]), _ = H[0], F = H[1], R = H[2];
                                    I = T.Names.camelCase(I);
                                    var W = T.Hooks.getRoot(I), $ = !1;
                                    if (a(o).isSVG || "tween" === W || !1 !== T.Names.prefixCheck(W)[1] || T.Normalizations.registered[W] !== i) {
                                        (s.display !== i && null !== s.display && "none" !== s.display || s.visibility !== i && "hidden" !== s.visibility) && /opacity|filter/.test(I) && !R && 0 !== _ && (R = 0), 
                                        s._cacheValues && N && N[I] ? (R === i && (R = N[I].endValue + N[I].unitType), $ = a(o).rootPropertyValueCache[W]) : T.Hooks.registered[I] ? R === i ? ($ = T.getPropertyValue(o, W), 
                                        R = T.getPropertyValue(o, I, $)) : $ = T.Hooks.templates[W][1] : R === i && (R = T.getPropertyValue(o, I));
                                        var z, V, X, B = !1;
                                        if (z = d(I, R), R = z[0], X = z[1], z = d(I, _), _ = z[0].replace(/^([+-\/*])=/, function(e, t) {
                                            return B = t, "";
                                        }), V = z[1], R = parseFloat(R) || 0, _ = parseFloat(_) || 0, "%" === V && (/^(fontSize|lineHeight)$/.test(I) ? (_ /= 100, 
                                        V = "em") : /^scale/.test(I) ? (_ /= 100, V = "") : /(Red|Green|Blue)$/i.test(I) && (_ = _ / 100 * 255, 
                                        V = "")), /[\/*]/.test(B)) V = X; else if (X !== V && 0 !== R) if (0 === _) V = X; else {
                                            r = r || y();
                                            var Y = /margin|padding|left|right|width|text|word|letter/i.test(I) || /X$/.test(I) || "x" === I ? "x" : "y";
                                            switch (X) {
                                              case "%":
                                                R *= "x" === Y ? r.percentToPxWidth : r.percentToPxHeight;
                                                break;

                                              case "px":
                                                break;

                                              default:
                                                R *= r[X + "ToPx"];
                                            }
                                            switch (V) {
                                              case "%":
                                                R *= 1 / ("x" === Y ? r.percentToPxWidth : r.percentToPxHeight);
                                                break;

                                              case "px":
                                                break;

                                              default:
                                                R *= 1 / r[V + "ToPx"];
                                            }
                                        }
                                        switch (B) {
                                          case "+":
                                            _ = R + _;
                                            break;

                                          case "-":
                                            _ = R - _;
                                            break;

                                          case "*":
                                            _ *= R;
                                            break;

                                          case "/":
                                            _ = R / _;
                                        }
                                        l[I] = {
                                            rootPropertyValue: $,
                                            startValue: R,
                                            currentValue: R,
                                            endValue: _,
                                            unitType: V,
                                            easing: F
                                        }, x.debug && console.log("tweensContainer (" + I + "): " + JSON.stringify(l[I]), o);
                                    } else x.debug && console.log("Skipping [" + W + "] due to a lack of browser support.");
                                }
                                l.element = o;
                            }
                            l.element && (T.Values.addClass(o, "velocity-animating"), L.push(l), "" === s.queue && (a(o).tweensContainer = l, 
                            a(o).opts = s), a(o).isAnimating = !0, k === w - 1 ? (x.State.calls.push([ L, h, s, null, A.resolver ]), 
                            !1 === x.State.isTicking && (x.State.isTicking = !0, f())) : k++);
                        }
                        var r, o = this, s = p.extend({}, x.defaults, m), l = {};
                        switch (a(o) === i && x.init(o), parseFloat(s.delay) && !1 !== s.queue && p.queue(o, s.queue, function(e) {
                            x.velocityQueueEntryFlag = !0, a(o).delayTimer = {
                                setTimeout: setTimeout(e, parseFloat(s.delay)),
                                next: e
                            };
                        }), s.duration.toString().toLowerCase()) {
                          case "fast":
                            s.duration = 200;
                            break;

                          case "normal":
                            s.duration = y;
                            break;

                          case "slow":
                            s.duration = 600;
                            break;

                          default:
                            s.duration = parseFloat(s.duration) || 1;
                        }
                        !1 !== x.mock && (!0 === x.mock ? s.duration = s.delay = 1 : (s.duration *= parseFloat(x.mock) || 1, 
                        s.delay *= parseFloat(x.mock) || 1)), s.easing = c(s.easing, s.duration), s.begin && !g.isFunction(s.begin) && (s.begin = null), 
                        s.progress && !g.isFunction(s.progress) && (s.progress = null), s.complete && !g.isFunction(s.complete) && (s.complete = null), 
                        s.display !== i && null !== s.display && (s.display = s.display.toString().toLowerCase(), 
                        "auto" === s.display && (s.display = x.CSS.Values.getDisplayType(o))), s.visibility !== i && null !== s.visibility && (s.visibility = s.visibility.toString().toLowerCase()), 
                        s.mobileHA = s.mobileHA && x.State.isMobile && !x.State.isGingerbread, !1 === s.queue ? s.delay ? setTimeout(e, s.delay) : e() : p.queue(o, s.queue, function(t, n) {
                            return !0 === n ? (A.promise && A.resolver(h), !0) : (x.velocityQueueEntryFlag = !0, 
                            void e(t));
                        }), "" !== s.queue && "fx" !== s.queue || "inprogress" === p.queue(o)[0] || p.dequeue(o);
                    }
                    var s, l, u, h, v, m, b = arguments[0] && (arguments[0].p || p.isPlainObject(arguments[0].properties) && !arguments[0].properties.names || g.isString(arguments[0].properties));
                    if (g.isWrapped(this) ? (s = !1, u = 0, h = this, l = this) : (s = !0, u = 1, h = b ? arguments[0].elements || arguments[0].e : arguments[0]), 
                    h = o(h)) {
                        b ? (v = arguments[0].properties || arguments[0].p, m = arguments[0].options || arguments[0].o) : (v = arguments[u], 
                        m = arguments[u + 1]);
                        var w = h.length, k = 0;
                        if (!/^(stop|finish)$/i.test(v) && !p.isPlainObject(m)) {
                            var S = u + 1;
                            m = {};
                            for (var E = S; E < arguments.length; E++) g.isArray(arguments[E]) || !/^(fast|normal|slow)$/i.test(arguments[E]) && !/^\d/.test(arguments[E]) ? g.isString(arguments[E]) || g.isArray(arguments[E]) ? m.easing = arguments[E] : g.isFunction(arguments[E]) && (m.complete = arguments[E]) : m.duration = arguments[E];
                        }
                        var A = {
                            promise: null,
                            resolver: null,
                            rejecter: null
                        };
                        s && x.Promise && (A.promise = new x.Promise(function(e, t) {
                            A.resolver = e, A.rejecter = t;
                        }));
                        var P;
                        switch (v) {
                          case "scroll":
                            P = "scroll";
                            break;

                          case "reverse":
                            P = "reverse";
                            break;

                          case "finish":
                          case "stop":
                            p.each(h, function(e, t) {
                                a(t) && a(t).delayTimer && (clearTimeout(a(t).delayTimer.setTimeout), a(t).delayTimer.next && a(t).delayTimer.next(), 
                                delete a(t).delayTimer);
                            });
                            var D = [];
                            return p.each(x.State.calls, function(e, t) {
                                t && p.each(t[1], function(n, r) {
                                    var o = m === i ? "" : m;
                                    return !0 === o || t[2].queue === o || m === i && !1 === t[2].queue ? void p.each(h, function(n, i) {
                                        i === r && ((!0 === m || g.isString(m)) && (p.each(p.queue(i, g.isString(m) ? m : ""), function(e, t) {
                                            g.isFunction(t) && t(null, !0);
                                        }), p.queue(i, g.isString(m) ? m : "", [])), "stop" === v ? (a(i) && a(i).tweensContainer && !1 !== o && p.each(a(i).tweensContainer, function(e, t) {
                                            t.endValue = t.currentValue;
                                        }), D.push(e)) : "finish" === v && (t[2].duration = 1));
                                    }) : !0;
                                });
                            }), "stop" === v && (p.each(D, function(e, t) {
                                d(t, !0);
                            }), A.promise && A.resolver(h)), e();

                          default:
                            if (!p.isPlainObject(v) || g.isEmptyObject(v)) {
                                if (g.isString(v) && x.Redirects[v]) {
                                    var O = p.extend({}, m), N = O.duration, q = O.delay || 0;
                                    return !0 === O.backwards && (h = p.extend(!0, [], h).reverse()), p.each(h, function(e, t) {
                                        parseFloat(O.stagger) ? O.delay = q + parseFloat(O.stagger) * e : g.isFunction(O.stagger) && (O.delay = q + O.stagger.call(t, e, w)), 
                                        O.drag && (O.duration = parseFloat(N) || (/^(callout|transition)/.test(v) ? 1e3 : y), 
                                        O.duration = Math.max(O.duration * (O.backwards ? 1 - e / w : (e + 1) / w), .75 * O.duration, 200)), 
                                        x.Redirects[v].call(t, t, O || {}, e, w, h, A.promise ? A : i);
                                    }), e();
                                }
                                var j = "Velocity: First argument (" + v + ") was not a property map, a known action, or a registered redirect. Aborting.";
                                return A.promise ? A.rejecter(new Error(j)) : console.log(j), e();
                            }
                            P = "start";
                        }
                        var M = {
                            lastParent: null,
                            lastPosition: null,
                            lastFontSize: null,
                            lastPercentToPxWidth: null,
                            lastPercentToPxHeight: null,
                            lastEmToPx: null,
                            remToPx: null,
                            vwToPx: null,
                            vhToPx: null
                        }, L = [];
                        p.each(h, function(e, t) {
                            g.isNode(t) && r.call(t);
                        });
                        var I, O = p.extend({}, x.defaults, m);
                        if (O.loop = parseInt(O.loop), I = 2 * O.loop - 1, O.loop) for (var H = 0; I > H; H++) {
                            var _ = {
                                delay: O.delay,
                                progress: O.progress
                            };
                            H === I - 1 && (_.display = O.display, _.visibility = O.visibility, _.complete = O.complete), 
                            C(h, "reverse", _);
                        }
                        return e();
                    }
                };
                x = p.extend(C, x), x.animate = C;
                var k = t.requestAnimationFrame || v;
                return x.State.isMobile || n.hidden === i || n.addEventListener("visibilitychange", function() {
                    n.hidden ? (k = function(e) {
                        return setTimeout(function() {
                            e(!0);
                        }, 16);
                    }, f()) : k = t.requestAnimationFrame || v;
                }), e.Velocity = x, e !== t && (e.fn.velocity = C, e.fn.velocity.defaults = x.defaults), 
                p.each([ "Down", "Up" ], function(e, t) {
                    x.Redirects["slide" + t] = function(e, n, r, o, a, s) {
                        var l = p.extend({}, n), u = l.begin, c = l.complete, f = {
                            height: "",
                            marginTop: "",
                            marginBottom: "",
                            paddingTop: "",
                            paddingBottom: ""
                        }, d = {};
                        l.display === i && (l.display = "Down" === t ? "inline" === x.CSS.Values.getDisplayType(e) ? "inline-block" : "block" : "none"), 
                        l.begin = function() {
                            u && u.call(a, a);
                            for (var n in f) {
                                d[n] = e.style[n];
                                var i = x.CSS.getPropertyValue(e, n);
                                f[n] = "Down" === t ? [ i, 0 ] : [ 0, i ];
                            }
                            d.overflow = e.style.overflow, e.style.overflow = "hidden";
                        }, l.complete = function() {
                            for (var t in d) e.style[t] = d[t];
                            c && c.call(a, a), s && s.resolver(a);
                        }, x(e, f, l);
                    };
                }), p.each([ "In", "Out" ], function(e, t) {
                    x.Redirects["fade" + t] = function(e, n, r, o, a, s) {
                        var l = p.extend({}, n), u = {
                            opacity: "In" === t ? 1 : 0
                        }, c = l.complete;
                        l.complete = r !== o - 1 ? l.begin = null : function() {
                            c && c.call(a, a), s && s.resolver(a);
                        }, l.display === i && (l.display = "In" === t ? "auto" : "none"), x(this, u, l);
                    };
                }), x;
            }(window.jQuery || window.Zepto || window, window, document);
        }));
        !function(i, r, a, s) {
            "use strict";
            function l(e, t, n) {
                return setTimeout(h(e, n), t);
            }
            function u(e, t, n) {
                return Array.isArray(e) ? (c(e, n[t], n), !0) : !1;
            }
            function c(e, t, n) {
                var i;
                if (e) if (e.forEach) e.forEach(t, n); else if (e.length !== s) for (i = 0; i < e.length; ) t.call(n, e[i], i, e), 
                i++; else for (i in e) e.hasOwnProperty(i) && t.call(n, e[i], i, e);
            }
            function f(e, t, n) {
                for (var i = Object.keys(t), r = 0; r < i.length; ) (!n || n && e[i[r]] === s) && (e[i[r]] = t[i[r]]), 
                r++;
                return e;
            }
            function d(e, t) {
                return f(e, t, !0);
            }
            function p(e, t, n) {
                var i, r = t.prototype;
                i = e.prototype = Object.create(r), i.constructor = e, i._super = r, n && f(i, n);
            }
            function h(e, t) {
                return function() {
                    return e.apply(t, arguments);
                };
            }
            function v(e, t) {
                return typeof e == he ? e.apply(t ? t[0] || s : s, t) : e;
            }
            function g(e, t) {
                return e === s ? t : e;
            }
            function m(e, t, n) {
                c(w(t), function(t) {
                    e.addEventListener(t, n, !1);
                });
            }
            function y(e, t, n) {
                c(w(t), function(t) {
                    e.removeEventListener(t, n, !1);
                });
            }
            function b(e, t) {
                for (;e; ) {
                    if (e == t) return !0;
                    e = e.parentNode;
                }
                return !1;
            }
            function x(e, t) {
                return e.indexOf(t) > -1;
            }
            function w(e) {
                return e.trim().split(/\s+/g);
            }
            function T(e, t, n) {
                if (e.indexOf && !n) return e.indexOf(t);
                for (var i = 0; i < e.length; ) {
                    if (n && e[i][n] == t || !n && e[i] === t) return i;
                    i++;
                }
                return -1;
            }
            function C(e) {
                return Array.prototype.slice.call(e, 0);
            }
            function k(e, t, n) {
                for (var i = [], r = [], o = 0; o < e.length; ) {
                    var a = t ? e[o][t] : e[o];
                    T(r, a) < 0 && i.push(e[o]), r[o] = a, o++;
                }
                return n && (i = t ? i.sort(function(e, n) {
                    return e[t] > n[t];
                }) : i.sort()), i;
            }
            function S(e, t) {
                for (var n, i, r = t[0].toUpperCase() + t.slice(1), o = 0; o < de.length; ) {
                    if (n = de[o], (i = n ? n + r : t) in e) return i;
                    o++;
                }
                return s;
            }
            function E() {
                return ye++;
            }
            function A(e) {
                var t = e.ownerDocument;
                return t.defaultView || t.parentWindow;
            }
            function P(e, t) {
                var n = this;
                this.manager = e, this.callback = t, this.element = e.element, this.target = e.options.inputTarget, 
                this.domHandler = function(t) {
                    v(e.options.enable, [ e ]) && n.handler(t);
                }, this.init();
            }
            function D(e) {
                var t, n = e.options.inputClass;
                return new (t = n ? n : we ? z : Te ? B : xe ? Q : $)(e, O);
            }
            function O(e, t, n) {
                var i = n.pointers.length, r = n.changedPointers.length, o = t & Pe && 0 === i - r, a = t & (Oe | Ne) && 0 === i - r;
                n.isFirst = !!o, n.isFinal = !!a, o && (e.session = {}), n.eventType = t, N(e, n), 
                e.emit("hammer.input", n), e.recognize(n), e.session.prevInput = n;
            }
            function N(e, t) {
                var n = e.session, i = t.pointers, r = i.length;
                n.firstInput || (n.firstInput = M(t)), r > 1 && !n.firstMultiple ? n.firstMultiple = M(t) : 1 === r && (n.firstMultiple = !1);
                var o = n.firstInput, a = n.firstMultiple, s = a ? a.center : o.center, l = t.center = L(i);
                t.timeStamp = me(), t.deltaTime = t.timeStamp - o.timeStamp, t.angle = F(s, l), 
                t.distance = _(s, l), q(n, t), t.offsetDirection = H(t.deltaX, t.deltaY), t.scale = a ? W(a.pointers, i) : 1, 
                t.rotation = a ? R(a.pointers, i) : 0, j(n, t);
                var u = e.element;
                b(t.srcEvent.target, u) && (u = t.srcEvent.target), t.target = u;
            }
            function q(e, t) {
                var n = t.center, i = e.offsetDelta || {}, r = e.prevDelta || {}, o = e.prevInput || {};
                (t.eventType === Pe || o.eventType === Oe) && (r = e.prevDelta = {
                    x: o.deltaX || 0,
                    y: o.deltaY || 0
                }, i = e.offsetDelta = {
                    x: n.x,
                    y: n.y
                }), t.deltaX = r.x + (n.x - i.x), t.deltaY = r.y + (n.y - i.y);
            }
            function j(e, t) {
                var n, i, r, o, a = e.lastInterval || t, l = t.timeStamp - a.timeStamp;
                if (t.eventType != Ne && (l > Ae || a.velocity === s)) {
                    var u = a.deltaX - t.deltaX, c = a.deltaY - t.deltaY, f = I(l, u, c);
                    i = f.x, r = f.y, n = ge(f.x) > ge(f.y) ? f.x : f.y, o = H(u, c), e.lastInterval = t;
                } else n = a.velocity, i = a.velocityX, r = a.velocityY, o = a.direction;
                t.velocity = n, t.velocityX = i, t.velocityY = r, t.direction = o;
            }
            function M(e) {
                for (var t = [], n = 0; n < e.pointers.length; ) t[n] = {
                    clientX: ve(e.pointers[n].clientX),
                    clientY: ve(e.pointers[n].clientY)
                }, n++;
                return {
                    timeStamp: me(),
                    pointers: t,
                    center: L(t),
                    deltaX: e.deltaX,
                    deltaY: e.deltaY
                };
            }
            function L(e) {
                var t = e.length;
                if (1 === t) return {
                    x: ve(e[0].clientX),
                    y: ve(e[0].clientY)
                };
                for (var n = 0, i = 0, r = 0; t > r; ) n += e[r].clientX, i += e[r].clientY, r++;
                return {
                    x: ve(n / t),
                    y: ve(i / t)
                };
            }
            function I(e, t, n) {
                return {
                    x: t / e || 0,
                    y: n / e || 0
                };
            }
            function H(e, t) {
                return e === t ? qe : ge(e) >= ge(t) ? e > 0 ? je : Me : t > 0 ? Le : Ie;
            }
            function _(e, t, n) {
                n || (n = Re);
                var i = t[n[0]] - e[n[0]], r = t[n[1]] - e[n[1]];
                return Math.sqrt(i * i + r * r);
            }
            function F(e, t, n) {
                n || (n = Re);
                var i = t[n[0]] - e[n[0]], r = t[n[1]] - e[n[1]];
                return 180 * Math.atan2(r, i) / Math.PI;
            }
            function R(e, t) {
                return F(t[1], t[0], We) - F(e[1], e[0], We);
            }
            function W(e, t) {
                return _(t[0], t[1], We) / _(e[0], e[1], We);
            }
            function $() {
                this.evEl = ze, this.evWin = Ve, this.allow = !0, this.pressed = !1, P.apply(this, arguments);
            }
            function z() {
                this.evEl = Ye, this.evWin = Qe, P.apply(this, arguments), this.store = this.manager.session.pointerEvents = [];
            }
            function V() {
                this.evTarget = Ge, this.evWin = Ze, this.started = !1, P.apply(this, arguments);
            }
            function X(e, t) {
                var n = C(e.touches), i = C(e.changedTouches);
                return t & (Oe | Ne) && (n = k(n.concat(i), "identifier", !0)), [ n, i ];
            }
            function B() {
                this.evTarget = Ke, this.targetIds = {}, P.apply(this, arguments);
            }
            function Y(e, t) {
                var n = C(e.touches), i = this.targetIds;
                if (t & (Pe | De) && 1 === n.length) return i[n[0].identifier] = !0, [ n, n ];
                var r, o, a = C(e.changedTouches), s = [], l = this.target;
                if (o = n.filter(function(e) {
                    return b(e.target, l);
                }), t === Pe) for (r = 0; r < o.length; ) i[o[r].identifier] = !0, r++;
                for (r = 0; r < a.length; ) i[a[r].identifier] && s.push(a[r]), t & (Oe | Ne) && delete i[a[r].identifier], 
                r++;
                return s.length ? [ k(o.concat(s), "identifier", !0), s ] : void 0;
            }
            function Q() {
                P.apply(this, arguments);
                var e = h(this.handler, this);
                this.touch = new B(this.manager, e), this.mouse = new $(this.manager, e);
            }
            function U(e, t) {
                this.manager = e, this.set(t);
            }
            function G(e) {
                if (x(e, ot)) return ot;
                var t = x(e, at), n = x(e, st);
                return t && n ? at + " " + st : t || n ? t ? at : st : x(e, rt) ? rt : it;
            }
            function Z(e) {
                this.id = E(), this.manager = null, this.options = d(e || {}, this.defaults), this.options.enable = g(this.options.enable, !0), 
                this.state = lt, this.simultaneous = {}, this.requireFail = [];
            }
            function J(e) {
                return e & pt ? "cancel" : e & ft ? "end" : e & ct ? "move" : e & ut ? "start" : "";
            }
            function K(e) {
                return e == Ie ? "down" : e == Le ? "up" : e == je ? "left" : e == Me ? "right" : "";
            }
            function ee(e, t) {
                var n = t.manager;
                return n ? n.get(e) : e;
            }
            function te() {
                Z.apply(this, arguments);
            }
            function ne() {
                te.apply(this, arguments), this.pX = null, this.pY = null;
            }
            function ie() {
                te.apply(this, arguments);
            }
            function re() {
                Z.apply(this, arguments), this._timer = null, this._input = null;
            }
            function oe() {
                te.apply(this, arguments);
            }
            function ae() {
                te.apply(this, arguments);
            }
            function se() {
                Z.apply(this, arguments), this.pTime = !1, this.pCenter = !1, this._timer = null, 
                this._input = null, this.count = 0;
            }
            function le(e, t) {
                return t = t || {}, t.recognizers = g(t.recognizers, le.defaults.preset), new ue(e, t);
            }
            function ue(e, t) {
                t = t || {}, this.options = d(t, le.defaults), this.options.inputTarget = this.options.inputTarget || e, 
                this.handlers = {}, this.session = {}, this.recognizers = [], this.element = e, 
                this.input = D(this), this.touchAction = new U(this, this.options.touchAction), 
                ce(this, !0), c(t.recognizers, function(e) {
                    var t = this.add(new e[0](e[1]));
                    e[2] && t.recognizeWith(e[2]), e[3] && t.requireFailure(e[3]);
                }, this);
            }
            function ce(e, t) {
                var n = e.element;
                c(e.options.cssProps, function(e, i) {
                    n.style[S(n.style, i)] = t ? e : "";
                });
            }
            function fe(e, t) {
                var n = r.createEvent("Event");
                n.initEvent(e, !0, !0), n.gesture = t, t.target.dispatchEvent(n);
            }
            var de = [ "", "webkit", "moz", "MS", "ms", "o" ], pe = r.createElement("div"), he = "function", ve = Math.round, ge = Math.abs, me = Date.now, ye = 1, be = /mobile|tablet|ip(ad|hone|od)|android/i, xe = "ontouchstart" in i, we = S(i, "PointerEvent") !== s, Te = xe && be.test(navigator.userAgent), Ce = "touch", ke = "pen", Se = "mouse", Ee = "kinect", Ae = 25, Pe = 1, De = 2, Oe = 4, Ne = 8, qe = 1, je = 2, Me = 4, Le = 8, Ie = 16, He = je | Me, _e = Le | Ie, Fe = He | _e, Re = [ "x", "y" ], We = [ "clientX", "clientY" ];
            P.prototype = {
                handler: function() {},
                init: function() {
                    this.evEl && m(this.element, this.evEl, this.domHandler), this.evTarget && m(this.target, this.evTarget, this.domHandler), 
                    this.evWin && m(A(this.element), this.evWin, this.domHandler);
                },
                destroy: function() {
                    this.evEl && y(this.element, this.evEl, this.domHandler), this.evTarget && y(this.target, this.evTarget, this.domHandler), 
                    this.evWin && y(A(this.element), this.evWin, this.domHandler);
                }
            };
            var $e = {
                mousedown: Pe,
                mousemove: De,
                mouseup: Oe
            }, ze = "mousedown", Ve = "mousemove mouseup";
            p($, P, {
                handler: function(e) {
                    var t = $e[e.type];
                    t & Pe && 0 === e.button && (this.pressed = !0), t & De && 1 !== e.which && (t = Oe), 
                    this.pressed && this.allow && (t & Oe && (this.pressed = !1), this.callback(this.manager, t, {
                        pointers: [ e ],
                        changedPointers: [ e ],
                        pointerType: Se,
                        srcEvent: e
                    }));
                }
            });
            var Xe = {
                pointerdown: Pe,
                pointermove: De,
                pointerup: Oe,
                pointercancel: Ne,
                pointerout: Ne
            }, Be = {
                2: Ce,
                3: ke,
                4: Se,
                5: Ee
            }, Ye = "pointerdown", Qe = "pointermove pointerup pointercancel";
            i.MSPointerEvent && (Ye = "MSPointerDown", Qe = "MSPointerMove MSPointerUp MSPointerCancel"), 
            p(z, P, {
                handler: function(e) {
                    var t = this.store, n = !1, i = e.type.toLowerCase().replace("ms", ""), r = Xe[i], o = Be[e.pointerType] || e.pointerType, a = o == Ce, s = T(t, e.pointerId, "pointerId");
                    r & Pe && (0 === e.button || a) ? 0 > s && (t.push(e), s = t.length - 1) : r & (Oe | Ne) && (n = !0), 
                    0 > s || (t[s] = e, this.callback(this.manager, r, {
                        pointers: t,
                        changedPointers: [ e ],
                        pointerType: o,
                        srcEvent: e
                    }), n && t.splice(s, 1));
                }
            });
            var Ue = {
                touchstart: Pe,
                touchmove: De,
                touchend: Oe,
                touchcancel: Ne
            }, Ge = "touchstart", Ze = "touchstart touchmove touchend touchcancel";
            p(V, P, {
                handler: function(e) {
                    var t = Ue[e.type];
                    if (t === Pe && (this.started = !0), this.started) {
                        var n = X.call(this, e, t);
                        t & (Oe | Ne) && 0 === n[0].length - n[1].length && (this.started = !1), this.callback(this.manager, t, {
                            pointers: n[0],
                            changedPointers: n[1],
                            pointerType: Ce,
                            srcEvent: e
                        });
                    }
                }
            });
            var Je = {
                touchstart: Pe,
                touchmove: De,
                touchend: Oe,
                touchcancel: Ne
            }, Ke = "touchstart touchmove touchend touchcancel";
            p(B, P, {
                handler: function(e) {
                    var t = Je[e.type], n = Y.call(this, e, t);
                    n && this.callback(this.manager, t, {
                        pointers: n[0],
                        changedPointers: n[1],
                        pointerType: Ce,
                        srcEvent: e
                    });
                }
            }), p(Q, P, {
                handler: function(e, t, n) {
                    var i = n.pointerType == Ce, r = n.pointerType == Se;
                    if (i) this.mouse.allow = !1; else if (r && !this.mouse.allow) return;
                    t & (Oe | Ne) && (this.mouse.allow = !0), this.callback(e, t, n);
                },
                destroy: function() {
                    this.touch.destroy(), this.mouse.destroy();
                }
            });
            var et = S(pe.style, "touchAction"), tt = et !== s, nt = "compute", it = "auto", rt = "manipulation", ot = "none", at = "pan-x", st = "pan-y";
            U.prototype = {
                set: function(e) {
                    e == nt && (e = this.compute()), tt && (this.manager.element.style[et] = e), this.actions = e.toLowerCase().trim();
                },
                update: function() {
                    this.set(this.manager.options.touchAction);
                },
                compute: function() {
                    var e = [];
                    return c(this.manager.recognizers, function(t) {
                        v(t.options.enable, [ t ]) && (e = e.concat(t.getTouchAction()));
                    }), G(e.join(" "));
                },
                preventDefaults: function(e) {
                    if (!tt) {
                        var t = e.srcEvent, n = e.offsetDirection;
                        if (this.manager.session.prevented) return void t.preventDefault();
                        var i = this.actions, r = x(i, ot), o = x(i, st), a = x(i, at);
                        return r || o && n & He || a && n & _e ? this.preventSrc(t) : void 0;
                    }
                },
                preventSrc: function(e) {
                    this.manager.session.prevented = !0, e.preventDefault();
                }
            };
            var lt = 1, ut = 2, ct = 4, ft = 8, dt = ft, pt = 16, ht = 32;
            Z.prototype = {
                defaults: {},
                set: function(e) {
                    return f(this.options, e), this.manager && this.manager.touchAction.update(), this;
                },
                recognizeWith: function(e) {
                    if (u(e, "recognizeWith", this)) return this;
                    var t = this.simultaneous;
                    return e = ee(e, this), t[e.id] || (t[e.id] = e, e.recognizeWith(this)), this;
                },
                dropRecognizeWith: function(e) {
                    return u(e, "dropRecognizeWith", this) ? this : (e = ee(e, this), delete this.simultaneous[e.id], 
                    this);
                },
                requireFailure: function(e) {
                    if (u(e, "requireFailure", this)) return this;
                    var t = this.requireFail;
                    return e = ee(e, this), -1 === T(t, e) && (t.push(e), e.requireFailure(this)), this;
                },
                dropRequireFailure: function(e) {
                    if (u(e, "dropRequireFailure", this)) return this;
                    e = ee(e, this);
                    var t = T(this.requireFail, e);
                    return t > -1 && this.requireFail.splice(t, 1), this;
                },
                hasRequireFailures: function() {
                    return this.requireFail.length > 0;
                },
                canRecognizeWith: function(e) {
                    return !!this.simultaneous[e.id];
                },
                emit: function(e) {
                    function t(t) {
                        n.manager.emit(n.options.event + (t ? J(i) : ""), e);
                    }
                    var n = this, i = this.state;
                    ft > i && t(!0), t(), i >= ft && t(!0);
                },
                tryEmit: function(e) {
                    return this.canEmit() ? this.emit(e) : void (this.state = ht);
                },
                canEmit: function() {
                    for (var e = 0; e < this.requireFail.length; ) {
                        if (!(this.requireFail[e].state & (ht | lt))) return !1;
                        e++;
                    }
                    return !0;
                },
                recognize: function(e) {
                    var t = f({}, e);
                    return v(this.options.enable, [ this, t ]) ? (this.state & (dt | pt | ht) && (this.state = lt), 
                    this.state = this.process(t), void (this.state & (ut | ct | ft | pt) && this.tryEmit(t))) : (this.reset(), 
                    void (this.state = ht));
                },
                process: function() {},
                getTouchAction: function() {},
                reset: function() {}
            }, p(te, Z, {
                defaults: {
                    pointers: 1
                },
                attrTest: function(e) {
                    var t = this.options.pointers;
                    return 0 === t || e.pointers.length === t;
                },
                process: function(e) {
                    var t = this.state, n = e.eventType, i = t & (ut | ct), r = this.attrTest(e);
                    return i && (n & Ne || !r) ? t | pt : i || r ? n & Oe ? t | ft : t & ut ? t | ct : ut : ht;
                }
            }), p(ne, te, {
                defaults: {
                    event: "pan",
                    threshold: 10,
                    pointers: 1,
                    direction: Fe
                },
                getTouchAction: function() {
                    var e = this.options.direction, t = [];
                    return e & He && t.push(st), e & _e && t.push(at), t;
                },
                directionTest: function(e) {
                    var t = this.options, n = !0, i = e.distance, r = e.direction, o = e.deltaX, a = e.deltaY;
                    return r & t.direction || (t.direction & He ? (r = 0 === o ? qe : 0 > o ? je : Me, 
                    n = o != this.pX, i = Math.abs(e.deltaX)) : (r = 0 === a ? qe : 0 > a ? Le : Ie, 
                    n = a != this.pY, i = Math.abs(e.deltaY))), e.direction = r, n && i > t.threshold && r & t.direction;
                },
                attrTest: function(e) {
                    return te.prototype.attrTest.call(this, e) && (this.state & ut || !(this.state & ut) && this.directionTest(e));
                },
                emit: function(e) {
                    this.pX = e.deltaX, this.pY = e.deltaY;
                    var t = K(e.direction);
                    t && this.manager.emit(this.options.event + t, e), this._super.emit.call(this, e);
                }
            }), p(ie, te, {
                defaults: {
                    event: "pinch",
                    threshold: 0,
                    pointers: 2
                },
                getTouchAction: function() {
                    return [ ot ];
                },
                attrTest: function(e) {
                    return this._super.attrTest.call(this, e) && (Math.abs(e.scale - 1) > this.options.threshold || this.state & ut);
                },
                emit: function(e) {
                    if (this._super.emit.call(this, e), 1 !== e.scale) {
                        var t = e.scale < 1 ? "in" : "out";
                        this.manager.emit(this.options.event + t, e);
                    }
                }
            }), p(re, Z, {
                defaults: {
                    event: "press",
                    pointers: 1,
                    time: 500,
                    threshold: 5
                },
                getTouchAction: function() {
                    return [ it ];
                },
                process: function(e) {
                    var t = this.options, n = e.pointers.length === t.pointers, i = e.distance < t.threshold, r = e.deltaTime > t.time;
                    if (this._input = e, !i || !n || e.eventType & (Oe | Ne) && !r) this.reset(); else if (e.eventType & Pe) this.reset(), 
                    this._timer = l(function() {
                        this.state = dt, this.tryEmit();
                    }, t.time, this); else if (e.eventType & Oe) return dt;
                    return ht;
                },
                reset: function() {
                    clearTimeout(this._timer);
                },
                emit: function(e) {
                    this.state === dt && (e && e.eventType & Oe ? this.manager.emit(this.options.event + "up", e) : (this._input.timeStamp = me(), 
                    this.manager.emit(this.options.event, this._input)));
                }
            }), p(oe, te, {
                defaults: {
                    event: "rotate",
                    threshold: 0,
                    pointers: 2
                },
                getTouchAction: function() {
                    return [ ot ];
                },
                attrTest: function(e) {
                    return this._super.attrTest.call(this, e) && (Math.abs(e.rotation) > this.options.threshold || this.state & ut);
                }
            }), p(ae, te, {
                defaults: {
                    event: "swipe",
                    threshold: 10,
                    velocity: .65,
                    direction: He | _e,
                    pointers: 1
                },
                getTouchAction: function() {
                    return ne.prototype.getTouchAction.call(this);
                },
                attrTest: function(e) {
                    var t, n = this.options.direction;
                    return n & (He | _e) ? t = e.velocity : n & He ? t = e.velocityX : n & _e && (t = e.velocityY), 
                    this._super.attrTest.call(this, e) && n & e.direction && e.distance > this.options.threshold && ge(t) > this.options.velocity && e.eventType & Oe;
                },
                emit: function(e) {
                    var t = K(e.direction);
                    t && this.manager.emit(this.options.event + t, e), this.manager.emit(this.options.event, e);
                }
            }), p(se, Z, {
                defaults: {
                    event: "tap",
                    pointers: 1,
                    taps: 1,
                    interval: 300,
                    time: 250,
                    threshold: 2,
                    posThreshold: 10
                },
                getTouchAction: function() {
                    return [ rt ];
                },
                process: function(e) {
                    var t = this.options, n = e.pointers.length === t.pointers, i = e.distance < t.threshold, r = e.deltaTime < t.time;
                    if (this.reset(), e.eventType & Pe && 0 === this.count) return this.failTimeout();
                    if (i && r && n) {
                        if (e.eventType != Oe) return this.failTimeout();
                        var o = this.pTime ? e.timeStamp - this.pTime < t.interval : !0, a = !this.pCenter || _(this.pCenter, e.center) < t.posThreshold;
                        this.pTime = e.timeStamp, this.pCenter = e.center, a && o ? this.count += 1 : this.count = 1, 
                        this._input = e;
                        if (0 === this.count % t.taps) return this.hasRequireFailures() ? (this._timer = l(function() {
                            this.state = dt, this.tryEmit();
                        }, t.interval, this), ut) : dt;
                    }
                    return ht;
                },
                failTimeout: function() {
                    return this._timer = l(function() {
                        this.state = ht;
                    }, this.options.interval, this), ht;
                },
                reset: function() {
                    clearTimeout(this._timer);
                },
                emit: function() {
                    this.state == dt && (this._input.tapCount = this.count, this.manager.emit(this.options.event, this._input));
                }
            }), le.VERSION = "2.0.4", le.defaults = {
                domEvents: !1,
                touchAction: nt,
                enable: !0,
                inputTarget: null,
                inputClass: null,
                preset: [ [ oe, {
                    enable: !1
                } ], [ ie, {
                    enable: !1
                }, [ "rotate" ] ], [ ae, {
                    direction: He
                } ], [ ne, {
                    direction: He
                }, [ "swipe" ] ], [ se ], [ se, {
                    event: "doubletap",
                    taps: 2
                }, [ "tap" ] ], [ re ] ],
                cssProps: {
                    userSelect: "default",
                    touchSelect: "none",
                    touchCallout: "none",
                    contentZooming: "none",
                    userDrag: "none",
                    tapHighlightColor: "rgba(0,0,0,0)"
                }
            };
            var vt = 2;
            ue.prototype = {
                set: function(e) {
                    return f(this.options, e), e.touchAction && this.touchAction.update(), e.inputTarget && (this.input.destroy(), 
                    this.input.target = e.inputTarget, this.input.init()), this;
                },
                stop: function(e) {
                    this.session.stopped = e ? vt : 1;
                },
                recognize: function(e) {
                    var t = this.session;
                    if (!t.stopped) {
                        this.touchAction.preventDefaults(e);
                        var n, i = this.recognizers, r = t.curRecognizer;
                        (!r || r && r.state & dt) && (r = t.curRecognizer = null);
                        for (var o = 0; o < i.length; ) n = i[o], t.stopped === vt || r && n != r && !n.canRecognizeWith(r) ? n.reset() : n.recognize(e), 
                        !r && n.state & (ut | ct | ft) && (r = t.curRecognizer = n), o++;
                    }
                },
                get: function(e) {
                    if (e instanceof Z) return e;
                    for (var t = this.recognizers, n = 0; n < t.length; n++) if (t[n].options.event == e) return t[n];
                    return null;
                },
                add: function(e) {
                    if (u(e, "add", this)) return this;
                    var t = this.get(e.options.event);
                    return t && this.remove(t), this.recognizers.push(e), e.manager = this, this.touchAction.update(), 
                    e;
                },
                remove: function(e) {
                    if (u(e, "remove", this)) return this;
                    var t = this.recognizers;
                    return e = this.get(e), t.splice(T(t, e), 1), this.touchAction.update(), this;
                },
                on: function(e, t) {
                    var n = this.handlers;
                    return c(w(e), function(e) {
                        n[e] = n[e] || [], n[e].push(t);
                    }), this;
                },
                off: function(e, t) {
                    var n = this.handlers;
                    return c(w(e), function(e) {
                        t ? n[e].splice(T(n[e], t), 1) : delete n[e];
                    }), this;
                },
                emit: function(e, t) {
                    this.options.domEvents && fe(e, t);
                    var n = this.handlers[e] && this.handlers[e].slice();
                    if (n && n.length) {
                        t.type = e, t.preventDefault = function() {
                            t.srcEvent.preventDefault();
                        };
                        for (var i = 0; i < n.length; ) n[i](t), i++;
                    }
                },
                destroy: function() {
                    this.element && ce(this, !1), this.handlers = {}, this.session = {}, this.input.destroy(), 
                    this.element = null;
                }
            }, f(le, {
                INPUT_START: Pe,
                INPUT_MOVE: De,
                INPUT_END: Oe,
                INPUT_CANCEL: Ne,
                STATE_POSSIBLE: lt,
                STATE_BEGAN: ut,
                STATE_CHANGED: ct,
                STATE_ENDED: ft,
                STATE_RECOGNIZED: dt,
                STATE_CANCELLED: pt,
                STATE_FAILED: ht,
                DIRECTION_NONE: qe,
                DIRECTION_LEFT: je,
                DIRECTION_RIGHT: Me,
                DIRECTION_UP: Le,
                DIRECTION_DOWN: Ie,
                DIRECTION_HORIZONTAL: He,
                DIRECTION_VERTICAL: _e,
                DIRECTION_ALL: Fe,
                Manager: ue,
                Input: P,
                TouchAction: U,
                TouchInput: B,
                MouseInput: $,
                PointerEventInput: z,
                TouchMouseInput: Q,
                SingleTouchInput: V,
                Recognizer: Z,
                AttrRecognizer: te,
                Tap: se,
                Pan: ne,
                Swipe: ae,
                Pinch: ie,
                Rotate: oe,
                Press: re,
                on: m,
                off: y,
                each: c,
                merge: d,
                extend: f,
                inherit: p,
                bindFn: h,
                prefixed: S
            }), "function" == he && n(115) ? (o = function() {
                return le;
            }.call(t, n, t, e)) !== undefined && (e.exports = o) : "undefined" != typeof e && e.exports ? e.exports = le : i[a] = le;
        }(window, document, "Hammer");
        !function(i) {
            if (!0) r = [ n(39), n(116) ], a = i, (o = "function" === typeof a ? a.apply(t, r) : a) !== undefined && (e.exports = o); else if ("object" === typeof t) i(require("jquery"), require("hammerjs")); else i(l, Hammer);
        }(function(e, t) {
            function n(n, i) {
                var r = e(n);
                if (!r.data("hammer")) r.data("hammer", new t(r[0], i));
            }
            e.fn.hammer = function(e) {
                return this.each(function() {
                    n(this, e);
                });
            };
            // extend the emit method to also trigger jQuery events
            t.Manager.prototype.emit = function(t) {
                return function(n, i) {
                    t.call(this, n, i);
                    e(this.element).trigger({
                        type: n,
                        gesture: i
                    });
                };
            }(t.Manager.prototype.emit);
        });
        // Required for Meteor package, the use of window prevents export by Meteor
        !function(e) {
            if (e.Package) Materialize = {}; else e.Materialize = {};
        }(window);
        /*
 * raf.js
 * https://github.com/ngryman/raf.js
 *
 * original requestAnimationFrame polyfill by Erik MÃ¶ller
 * inspired from paul_irish gist and post
 *
 * Copyright (c) 2013 ngryman
 * Licensed under the MIT license.
 */
        !function(e) {
            var t = 0, n = [ "webkit", "moz" ], i = e.requestAnimationFrame, r = e.cancelAnimationFrame, o = n.length;
            // try to un-prefix existing raf
            for (;--o >= 0 && !i; ) {
                i = e[n[o] + "RequestAnimationFrame"];
                r = e[n[o] + "CancelRequestAnimationFrame"];
            }
            // polyfill with setTimeout fallback
            // heavily inspired from @darius gist mod: https://gist.github.com/paulirish/1579671#comment-837945
            if (!i || !r) {
                i = function(e) {
                    var n = +Date.now(), i = Math.max(t + 16, n);
                    return setTimeout(function() {
                        e(t = i);
                    }, i - n);
                };
                r = clearTimeout;
            }
            // export to window
            e.requestAnimationFrame = i;
            e.cancelAnimationFrame = r;
        }(window);
        /**
 * Generate approximated selector string for a jQuery object
 * @param {jQuery} obj  jQuery object to be parsed
 * @returns {string}
 */
        Materialize.objectSelectorString = function(e) {
            return ((e.prop("tagName") || "") + (e.attr("id") || "") + (e.attr("class") || "")).replace(/\s/g, "");
        };
        // Unique Random ID
        Materialize.guid = function() {
            function e() {
                return Math.floor(65536 * (1 + Math.random())).toString(16).substring(1);
            }
            return function() {
                return e() + e() + "-" + e() + "-" + e() + "-" + e() + "-" + e() + e() + e();
            };
        }();
        /**
 * Escapes hash from special characters
 * @param {string} hash  String returned from this.hash
 * @returns {string}
 */
        Materialize.escapeHash = function(e) {
            return e.replace(/(:|\.|\[|\]|,|=)/g, "\\$1");
        };
        Materialize.elementOrParentIsFixed = function(e) {
            var t = $(e);
            var n = t.add(t.parents());
            var i = !1;
            n.each(function() {
                if ("fixed" === $(this).css("position")) {
                    i = !0;
                    return !1;
                }
            });
            return i;
        };
        /**
 * Get time in ms
 * @license https://raw.github.com/jashkenas/underscore/master/LICENSE
 * @type {function}
 * @return {number}
 */
        var u = Date.now || function() {
            return new Date().getTime();
        };
        /**
 * Returns a function, that, when invoked, will only be triggered at most once
 * during a given window of time. Normally, the throttled function will run
 * as much as it can, without ever going more than once per `wait` duration;
 * but if you'd like to disable the execution on the leading edge, pass
 * `{leading: false}`. To disable execution on the trailing edge, ditto.
 * @license https://raw.github.com/jashkenas/underscore/master/LICENSE
 * @param {function} func
 * @param {number} wait
 * @param {Object=} options
 * @returns {Function}
 */
        Materialize.throttle = function(e, t, n) {
            var i, r, o;
            var a = null;
            var s = 0;
            n || (n = {});
            var l = function() {
                s = !1 === n.leading ? 0 : u();
                a = null;
                o = e.apply(i, r);
                i = r = null;
            };
            return function() {
                var c = u();
                if (!s && !1 === n.leading) s = c;
                var f = t - (c - s);
                i = this;
                r = arguments;
                if (f <= 0) {
                    clearTimeout(a);
                    a = null;
                    s = c;
                    o = e.apply(i, r);
                    i = r = null;
                } else if (!a && !1 !== n.trailing) a = setTimeout(l, f);
                return o;
            };
        };
        // Velocity has conflicts when loaded with jQuery, this will check for it
        // First, check if in noConflict mode
        var c;
        if (l) c = l.Velocity; else if ($) c = $.Velocity; else c = Velocity;
        !function(e) {
            e.fn.collapsible = function(t, n) {
                var i = {
                    accordion: undefined,
                    onOpen: undefined,
                    onClose: undefined
                };
                var r = t;
                t = e.extend(i, t);
                return this.each(function() {
                    /****************
      Helper Functions
      ****************/
                    // Accordion Open
                    function i(t) {
                        d = f.find("> li > .collapsible-header");
                        if (t.hasClass("active")) t.parent().addClass("active"); else t.parent().removeClass("active");
                        if (t.parent().hasClass("active")) t.siblings(".collapsible-body").stop(!0, !1).slideDown({
                            duration: 350,
                            easing: "easeOutQuart",
                            queue: !1,
                            complete: function() {
                                e(this).css("height", "");
                            }
                        }); else t.siblings(".collapsible-body").stop(!0, !1).slideUp({
                            duration: 350,
                            easing: "easeOutQuart",
                            queue: !1,
                            complete: function() {
                                e(this).css("height", "");
                            }
                        });
                        d.not(t).removeClass("active").parent().removeClass("active");
                        // Close previously open accordion elements.
                        d.not(t).parent().children(".collapsible-body").stop(!0, !1).each(function() {
                            if (e(this).is(":visible")) e(this).slideUp({
                                duration: 350,
                                easing: "easeOutQuart",
                                queue: !1,
                                complete: function() {
                                    e(this).css("height", "");
                                    s(e(this).siblings(".collapsible-header"));
                                }
                            });
                        });
                    }
                    // Expandable Open
                    function o(t) {
                        if (t.hasClass("active")) t.parent().addClass("active"); else t.parent().removeClass("active");
                        if (t.parent().hasClass("active")) t.siblings(".collapsible-body").stop(!0, !1).slideDown({
                            duration: 350,
                            easing: "easeOutQuart",
                            queue: !1,
                            complete: function() {
                                e(this).css("height", "");
                            }
                        }); else t.siblings(".collapsible-body").stop(!0, !1).slideUp({
                            duration: 350,
                            easing: "easeOutQuart",
                            queue: !1,
                            complete: function() {
                                e(this).css("height", "");
                            }
                        });
                    }
                    // Open collapsible. object: .collapsible-header
                    function a(e, n) {
                        if (!n) e.toggleClass("active");
                        if (t.accordion || "accordion" === p || p === undefined) // Handle Accordion
                        i(e); else // Handle Expandables
                        o(e);
                        s(e);
                    }
                    // Handle callbacks
                    function s(e) {
                        if (e.hasClass("active")) {
                            if ("function" === typeof t.onOpen) t.onOpen.call(this, e.parent());
                        } else if ("function" === typeof t.onClose) t.onClose.call(this, e.parent());
                    }
                    /**
       * Check if object is children of panel header
       * @param  {Object}  object Jquery object
       * @return {Boolean} true if it is children
       */
                    function l(e) {
                        return u(e).length > 0;
                    }
                    /**
       * Get panel header from a children element
       * @param  {Object} object Jquery object
       * @return {Object} panel header object
       */
                    function u(e) {
                        return e.closest("li > .collapsible-header");
                    }
                    // Turn off any existing event handlers
                    function c() {
                        f.off("click.collapse", "> li > .collapsible-header");
                    }
                    var f = e(this);
                    var d = e(this).find("> li > .collapsible-header");
                    var p = f.data("collapsible");
                    /*****  End Helper Functions  *****/
                    // Methods
                    if ("destroy" === r) {
                        c();
                        return;
                    } else if (n >= 0 && n < d.length) {
                        var h = d.eq(n);
                        if (h.length && ("open" === r || "close" === r && h.hasClass("active"))) a(h);
                        return;
                    }
                    c();
                    // Add click handler to only direct collapsible header children
                    f.on("click.collapse", "> li > .collapsible-header", function(t) {
                        var n = e(t.target);
                        if (l(n)) n = u(n);
                        a(n);
                    });
                    // Open first active
                    if (t.accordion || "accordion" === p || p === undefined) // Handle Accordion
                    a(d.filter(".active").first(), !0); else // Handle Expandables
                    d.filter(".active").each(function() {
                        a(e(this), !0);
                    });
                });
            };
            e(document).ready(function() {
                e(".collapsible").collapsible();
            });
        }(l);
        !function(e) {
            // Add posibility to scroll to selected option
            // usefull for select for example
            e.fn.scrollTo = function(t) {
                e(this).scrollTop(e(this).scrollTop() - e(this).offset().top + e(t).offset().top);
                return this;
            };
            e.fn.dropdown = function(t) {
                var n = {
                    inDuration: 300,
                    outDuration: 225,
                    constrainWidth: !0,
                    // Constrains width of dropdown to the activator
                    hover: !1,
                    gutter: 0,
                    // Spacing from edge
                    belowOrigin: !1,
                    alignment: "left",
                    stopPropagation: !1
                };
                // Open dropdown.
                if ("open" === t) {
                    this.each(function() {
                        e(this).trigger("open");
                    });
                    return !1;
                }
                // Close dropdown.
                if ("close" === t) {
                    this.each(function() {
                        e(this).trigger("close");
                    });
                    return !1;
                }
                this.each(function() {
                    function i() {
                        if (a.data("induration") !== undefined) s.inDuration = a.data("induration");
                        if (a.data("outduration") !== undefined) s.outDuration = a.data("outduration");
                        if (a.data("constrainwidth") !== undefined) s.constrainWidth = a.data("constrainwidth");
                        if (a.data("hover") !== undefined) s.hover = a.data("hover");
                        if (a.data("gutter") !== undefined) s.gutter = a.data("gutter");
                        if (a.data("beloworigin") !== undefined) s.belowOrigin = a.data("beloworigin");
                        if (a.data("alignment") !== undefined) s.alignment = a.data("alignment");
                        if (a.data("stoppropagation") !== undefined) s.stopPropagation = a.data("stoppropagation");
                    }
                    /*
        Helper function to position and resize dropdown.
        Used in hover and click handler.
      */
                    function r(t) {
                        // Check for simultaneous focus and click events.
                        if ("focus" === t) l = !0;
                        // Check html data attributes
                        i();
                        // Set Dropdown state
                        u.addClass("active");
                        a.addClass("active");
                        var n = a[0].getBoundingClientRect().width;
                        // Constrain width
                        if (!0 === s.constrainWidth) u.css("width", n); else u.css("white-space", "nowrap");
                        // Offscreen detection
                        var r = window.innerHeight;
                        var c = a.innerHeight();
                        var f = a.offset().left;
                        var d = a.offset().top - e(window).scrollTop();
                        var p = s.alignment;
                        var h = 0;
                        var v = 0;
                        // Below Origin
                        var g = 0;
                        if (!0 === s.belowOrigin) g = c;
                        // Check for scrolling positioned container.
                        var m = 0;
                        var y = 0;
                        var b = a.parent();
                        if (!b.is("body")) {
                            if (b[0].scrollHeight > b[0].clientHeight) m = b[0].scrollTop;
                            if (b[0].scrollWidth > b[0].clientWidth) y = b[0].scrollLeft;
                        }
                        if (f + u.innerWidth() > e(window).width()) // Dropdown goes past screen on right, force right alignment
                        p = "right"; else if (f - u.innerWidth() + a.innerWidth() < 0) // Dropdown goes past screen on left, force left alignment
                        p = "left";
                        // Vertical bottom offscreen detection
                        if (d + u.innerHeight() > r) // If going upwards still goes offscreen, just crop height of dropdown.
                        if (d + c - u.innerHeight() < 0) {
                            var x = r - d - g;
                            u.css("max-height", x);
                        } else {
                            // Flow upwards.
                            if (!g) g += c;
                            g -= u.innerHeight();
                        }
                        // Handle edge alignment
                        if ("left" === p) {
                            h = s.gutter;
                            v = a.position().left + h;
                        } else if ("right" === p) {
                            // Material icons fix
                            u.stop(!0, !0).css({
                                opacity: 0,
                                left: 0
                            });
                            var w = a.position().left + n - u.width();
                            h = -s.gutter;
                            v = w + h;
                        }
                        // Position dropdown
                        u.css({
                            position: "absolute",
                            top: a.position().top + g + m,
                            left: v + y
                        });
                        // Show dropdown
                        u.slideDown({
                            queue: !1,
                            duration: s.inDuration,
                            easing: "easeOutCubic",
                            complete: function() {
                                e(this).css("height", "");
                            }
                        }).animate({
                            opacity: 1
                        }, {
                            queue: !1,
                            duration: s.inDuration,
                            easing: "easeOutSine"
                        });
                        // Add click close handler to document
                        setTimeout(function() {
                            e(document).on("click." + u.attr("id"), function(t) {
                                o();
                                e(document).off("click." + u.attr("id"));
                            });
                        }, 0);
                    }
                    function o() {
                        // Check for simultaneous focus and click events.
                        l = !1;
                        u.fadeOut(s.outDuration);
                        u.removeClass("active");
                        a.removeClass("active");
                        e(document).off("click." + u.attr("id"));
                        setTimeout(function() {
                            u.css("max-height", "");
                        }, s.outDuration);
                    }
                    var a = e(this);
                    var s = e.extend({}, n, t);
                    var l = !1;
                    // Dropdown menu
                    var u = e("#" + a.attr("data-activates"));
                    i();
                    // Attach dropdown to its activator
                    a.after(u);
                    // Hover
                    if (s.hover) {
                        var c = !1;
                        a.off("click." + a.attr("id"));
                        // Hover handler to show dropdown
                        a.on("mouseenter", function(e) {
                            // Mouse over
                            if (!1 === c) {
                                r();
                                c = !0;
                            }
                        });
                        a.on("mouseleave", function(t) {
                            // If hover on origin then to something other than dropdown content, then close
                            var n = t.toElement || t.relatedTarget;
                            // added browser compatibility for target element
                            if (!e(n).closest(".dropdown-content").is(u)) {
                                u.stop(!0, !0);
                                o();
                                c = !1;
                            }
                        });
                        u.on("mouseleave", function(t) {
                            // Mouse out
                            var n = t.toElement || t.relatedTarget;
                            if (!e(n).closest(".dropdown-button").is(a)) {
                                u.stop(!0, !0);
                                o();
                                c = !1;
                            }
                        });
                    } else {
                        // Click handler to show dropdown
                        a.off("click." + a.attr("id"));
                        a.on("click." + a.attr("id"), function(t) {
                            if (!l) if (a[0] == t.currentTarget && !a.hasClass("active") && 0 === e(t.target).closest(".dropdown-content").length) {
                                t.preventDefault();
                                // Prevents button click from moving window
                                if (s.stopPropagation) t.stopPropagation();
                                r("click");
                            } else if (a.hasClass("active")) {
                                o();
                                e(document).off("click." + u.attr("id"));
                            }
                        });
                    }
                    // End else
                    // Listen to open and close event - useful for select component
                    a.on("open", function(e, t) {
                        r(t);
                    });
                    a.on("close", o);
                });
            };
            // End dropdown plugin
            e(document).ready(function() {
                e(".dropdown-button").dropdown();
            });
        }(l);
        !function(e) {
            "use strict";
            var t = {
                opacity: .5,
                inDuration: 250,
                outDuration: 250,
                ready: undefined,
                complete: undefined,
                dismissible: !0,
                startingTop: "4%",
                endingTop: "10%"
            };
            /**
   * @class
   *
   */
            var n = function() {
                /**
     * Construct Modal instance and set up overlay
     * @constructor
     * @param {jQuery} $el
     * @param {Object} options
     */
                function n(t, r) {
                    i(this, n);
                    // If exists, destroy and reinitialize
                    if (t[0].M_Modal) t[0].M_Modal.destroy();
                    /**
       * The jQuery element
       * @type {jQuery}
       */
                    this.$el = t;
                    /**
       * Options for the modal
       * @member Modal#options
       * @prop {Number} [opacity=0.5] - Opacity of the modal overlay
       * @prop {Number} [inDuration=250] - Length in ms of enter transition
       * @prop {Number} [outDuration=250] - Length in ms of exit transition
       * @prop {Function} ready - Callback function called when modal is finished entering
       * @prop {Function} complete - Callback function called when modal is finished exiting
       * @prop {Boolean} [dismissible=true] - Allow modal to be dismissed by keyboard or overlay click
       * @prop {String} [startingTop='4%'] - startingTop
       * @prop {String} [endingTop='10%'] - endingTop
       */
                    this.options = e.extend({}, n.defaults, r);
                    /**
       * Describes open/close state of modal
       * @type {Boolean}
       */
                    this.isOpen = !1;
                    this.$el[0].M_Modal = this;
                    this.id = t.attr("id");
                    this.openingTrigger = undefined;
                    this.$overlay = e('<div class="modal-overlay"></div>');
                    n._increment++;
                    n._count++;
                    this.$overlay[0].style.zIndex = 1e3 + 2 * n._increment;
                    this.$el[0].style.zIndex = 1e3 + 2 * n._increment + 1;
                    this.setupEventHandlers();
                }
                s(n, [ {
                    key: "getInstance",
                    /**
       * Get Instance
       */
                    value: function r() {
                        return this;
                    }
                }, {
                    key: "destroy",
                    value: function o() {
                        this.removeEventHandlers();
                        this.$el[0].removeAttribute("style");
                        if (this.$overlay[0].parentNode) this.$overlay[0].parentNode.removeChild(this.$overlay[0]);
                        this.$el[0].M_Modal = undefined;
                        n._count--;
                    }
                }, {
                    key: "setupEventHandlers",
                    value: function a() {
                        this.handleOverlayClickBound = this.handleOverlayClick.bind(this);
                        this.handleModalCloseClickBound = this.handleModalCloseClick.bind(this);
                        if (1 === n._count) document.addEventListener("click", this.handleTriggerClick);
                        this.$overlay[0].addEventListener("click", this.handleOverlayClickBound);
                        this.$el[0].addEventListener("click", this.handleModalCloseClickBound);
                    }
                }, {
                    key: "removeEventHandlers",
                    value: function l() {
                        if (0 === n._count) document.removeEventListener("click", this.handleTriggerClick);
                        this.$overlay[0].removeEventListener("click", this.handleOverlayClickBound);
                        this.$el[0].removeEventListener("click", this.handleModalCloseClickBound);
                    }
                }, {
                    key: "handleTriggerClick",
                    value: function u(t) {
                        var n = e(t.target).closest(".modal-trigger");
                        if (t.target && n.length) {
                            var i = n[0].getAttribute("href");
                            if (i) i = i.slice(1); else i = n[0].getAttribute("data-target");
                            var r = document.getElementById(i).M_Modal;
                            if (r) r.open(n);
                            t.preventDefault();
                        }
                    }
                }, {
                    key: "handleOverlayClick",
                    value: function f() {
                        if (this.options.dismissible) this.close();
                    }
                }, {
                    key: "handleModalCloseClick",
                    value: function d(t) {
                        var n = e(t.target).closest(".modal-close");
                        if (t.target && n.length) this.close();
                    }
                }, {
                    key: "handleKeydown",
                    value: function p(e) {
                        // ESC key
                        if (27 === e.keyCode && this.options.dismissible) this.close();
                    }
                }, {
                    key: "animateIn",
                    value: function h() {
                        var t = this;
                        // Set initial styles
                        e.extend(this.$el[0].style, {
                            display: "block",
                            opacity: 0
                        });
                        e.extend(this.$overlay[0].style, {
                            display: "block",
                            opacity: 0
                        });
                        // Animate overlay
                        c(this.$overlay[0], {
                            opacity: this.options.opacity
                        }, {
                            duration: this.options.inDuration,
                            queue: !1,
                            ease: "easeOutCubic"
                        });
                        // Define modal animation options
                        var n = {
                            duration: this.options.inDuration,
                            queue: !1,
                            ease: "easeOutCubic",
                            // Handle modal ready callback
                            complete: function() {
                                if ("function" === typeof t.options.ready) t.options.ready.call(t, t.$el, t.openingTrigger);
                            }
                        };
                        // Bottom sheet animation
                        if (this.$el[0].classList.contains("bottom-sheet")) c(this.$el[0], {
                            bottom: 0,
                            opacity: 1
                        }, n); else {
                            c.hook(this.$el[0], "scaleX", .7);
                            this.$el[0].style.top = this.options.startingTop;
                            c(this.$el[0], {
                                top: this.options.endingTop,
                                opacity: 1,
                                scaleX: 1
                            }, n);
                        }
                    }
                }, {
                    key: "animateOut",
                    value: function v() {
                        var e = this;
                        // Animate overlay
                        c(this.$overlay[0], {
                            opacity: 0
                        }, {
                            duration: this.options.outDuration,
                            queue: !1,
                            ease: "easeOutQuart"
                        });
                        // Define modal animation options
                        var t = {
                            duration: this.options.outDuration,
                            queue: !1,
                            ease: "easeOutCubic",
                            // Handle modal ready callback
                            complete: function() {
                                e.$el[0].style.display = "none";
                                // Call complete callback
                                if ("function" === typeof e.options.complete) e.options.complete.call(e, e.$el);
                                e.$overlay[0].remove();
                            }
                        };
                        // Bottom sheet animation
                        if (this.$el[0].classList.contains("bottom-sheet")) c(this.$el[0], {
                            bottom: "-100%",
                            opacity: 0
                        }, t); else c(this.$el[0], {
                            top: this.options.startingTop,
                            opacity: 0,
                            scaleX: .7
                        }, t);
                    }
                }, {
                    key: "open",
                    value: function g(e) {
                        if (this.isOpen) return;
                        this.isOpen = !0;
                        var t = document.body;
                        t.style.overflow = "hidden";
                        this.$el[0].classList.add("open");
                        t.appendChild(this.$overlay[0]);
                        // Set opening trigger, undefined indicates modal was opened by javascript
                        this.openingTrigger = e ? e : undefined;
                        if (this.options.dismissible) {
                            this.handleKeydownBound = this.handleKeydown.bind(this);
                            document.addEventListener("keydown", this.handleKeydownBound);
                        }
                        this.animateIn();
                        return this;
                    }
                }, {
                    key: "close",
                    value: function m() {
                        if (!this.isOpen) return;
                        this.isOpen = !1;
                        this.$el[0].classList.remove("open");
                        document.body.style.overflow = null;
                        if (this.options.dismissible) document.removeEventListener("keydown", this.handleKeydownBound);
                        this.animateOut();
                        return this;
                    }
                } ], [ {
                    key: "init",
                    value: function y(t, i) {
                        var r = [];
                        t.each(function() {
                            r.push(new n(e(this), i));
                        });
                        return r;
                    }
                }, {
                    key: "defaults",
                    get: function() {
                        return t;
                    }
                } ]);
                return n;
            }();
            /**
   * @static
   * @memberof Modal
   */
            n._increment = 0;
            /**
   * @static
   * @memberof Modal
   */
            n._count = 0;
            window.Materialize.Modal = n;
            e.fn.modal = function(t) {
                // Call plugin method if valid method name is passed in
                if (n.prototype[t]) // Getter methods
                if ("get" === t.slice(0, 3)) return this.first()[0].M_Modal[t](); else return this.each(function() {
                    this.M_Modal[t]();
                }); else if ("object" === typeof t || !t) {
                    n.init(this, arguments[0]);
                    return this;
                } else e.error("Method " + t + " does not exist on jQuery.modal");
            };
        }(l);
        !function(e) {
            e.fn.materialbox = function() {
                return this.each(function() {
                    // End click handler
                    // This function returns the modaled image to the original spot
                    function t() {
                        i = !1;
                        var t = a.parent(".material-placeholder");
                        var r = window.innerWidth;
                        var s = window.innerHeight;
                        var l = a.data("width");
                        var u = a.data("height");
                        a.velocity("stop", !0);
                        e("#materialbox-overlay").velocity("stop", !0);
                        e(".materialbox-caption").velocity("stop", !0);
                        // disable exit handlers
                        e(window).off("scroll.materialbox");
                        e(document).off("keyup.materialbox");
                        e(window).off("resize.materialbox");
                        e("#materialbox-overlay").velocity({
                            opacity: 0
                        }, {
                            duration: o,
                            // Delay prevents animation overlapping
                            queue: !1,
                            easing: "easeOutQuad",
                            complete: function() {
                                // Remove Overlay
                                n = !1;
                                e(this).remove();
                            }
                        });
                        // Resize Image
                        a.velocity({
                            width: l,
                            height: u,
                            left: 0,
                            top: 0
                        }, {
                            duration: o,
                            queue: !1,
                            easing: "easeOutQuad",
                            complete: function() {
                                t.css({
                                    height: "",
                                    width: "",
                                    position: "",
                                    top: "",
                                    left: ""
                                });
                                a.removeAttr("style");
                                a.attr("style", d);
                                // Remove class
                                a.removeClass("active");
                                i = !0;
                                // Remove overflow overrides on ancestors
                                if (c) c.css("overflow", "");
                            }
                        });
                        // Remove Caption + reset css settings on image
                        e(".materialbox-caption").velocity({
                            opacity: 0
                        }, {
                            duration: o,
                            // Delay prevents animation overlapping
                            queue: !1,
                            easing: "easeOutQuad",
                            complete: function() {
                                e(this).remove();
                            }
                        });
                    }
                    if (e(this).hasClass("initialized")) return;
                    e(this).addClass("initialized");
                    var n = !1;
                    var i = !0;
                    var r = 275;
                    var o = 200;
                    var a = e(this);
                    var s = e("<div></div>").addClass("material-placeholder");
                    var l = 0;
                    var u = 0;
                    var c;
                    var f;
                    var d = a.attr("style");
                    a.wrap(s);
                    // Start click handler
                    a.on("click", function() {
                        var o = a.parent(".material-placeholder");
                        var s = window.innerWidth;
                        var l = window.innerHeight;
                        var u = a.width();
                        var d = a.height();
                        // If already modal, return to original
                        if (!1 === i) {
                            t();
                            return !1;
                        } else if (n && !0 === i) {
                            t();
                            return !1;
                        }
                        // Set states
                        i = !1;
                        a.addClass("active");
                        n = !0;
                        // Set positioning for placeholder
                        o.css({
                            width: o[0].getBoundingClientRect().width,
                            height: o[0].getBoundingClientRect().height,
                            position: "relative",
                            top: 0,
                            left: 0
                        });
                        // Find ancestor with overflow: hidden; and remove it
                        c = undefined;
                        f = o[0].parentNode;
                        var p = 0;
                        for (;null !== f && !e(f).is(document); ) {
                            var h = e(f);
                            if ("visible" !== h.css("overflow")) {
                                h.css("overflow", "visible");
                                if (c === undefined) c = h; else c = c.add(h);
                            }
                            f = f.parentNode;
                        }
                        // Set css on origin
                        a.css({
                            position: "absolute",
                            "z-index": 1e3,
                            "will-change": "left, top, width, height"
                        }).data("width", u).data("height", d);
                        // Add overlay
                        var v = e('<div id="materialbox-overlay"></div>').css({
                            opacity: 0
                        }).click(function() {
                            if (!0 === i) t();
                        });
                        // Put before in origin image to preserve z-index layering.
                        a.before(v);
                        // Set dimensions if needed
                        var g = v[0].getBoundingClientRect();
                        v.css({
                            width: s,
                            height: l,
                            left: -1 * g.left,
                            top: -1 * g.top
                        });
                        // Animate Overlay
                        v.velocity({
                            opacity: 1
                        }, {
                            duration: r,
                            queue: !1,
                            easing: "easeOutQuad"
                        });
                        // Add and animate caption if it exists
                        if ("" !== a.data("caption")) {
                            var m = e('<div class="materialbox-caption"></div>');
                            m.text(a.data("caption"));
                            e("body").append(m);
                            m.css({
                                display: "inline"
                            });
                            m.velocity({
                                opacity: 1
                            }, {
                                duration: r,
                                queue: !1,
                                easing: "easeOutQuad"
                            });
                        }
                        // Resize Image
                        var y = 0;
                        var b = u / s;
                        var x = d / l;
                        var w = 0;
                        var T = 0;
                        if (b > x) {
                            y = d / u;
                            w = .9 * s;
                            T = .9 * s * y;
                        } else {
                            y = u / d;
                            w = .9 * l * y;
                            T = .9 * l;
                        }
                        // Animate image + set z-index
                        if (a.hasClass("responsive-img")) a.velocity({
                            "max-width": w,
                            width: u
                        }, {
                            duration: 0,
                            queue: !1,
                            complete: function() {
                                a.css({
                                    left: 0,
                                    top: 0
                                }).velocity({
                                    height: T,
                                    width: w,
                                    left: e(document).scrollLeft() + s / 2 - a.parent(".material-placeholder").offset().left - w / 2,
                                    top: e(document).scrollTop() + l / 2 - a.parent(".material-placeholder").offset().top - T / 2
                                }, {
                                    duration: r,
                                    queue: !1,
                                    easing: "easeOutQuad",
                                    complete: function() {
                                        i = !0;
                                    }
                                });
                            }
                        }); else a.css("left", 0).css("top", 0).velocity({
                            height: T,
                            width: w,
                            left: e(document).scrollLeft() + s / 2 - a.parent(".material-placeholder").offset().left - w / 2,
                            top: e(document).scrollTop() + l / 2 - a.parent(".material-placeholder").offset().top - T / 2
                        }, {
                            duration: r,
                            queue: !1,
                            easing: "easeOutQuad",
                            complete: function() {
                                i = !0;
                            }
                        });
                        // Handle Exit triggers
                        e(window).on("scroll.materialbox", function() {
                            if (n) t();
                        });
                        e(window).on("resize.materialbox", function() {
                            if (n) t();
                        });
                        e(document).on("keyup.materialbox", function(e) {
                            // ESC key
                            if (27 === e.keyCode && !0 === i && n) t();
                        });
                    });
                });
            };
            e(document).ready(function() {
                e(".materialboxed").materialbox();
            });
        }(l);
        !function(e) {
            e.fn.parallax = function() {
                var t = e(window).width();
                // Parallax Scripts
                return this.each(function(n) {
                    function i(n) {
                        var i;
                        if (t < 601) i = r.height() > 0 ? r.height() : r.children("img").height(); else i = r.height() > 0 ? r.height() : 500;
                        var o = r.children("img").first();
                        var a = o.height();
                        var s = a - i;
                        var l = r.offset().top + i;
                        var u = r.offset().top;
                        var c = e(window).scrollTop();
                        var f = window.innerHeight;
                        var d = c + f;
                        var p = (d - u) / (i + f);
                        var h = Math.round(s * p);
                        if (n) o.css("display", "block");
                        if (l > c && u < c + f) o.css("transform", "translate3D(-50%," + h + "px, 0)");
                    }
                    var r = e(this);
                    r.addClass("parallax");
                    // Wait for image load
                    r.children("img").one("load", function() {
                        i(!0);
                    }).each(function() {
                        if (this.complete) e(this).trigger("load");
                    });
                    e(window).scroll(function() {
                        t = e(window).width();
                        i(!1);
                    });
                    e(window).resize(function() {
                        t = e(window).width();
                        i(!1);
                    });
                });
            };
        }(l);
        !function(e) {
            var t = {
                init: function(t) {
                    var n = {
                        onShow: null,
                        swipeable: !1,
                        responsiveThreshold: Infinity
                    };
                    t = e.extend(n, t);
                    var i = Materialize.objectSelectorString(e(this));
                    return this.each(function(n) {
                        var r = i + n;
                        // For each set of tabs, we want to keep track of
                        // which tab is active and its associated content
                        var o = e(this), a = e(window).width();
                        var s, l, u = o.find("li.tab a"), c = o.width(), f = e(), d, p = Math.max(c, o[0].scrollWidth) / u.length, h, v = prev_index = 0, g = !1, m, y = 300;
                        // Finds right attribute for indicator based on active tab.
                        // el: jQuery Object
                        var b = function(e) {
                            return Math.ceil(c - e.position().left - e[0].getBoundingClientRect().width - o.scrollLeft());
                        };
                        // Finds left attribute for indicator based on active tab.
                        // el: jQuery Object
                        var x = function(e) {
                            return Math.floor(e.position().left + o.scrollLeft());
                        };
                        // Animates Indicator to active tab.
                        // prev_index: Number
                        var w = function(e) {
                            if (v - e >= 0) {
                                h.velocity({
                                    right: b(s)
                                }, {
                                    duration: y,
                                    queue: !1,
                                    easing: "easeOutQuad"
                                });
                                h.velocity({
                                    left: x(s)
                                }, {
                                    duration: y,
                                    queue: !1,
                                    easing: "easeOutQuad",
                                    delay: 90
                                });
                            } else {
                                h.velocity({
                                    left: x(s)
                                }, {
                                    duration: y,
                                    queue: !1,
                                    easing: "easeOutQuad"
                                });
                                h.velocity({
                                    right: b(s)
                                }, {
                                    duration: y,
                                    queue: !1,
                                    easing: "easeOutQuad",
                                    delay: 90
                                });
                            }
                        };
                        // Change swipeable according to responsive threshold
                        if (t.swipeable) if (a > t.responsiveThreshold) t.swipeable = !1;
                        // If the location.hash matches one of the links, use that as the active tab.
                        s = e(u.filter('[href="' + location.hash + '"]'));
                        // If no match is found, use the first link or any with class 'active' as the initial active tab.
                        if (0 === s.length) s = e(this).find("li.tab a.active").first();
                        if (0 === s.length) s = e(this).find("li.tab a").first();
                        s.addClass("active");
                        v = u.index(s);
                        if (v < 0) v = 0;
                        if (s[0] !== undefined) {
                            l = e(s[0].hash);
                            l.addClass("active");
                        }
                        // append indicator then set indicator width to tab width
                        if (!o.find(".indicator").length) o.append('<li class="indicator"></li>');
                        h = o.find(".indicator");
                        // we make sure that the indicator is at the end of the tabs
                        o.append(h);
                        if (o.is(":visible")) // $indicator.css({"right": $tabs_width - ((index + 1) * $tab_width)});
                        // $indicator.css({"left": index * $tab_width});
                        setTimeout(function() {
                            h.css({
                                right: b(s)
                            });
                            h.css({
                                left: x(s)
                            });
                        }, 0);
                        e(window).off("resize.tabs-" + r).on("resize.tabs-" + r, function() {
                            c = o.width();
                            p = Math.max(c, o[0].scrollWidth) / u.length;
                            if (v < 0) v = 0;
                            if (0 !== p && 0 !== c) {
                                h.css({
                                    right: b(s)
                                });
                                h.css({
                                    left: x(s)
                                });
                            }
                        });
                        // Initialize Tabs Content.
                        if (t.swipeable) {
                            // TODO: Duplicate calls with swipeable? handle multiple div wrapping.
                            u.each(function() {
                                var t = e(Materialize.escapeHash(this.hash));
                                t.addClass("carousel-item");
                                f = f.add(t);
                            });
                            d = f.wrapAll('<div class="tabs-content carousel"></div>');
                            f.css("display", "");
                            e(".tabs-content.carousel").carousel({
                                fullWidth: !0,
                                noWrap: !0,
                                onCycleTo: function(e) {
                                    if (!g) {
                                        var n = v;
                                        v = d.index(e);
                                        s.removeClass("active");
                                        s = u.eq(v);
                                        s.addClass("active");
                                        w(n);
                                        if ("function" === typeof t.onShow) t.onShow.call(o[0], l);
                                    }
                                }
                            });
                        } else // Hide the remaining content
                        u.not(s).each(function() {
                            e(Materialize.escapeHash(this.hash)).hide();
                        });
                        // Bind the click event handler
                        o.off("click.tabs").on("click.tabs", "a", function(n) {
                            if (e(this).parent().hasClass("disabled")) {
                                n.preventDefault();
                                return;
                            }
                            // Act as regular link if target attribute is specified.
                            if (e(this).attr("target")) return;
                            g = !0;
                            c = o.width();
                            p = Math.max(c, o[0].scrollWidth) / u.length;
                            // Make the old tab inactive.
                            s.removeClass("active");
                            var i = l;
                            // Update the variables with the new link and content
                            s = e(this);
                            l = e(Materialize.escapeHash(this.hash));
                            u = o.find("li.tab a");
                            var r = s.position();
                            // Make the tab active.
                            s.addClass("active");
                            prev_index = v;
                            v = u.index(e(this));
                            if (v < 0) v = 0;
                            // Change url to current tab
                            // window.location.hash = $active.attr('href');
                            // Swap content
                            if (t.swipeable) {
                                if (f.length) f.carousel("set", v, function() {
                                    if ("function" === typeof t.onShow) t.onShow.call(o[0], l);
                                });
                            } else {
                                if (l !== undefined) {
                                    l.show();
                                    l.addClass("active");
                                    if ("function" === typeof t.onShow) t.onShow.call(this, l);
                                }
                                if (i !== undefined && !i.is(l)) {
                                    i.hide();
                                    i.removeClass("active");
                                }
                            }
                            // Reset clicked state
                            m = setTimeout(function() {
                                g = !1;
                            }, y);
                            // Update indicator
                            w(prev_index);
                            // Prevent the anchor's default click action
                            n.preventDefault();
                        });
                    });
                },
                select_tab: function(e) {
                    this.find('a[href="#' + e + '"]').trigger("click");
                }
            };
            e.fn.tabs = function(n) {
                if (t[n]) return t[n].apply(this, Array.prototype.slice.call(arguments, 1)); else if ("object" === typeof n || !n) // Default to "init"
                return t.init.apply(this, arguments); else e.error("Method " + n + " does not exist on jQuery.tabs");
            };
            e(document).ready(function() {
                e("ul.tabs").tabs();
            });
        }(l);
        !function(e) {
            e.fn.tooltip = function(n) {
                var i = null, r = 5;
                // Defaults
                var o = {
                    delay: 350,
                    tooltip: "",
                    position: "bottom",
                    html: !1
                };
                // Remove tooltip from the activator
                if ("remove" === n) {
                    this.each(function() {
                        e("#" + e(this).attr("data-tooltip-id")).remove();
                        e(this).removeAttr("data-tooltip-id");
                        e(this).off("mouseenter.tooltip mouseleave.tooltip");
                    });
                    return !1;
                }
                n = e.extend(o, n);
                return this.each(function() {
                    var i = Materialize.guid();
                    var o = e(this);
                    // Destroy old tooltip
                    if (o.attr("data-tooltip-id")) e("#" + o.attr("data-tooltip-id")).remove();
                    o.attr("data-tooltip-id", i);
                    // Get attributes.
                    var a, s, l, u, c, f;
                    var d = function() {
                        a = o.attr("data-html") ? "true" === o.attr("data-html") : n.html;
                        s = o.attr("data-delay");
                        s = s === undefined || "" === s ? n.delay : s;
                        l = o.attr("data-position");
                        l = l === undefined || "" === l ? n.position : l;
                        u = o.attr("data-tooltip");
                        u = u === undefined || "" === u ? n.tooltip : u;
                    };
                    d();
                    c = function() {
                        var t = e('<div class="material-tooltip"></div>');
                        // Create Text span
                        if (a) u = e("<span></span>").html(u); else u = e("<span></span>").text(u);
                        // Create tooltip
                        t.append(u).appendTo(e("body")).attr("id", i);
                        // Create backdrop
                        f = e('<div class="backdrop"></div>');
                        f.appendTo(t);
                        return t;
                    }();
                    // Destroy previously binded events
                    o.off("mouseenter.tooltip mouseleave.tooltip");
                    // Mouse In
                    var p = !1, h;
                    o.on({
                        "mouseenter.tooltip": function(e) {
                            var n = function() {
                                d();
                                p = !0;
                                c.velocity("stop");
                                f.velocity("stop");
                                c.css({
                                    visibility: "visible",
                                    left: "0px",
                                    top: "0px"
                                });
                                // Tooltip positioning
                                var e = o.outerWidth();
                                var n = o.outerHeight();
                                var i = c.outerHeight();
                                var a = c.outerWidth();
                                var s = "0px";
                                var u = "0px";
                                var h = f[0].offsetWidth;
                                var v = f[0].offsetHeight;
                                var g = 8;
                                var m = 8;
                                var y = 0;
                                var b, x, w;
                                if ("top" === l) {
                                    // Top Position
                                    b = o.offset().top - i - r;
                                    x = o.offset().left + e / 2 - a / 2;
                                    w = t(x, b, a, i);
                                    s = "-10px";
                                    f.css({
                                        bottom: 0,
                                        left: 0,
                                        borderRadius: "14px 14px 0 0",
                                        transformOrigin: "50% 100%",
                                        marginTop: i,
                                        marginLeft: a / 2 - h / 2
                                    });
                                } else if ("left" === l) {
                                    b = o.offset().top + n / 2 - i / 2;
                                    x = o.offset().left - a - r;
                                    w = t(x, b, a, i);
                                    u = "-10px";
                                    f.css({
                                        top: "-7px",
                                        right: 0,
                                        width: "14px",
                                        height: "14px",
                                        borderRadius: "14px 0 0 14px",
                                        transformOrigin: "95% 50%",
                                        marginTop: i / 2,
                                        marginLeft: a
                                    });
                                } else if ("right" === l) {
                                    b = o.offset().top + n / 2 - i / 2;
                                    x = o.offset().left + e + r;
                                    w = t(x, b, a, i);
                                    u = "+10px";
                                    f.css({
                                        top: "-7px",
                                        left: 0,
                                        width: "14px",
                                        height: "14px",
                                        borderRadius: "0 14px 14px 0",
                                        transformOrigin: "5% 50%",
                                        marginTop: i / 2,
                                        marginLeft: "0px"
                                    });
                                } else {
                                    // Bottom Position
                                    b = o.offset().top + o.outerHeight() + r;
                                    x = o.offset().left + e / 2 - a / 2;
                                    w = t(x, b, a, i);
                                    s = "+10px";
                                    f.css({
                                        top: 0,
                                        left: 0,
                                        marginLeft: a / 2 - h / 2
                                    });
                                }
                                // Set tooptip css placement
                                c.css({
                                    top: w.y,
                                    left: w.x
                                });
                                // Calculate Scale to fill
                                g = Math.SQRT2 * a / parseInt(h);
                                m = Math.SQRT2 * i / parseInt(v);
                                y = Math.max(g, m);
                                c.velocity({
                                    translateY: s,
                                    translateX: u
                                }, {
                                    duration: 350,
                                    queue: !1
                                }).velocity({
                                    opacity: 1
                                }, {
                                    duration: 300,
                                    delay: 50,
                                    queue: !1
                                });
                                f.css({
                                    visibility: "visible"
                                }).velocity({
                                    opacity: 1
                                }, {
                                    duration: 55,
                                    delay: 0,
                                    queue: !1
                                }).velocity({
                                    scaleX: y,
                                    scaleY: y
                                }, {
                                    duration: 300,
                                    delay: 0,
                                    queue: !1,
                                    easing: "easeInOutQuad"
                                });
                            };
                            h = setTimeout(n, s);
                        },
                        "mouseleave.tooltip": function() {
                            // Reset State
                            p = !1;
                            clearTimeout(h);
                            // Animate back
                            setTimeout(function() {
                                if (!0 !== p) {
                                    c.velocity({
                                        opacity: 0,
                                        translateY: 0,
                                        translateX: 0
                                    }, {
                                        duration: 225,
                                        queue: !1
                                    });
                                    f.velocity({
                                        opacity: 0,
                                        scaleX: 1,
                                        scaleY: 1
                                    }, {
                                        duration: 225,
                                        queue: !1,
                                        complete: function() {
                                            f.css({
                                                visibility: "hidden"
                                            });
                                            c.css({
                                                visibility: "hidden"
                                            });
                                            p = !1;
                                        }
                                    });
                                }
                            }, 225);
                        }
                    });
                });
            };
            var t = function(t, n, i, r) {
                var o = t;
                var a = n;
                if (o < 0) o = 4; else if (o + i > window.innerWidth) o -= o + i - window.innerWidth;
                if (a < 0) a = 4; else if (a + r > window.innerHeight + e(window).scrollTop) a -= a + r - window.innerHeight;
                return {
                    x: o,
                    y: a
                };
            };
            e(document).ready(function() {
                e(".tooltipped").tooltip();
            });
        }(l);
        !function(e) {
            "use strict";
            // Find exact position of element
            function t(e) {
                return null !== e && e === e.window;
            }
            function n(e) {
                return t(e) ? e : 9 === e.nodeType && e.defaultView;
            }
            function i(e) {
                var t, i, r = {
                    top: 0,
                    left: 0
                }, o = e && e.ownerDocument;
                t = o.documentElement;
                if (typeof e.getBoundingClientRect !== typeof undefined) r = e.getBoundingClientRect();
                i = n(o);
                return {
                    top: r.top + i.pageYOffset - t.clientTop,
                    left: r.left + i.pageXOffset - t.clientLeft
                };
            }
            function r(e) {
                var t = "";
                for (var n in e) if (e.hasOwnProperty(n)) t += n + ":" + e[n] + ";";
                return t;
            }
            /**
   * Delegated click handler for .waves-effect element.
   * returns null when .waves-effect element not in "click tree"
   */
            function o(e) {
                if (!1 === c.allowEvent(e)) return null;
                var t = null;
                var n = e.target || e.srcElement;
                for (;null !== n.parentNode; ) {
                    if (!(n instanceof SVGElement) && -1 !== n.className.indexOf("waves-effect")) {
                        t = n;
                        break;
                    }
                    n = n.parentNode;
                }
                return t;
            }
            /**
   * Bubble the click and show effect if .waves-effect elem was found
   */
            function a(t) {
                var n = o(t);
                if (null !== n) {
                    u.show(t, n);
                    if ("ontouchstart" in e) {
                        n.addEventListener("touchend", u.hide, !1);
                        n.addEventListener("touchcancel", u.hide, !1);
                    }
                    n.addEventListener("mouseup", u.hide, !1);
                    n.addEventListener("mouseleave", u.hide, !1);
                    n.addEventListener("dragend", u.hide, !1);
                }
            }
            var s = s || {};
            var l = document.querySelectorAll.bind(document);
            var u = {
                // Effect delay
                duration: 750,
                show: function(e, t) {
                    // Disable right click
                    if (2 === e.button) return !1;
                    var n = t || this;
                    // Create ripple
                    var o = document.createElement("div");
                    o.className = "waves-ripple";
                    n.appendChild(o);
                    // Get click coordinate and element witdh
                    var a = i(n);
                    var s = e.pageY - a.top;
                    var l = e.pageX - a.left;
                    var c = "scale(" + n.clientWidth / 100 * 10 + ")";
                    // Support for touch devices
                    if ("touches" in e) {
                        s = e.touches[0].pageY - a.top;
                        l = e.touches[0].pageX - a.left;
                    }
                    // Attach data to element
                    o.setAttribute("data-hold", Date.now());
                    o.setAttribute("data-scale", c);
                    o.setAttribute("data-x", l);
                    o.setAttribute("data-y", s);
                    // Set ripple position
                    var f = {
                        top: s + "px",
                        left: l + "px"
                    };
                    o.className = o.className + " waves-notransition";
                    o.setAttribute("style", r(f));
                    o.className = o.className.replace("waves-notransition", "");
                    // Scale the ripple
                    f["-webkit-transform"] = c;
                    f["-moz-transform"] = c;
                    f["-ms-transform"] = c;
                    f["-o-transform"] = c;
                    f.transform = c;
                    f.opacity = "1";
                    f["-webkit-transition-duration"] = u.duration + "ms";
                    f["-moz-transition-duration"] = u.duration + "ms";
                    f["-o-transition-duration"] = u.duration + "ms";
                    f["transition-duration"] = u.duration + "ms";
                    f["-webkit-transition-timing-function"] = "cubic-bezier(0.250, 0.460, 0.450, 0.940)";
                    f["-moz-transition-timing-function"] = "cubic-bezier(0.250, 0.460, 0.450, 0.940)";
                    f["-o-transition-timing-function"] = "cubic-bezier(0.250, 0.460, 0.450, 0.940)";
                    f["transition-timing-function"] = "cubic-bezier(0.250, 0.460, 0.450, 0.940)";
                    o.setAttribute("style", r(f));
                },
                hide: function(e) {
                    c.touchup(e);
                    var t = this;
                    var n = 1.4 * t.clientWidth;
                    // Get first ripple
                    var i = null;
                    var o = t.getElementsByClassName("waves-ripple");
                    if (o.length > 0) i = o[o.length - 1]; else return !1;
                    var a = i.getAttribute("data-x");
                    var s = i.getAttribute("data-y");
                    var l = i.getAttribute("data-scale");
                    // Get delay beetween mousedown and mouse leave
                    var f = Date.now() - Number(i.getAttribute("data-hold"));
                    var d = 350 - f;
                    if (d < 0) d = 0;
                    // Fade out ripple after delay
                    setTimeout(function() {
                        var e = {
                            top: s + "px",
                            left: a + "px",
                            opacity: "0",
                            // Duration
                            "-webkit-transition-duration": u.duration + "ms",
                            "-moz-transition-duration": u.duration + "ms",
                            "-o-transition-duration": u.duration + "ms",
                            "transition-duration": u.duration + "ms",
                            "-webkit-transform": l,
                            "-moz-transform": l,
                            "-ms-transform": l,
                            "-o-transform": l,
                            transform: l
                        };
                        i.setAttribute("style", r(e));
                        setTimeout(function() {
                            try {
                                t.removeChild(i);
                            } catch (e) {
                                return !1;
                            }
                        }, u.duration);
                    }, d);
                },
                // Little hack to make <input> can perform waves effect
                wrapInput: function(e) {
                    for (var t = 0; t < e.length; t++) {
                        var n = e[t];
                        if ("input" === n.tagName.toLowerCase()) {
                            var i = n.parentNode;
                            // If input already have parent just pass through
                            if ("i" === i.tagName.toLowerCase() && -1 !== i.className.indexOf("waves-effect")) continue;
                            // Put element class and style to the specified parent
                            var r = document.createElement("i");
                            r.className = n.className + " waves-input-wrapper";
                            var o = n.getAttribute("style");
                            if (!o) o = "";
                            r.setAttribute("style", o);
                            n.className = "waves-button-input";
                            n.removeAttribute("style");
                            // Put element as child
                            i.replaceChild(r, n);
                            r.appendChild(n);
                        }
                    }
                }
            };
            /**
   * Disable mousedown event for 500ms during and after touch
   */
            var c = {
                /* uses an integer rather than bool so there's no issues with
     * needing to clear timeouts if another touch event occurred
     * within the 500ms. Cannot mouseup between touchstart and
     * touchend, nor in the 500ms after touchend. */
                touches: 0,
                allowEvent: function(e) {
                    var t = !0;
                    if ("touchstart" === e.type) c.touches += 1; else if ("touchend" === e.type || "touchcancel" === e.type) setTimeout(function() {
                        if (c.touches > 0) c.touches -= 1;
                    }, 500); else if ("mousedown" === e.type && c.touches > 0) t = !1;
                    return t;
                },
                touchup: function(e) {
                    c.allowEvent(e);
                }
            };
            s.displayEffect = function(t) {
                t = t || {};
                if ("duration" in t) u.duration = t.duration;
                //Wrap input inside <i> tag
                u.wrapInput(l(".waves-effect"));
                if ("ontouchstart" in e) document.body.addEventListener("touchstart", a, !1);
                document.body.addEventListener("mousedown", a, !1);
            };
            /**
   * Attach Waves to an input element (or any element which doesn't
   * bubble mouseup/mousedown events).
   *   Intended to be used with dynamically loaded forms/inputs, or
   * where the user doesn't want a delegated click handler.
   */
            s.attach = function(t) {
                //FUTURE: automatically add waves classes and allow users
                // to specify them with an options param? Eg. light/classic/button
                if ("input" === t.tagName.toLowerCase()) {
                    u.wrapInput([ t ]);
                    t = t.parentNode;
                }
                if ("ontouchstart" in e) t.addEventListener("touchstart", a, !1);
                t.addEventListener("mousedown", a, !1);
            };
            e.Waves = s;
            document.addEventListener("DOMContentLoaded", function() {
                s.displayEffect();
            }, !1);
        }(window);
        !function(e) {
            "use strict";
            var t = {
                displayLength: Infinity,
                inDuration: 300,
                outDuration: 375,
                className: undefined,
                completeCallback: undefined,
                activationPercent: .8
            };
            var n = function() {
                function n(t, r, o, a) {
                    i(this, n);
                    if (!t) return;
                    /**
       * Options for the toast
       * @member Toast#options
       */
                    this.options = {
                        displayLength: r,
                        className: o,
                        completeCallback: a
                    };
                    this.options = e.extend({}, n.defaults, this.options);
                    this.message = t;
                    /**
       * Describes current pan state toast
       * @type {Boolean}
       */
                    this.panning = !1;
                    /**
       * Time remaining until toast is removed
       */
                    this.timeRemaining = this.options.displayLength;
                    if (0 === n._toasts.length) n._createContainer();
                    // Create new toast
                    n._toasts.push(this);
                    var s = this.createToast();
                    s.M_Toast = this;
                    this.el = s;
                    this._animateIn();
                    this.setTimer();
                }
                s(n, [ {
                    key: "createToast",
                    /**
       * Create toast and append it to toast container
       */
                    value: function r() {
                        var t = document.createElement("div");
                        t.classList.add("toast");
                        // Add custom classes onto toast
                        if (this.options.className) {
                            var i = this.options.className.split(" ");
                            var r = void 0, o = void 0;
                            for (r = 0, o = i.length; r < o; r++) t.classList.add(i[r]);
                        }
                        // Set content
                        if ("object" === typeof HTMLElement ? this.message instanceof HTMLElement : this.message && "object" === typeof this.message && null !== this.message && 1 === this.message.nodeType && "string" === typeof this.message.nodeName) t.appendChild(this.message); else if (this.message instanceof l) e(t).append(this.message); else t.innerHTML = this.message;
                        // Append toasft
                        n._container.appendChild(t);
                        return t;
                    }
                }, {
                    key: "_animateIn",
                    value: function o() {
                        // Animate toast in
                        c(this.el, {
                            top: 0,
                            opacity: 1
                        }, {
                            duration: 300,
                            easing: "easeOutCubic",
                            queue: !1
                        });
                    }
                }, {
                    key: "setTimer",
                    value: function a() {
                        var e = this;
                        if (this.timeRemaining !== Infinity) this.counterInterval = setInterval(function() {
                            // If toast is not being dragged, decrease its time remaining
                            if (!e.panning) e.timeRemaining -= 20;
                            // Animate toast out
                            if (e.timeRemaining <= 0) e.remove();
                        }, 20);
                    }
                }, {
                    key: "remove",
                    value: function u() {
                        var e = this;
                        window.clearInterval(this.counterInterval);
                        var t = this.el.offsetWidth * this.options.activationPercent;
                        if (this.wasSwiped) {
                            this.el.style.transition = "transform .05s, opacity .05s";
                            this.el.style.transform = "translateX(" + t + "px)";
                            this.el.style.opacity = 0;
                        }
                        c(this.el, {
                            opacity: 0,
                            marginTop: "-40px"
                        }, {
                            duration: this.options.outDuration,
                            easing: "easeOutExpo",
                            queue: !1,
                            complete: function() {
                                // Call the optional callback
                                if ("function" === typeof e.options.completeCallback) e.options.completeCallback();
                                // Remove toast from DOM
                                e.el.parentNode.removeChild(e.el);
                                n._toasts.splice(n._toasts.indexOf(e), 1);
                                if (0 === n._toasts.length) n._removeContainer();
                            }
                        });
                    }
                } ], [ {
                    key: "_createContainer",
                    /**
       * Append toast container and add event handlers
       */
                    value: function f() {
                        var e = document.createElement("div");
                        e.setAttribute("id", "toast-container");
                        // Add event handler
                        e.addEventListener("touchstart", n._onDragStart);
                        e.addEventListener("touchmove", n._onDragMove);
                        e.addEventListener("touchend", n._onDragEnd);
                        e.addEventListener("mousedown", n._onDragStart);
                        document.addEventListener("mousemove", n._onDragMove);
                        document.addEventListener("mouseup", n._onDragEnd);
                        document.body.appendChild(e);
                        n._container = e;
                    }
                }, {
                    key: "_removeContainer",
                    value: function d() {
                        // Add event handler
                        document.removeEventListener("mousemove", n._onDragMove);
                        document.removeEventListener("mouseup", n._onDragEnd);
                        n._container.parentNode.removeChild(n._container);
                        n._container = null;
                    }
                }, {
                    key: "_onDragStart",
                    value: function p(t) {
                        if (t.target && e(t.target).closest(".toast").length) {
                            var i = e(t.target).closest(".toast");
                            var r = i[0].M_Toast;
                            r.panning = !0;
                            n._draggedToast = r;
                            r.el.classList.add("panning");
                            r.el.style.transition = null;
                            r.startingXPos = n._xPos(t);
                            r.time = Date.now();
                            r.xPos = n._xPos(t);
                        }
                    }
                }, {
                    key: "_onDragMove",
                    value: function h(e) {
                        if (n._draggedToast) {
                            e.preventDefault();
                            var t = n._draggedToast;
                            t.deltaX = Math.abs(t.xPos - n._xPos(e));
                            t.xPos = n._xPos(e);
                            t.velocityX = t.deltaX / (Date.now() - t.time);
                            t.time = Date.now();
                            var i = t.xPos - t.startingXPos;
                            var r = t.el.offsetWidth * t.options.activationPercent;
                            t.el.style.transform = "translateX(" + i + "px)";
                            t.el.style.opacity = 1 - Math.abs(i / r);
                        }
                    }
                }, {
                    key: "_onDragEnd",
                    value: function v(e) {
                        if (n._draggedToast) {
                            var t = n._draggedToast;
                            t.panning = !1;
                            t.el.classList.remove("panning");
                            var i = t.xPos - t.startingXPos;
                            var r = t.el.offsetWidth * t.options.activationPercent;
                            // Remove toast
                            if (Math.abs(i) > r || t.velocityX > 1) {
                                t.wasSwiped = !0;
                                t.remove();
                            } else {
                                t.el.style.transition = "transform .2s, opacity .2s";
                                t.el.style.transform = null;
                                t.el.style.opacity = null;
                            }
                            n._draggedToast = null;
                        }
                    }
                }, {
                    key: "_xPos",
                    value: function g(e) {
                        if (e.targetTouches && e.targetTouches.length >= 1) return e.targetTouches[0].clientX;
                        // mouse event
                        return e.clientX;
                    }
                }, {
                    key: "removeAll",
                    value: function m() {
                        for (var e in n._toasts) n._toasts[e].remove();
                    }
                }, {
                    key: "defaults",
                    get: function() {
                        return t;
                    }
                } ]);
                return n;
            }();
            /**
   * @static
   * @memberof Toast
   * @type {Array.<Toast>}
   */
            n._toasts = [];
            /**
   * @static
   * @memberof Toast
   */
            n._container = null;
            /**
   * @static
   * @memberof Toast
   * @type {Toast}
   */
            n._draggedToast = null;
            window.Materialize.Toast = n;
            window.Materialize.toast = function(e, t, i, r) {
                return new n(e, t, i, r);
            };
        }(l);
        !function(e) {
            var t = {
                init: function(t) {
                    var n = {
                        menuWidth: 300,
                        edge: "left",
                        closeOnClick: !1,
                        draggable: !0,
                        onOpen: null,
                        onClose: null
                    };
                    t = e.extend(n, t);
                    e(this).each(function() {
                        var n = e(this);
                        var i = n.attr("data-activates");
                        var r = e("#" + i);
                        // Set to width
                        if (300 != t.menuWidth) r.css("width", t.menuWidth);
                        // Add Touch Area
                        var o = e('.drag-target[data-sidenav="' + i + '"]');
                        if (t.draggable) {
                            // Regenerate dragTarget
                            if (o.length) o.remove();
                            o = e('<div class="drag-target"></div>').attr("data-sidenav", i);
                            e("body").append(o);
                        } else o = e();
                        if ("left" == t.edge) {
                            r.css("transform", "translateX(-100%)");
                            o.css({
                                left: 0
                            });
                        } else {
                            r.addClass("right-aligned").css("transform", "translateX(100%)");
                            o.css({
                                right: 0
                            });
                        }
                        // If fixed sidenav, bring menu out
                        if (r.hasClass("fixed")) if (window.innerWidth > 992) r.css("transform", "translateX(0)");
                        // Window resize to reset on large screens fixed
                        if (r.hasClass("fixed")) e(window).resize(function() {
                            if (window.innerWidth > 992) // Close menu if window is resized bigger than 992 and user has fixed sidenav
                            if (0 !== e("#sidenav-overlay").length && l) a(!0); else // menu.removeAttr('style');
                            r.css("transform", "translateX(0%)"); else if (!1 === l) if ("left" === t.edge) r.css("transform", "translateX(-100%)"); else r.css("transform", "translateX(100%)");
                        });
                        // if closeOnClick, then add close event for all a tags in side sideNav
                        if (!0 === t.closeOnClick) r.on("click.itemclick", "a:not(.collapsible-header)", function() {
                            if (!(window.innerWidth > 992 && r.hasClass("fixed"))) a();
                        });
                        var a = function(n) {
                            s = !1;
                            l = !1;
                            // Reenable scrolling
                            e("body").css({
                                overflow: "",
                                width: ""
                            });
                            e("#sidenav-overlay").velocity({
                                opacity: 0
                            }, {
                                duration: 200,
                                queue: !1,
                                easing: "easeOutQuad",
                                complete: function() {
                                    e(this).remove();
                                }
                            });
                            if ("left" === t.edge) {
                                // Reset phantom div
                                o.css({
                                    width: "",
                                    right: "",
                                    left: "0"
                                });
                                r.velocity({
                                    translateX: "-100%"
                                }, {
                                    duration: 200,
                                    queue: !1,
                                    easing: "easeOutCubic",
                                    complete: function() {
                                        if (!0 === n) {
                                            // Restore Fixed sidenav
                                            r.removeAttr("style");
                                            r.css("width", t.menuWidth);
                                        }
                                    }
                                });
                            } else {
                                // Reset phantom div
                                o.css({
                                    width: "",
                                    right: "0",
                                    left: ""
                                });
                                r.velocity({
                                    translateX: "100%"
                                }, {
                                    duration: 200,
                                    queue: !1,
                                    easing: "easeOutCubic",
                                    complete: function() {
                                        if (!0 === n) {
                                            // Restore Fixed sidenav
                                            r.removeAttr("style");
                                            r.css("width", t.menuWidth);
                                        }
                                    }
                                });
                            }
                            // Callback
                            if ("function" === typeof t.onClose) t.onClose.call(this, r);
                        };
                        // Touch Event
                        var s = !1;
                        var l = !1;
                        if (t.draggable) {
                            o.on("click", function() {
                                if (l) a();
                            });
                            o.hammer({
                                prevent_default: !1
                            }).on("pan", function(n) {
                                if ("touch" == n.gesture.pointerType) {
                                    var i = n.gesture.direction;
                                    var o = n.gesture.center.x;
                                    var s = n.gesture.center.y;
                                    var u = n.gesture.velocityX;
                                    // Vertical scroll bugfix
                                    if (0 === o && 0 === s) return;
                                    // Disable Scrolling
                                    var c = e("body");
                                    var f = e("#sidenav-overlay");
                                    var d = c.innerWidth();
                                    c.css("overflow", "hidden");
                                    c.width(d);
                                    // If overlay does not exist, create one and if it is clicked, close menu
                                    if (0 === f.length) {
                                        f = e('<div id="sidenav-overlay"></div>');
                                        f.css("opacity", 0).click(function() {
                                            a();
                                        });
                                        // Run 'onOpen' when sidenav is opened via touch/swipe if applicable
                                        if ("function" === typeof t.onOpen) t.onOpen.call(this, r);
                                        e("body").append(f);
                                    }
                                    // Keep within boundaries
                                    if ("left" === t.edge) if (o > t.menuWidth) o = t.menuWidth; else if (o < 0) o = 0;
                                    if ("left" === t.edge) {
                                        // Left Direction
                                        if (o < t.menuWidth / 2) l = !1; else if (o >= t.menuWidth / 2) l = !0;
                                        r.css("transform", "translateX(" + (o - t.menuWidth) + "px)");
                                    } else {
                                        // Left Direction
                                        if (o < window.innerWidth - t.menuWidth / 2) l = !0; else if (o >= window.innerWidth - t.menuWidth / 2) l = !1;
                                        var p = o - t.menuWidth / 2;
                                        if (p < 0) p = 0;
                                        r.css("transform", "translateX(" + p + "px)");
                                    }
                                    // Percentage overlay
                                    var h;
                                    if ("left" === t.edge) {
                                        h = o / t.menuWidth;
                                        f.velocity({
                                            opacity: h
                                        }, {
                                            duration: 10,
                                            queue: !1,
                                            easing: "easeOutQuad"
                                        });
                                    } else {
                                        h = Math.abs((o - window.innerWidth) / t.menuWidth);
                                        f.velocity({
                                            opacity: h
                                        }, {
                                            duration: 10,
                                            queue: !1,
                                            easing: "easeOutQuad"
                                        });
                                    }
                                }
                            }).on("panend", function(n) {
                                if ("touch" == n.gesture.pointerType) {
                                    var i = e("#sidenav-overlay");
                                    var a = n.gesture.velocityX;
                                    var u = n.gesture.center.x;
                                    var c = u - t.menuWidth;
                                    var f = u - t.menuWidth / 2;
                                    if (c > 0) c = 0;
                                    if (f < 0) f = 0;
                                    s = !1;
                                    if ("left" === t.edge) {
                                        // If velocityX <= 0.3 then the user is flinging the menu closed so ignore menuOut
                                        if (l && a <= .3 || a < -.5) {
                                            // Return menu to open
                                            if (0 !== c) r.velocity({
                                                translateX: [ 0, c ]
                                            }, {
                                                duration: 300,
                                                queue: !1,
                                                easing: "easeOutQuad"
                                            });
                                            i.velocity({
                                                opacity: 1
                                            }, {
                                                duration: 50,
                                                queue: !1,
                                                easing: "easeOutQuad"
                                            });
                                            o.css({
                                                width: "50%",
                                                right: 0,
                                                left: ""
                                            });
                                            l = !0;
                                        } else if (!l || a > .3) {
                                            // Enable Scrolling
                                            e("body").css({
                                                overflow: "",
                                                width: ""
                                            });
                                            // Slide menu closed
                                            r.velocity({
                                                translateX: [ -1 * t.menuWidth - 10, c ]
                                            }, {
                                                duration: 200,
                                                queue: !1,
                                                easing: "easeOutQuad"
                                            });
                                            i.velocity({
                                                opacity: 0
                                            }, {
                                                duration: 200,
                                                queue: !1,
                                                easing: "easeOutQuad",
                                                complete: function() {
                                                    // Run 'onClose' when sidenav is closed via touch/swipe if applicable
                                                    if ("function" === typeof t.onClose) t.onClose.call(this, r);
                                                    e(this).remove();
                                                }
                                            });
                                            o.css({
                                                width: "10px",
                                                right: "",
                                                left: 0
                                            });
                                        }
                                    } else if (l && a >= -.3 || a > .5) {
                                        // Return menu to open
                                        if (0 !== f) r.velocity({
                                            translateX: [ 0, f ]
                                        }, {
                                            duration: 300,
                                            queue: !1,
                                            easing: "easeOutQuad"
                                        });
                                        i.velocity({
                                            opacity: 1
                                        }, {
                                            duration: 50,
                                            queue: !1,
                                            easing: "easeOutQuad"
                                        });
                                        o.css({
                                            width: "50%",
                                            right: "",
                                            left: 0
                                        });
                                        l = !0;
                                    } else if (!l || a < -.3) {
                                        // Enable Scrolling
                                        e("body").css({
                                            overflow: "",
                                            width: ""
                                        });
                                        // Slide menu closed
                                        r.velocity({
                                            translateX: [ t.menuWidth + 10, f ]
                                        }, {
                                            duration: 200,
                                            queue: !1,
                                            easing: "easeOutQuad"
                                        });
                                        i.velocity({
                                            opacity: 0
                                        }, {
                                            duration: 200,
                                            queue: !1,
                                            easing: "easeOutQuad",
                                            complete: function() {
                                                // Run 'onClose' when sidenav is closed via touch/swipe if applicable
                                                if ("function" === typeof t.onClose) t.onClose.call(this, r);
                                                e(this).remove();
                                            }
                                        });
                                        o.css({
                                            width: "10px",
                                            right: 0,
                                            left: ""
                                        });
                                    }
                                }
                            });
                        }
                        n.off("click.sidenav").on("click.sidenav", function() {
                            if (!0 === l) {
                                l = !1;
                                s = !1;
                                a();
                            } else {
                                // Disable Scrolling
                                var n = e("body");
                                var i = e('<div id="sidenav-overlay"></div>');
                                var u = n.innerWidth();
                                n.css("overflow", "hidden");
                                n.width(u);
                                // Push current drag target on top of DOM tree
                                e("body").append(o);
                                if ("left" === t.edge) {
                                    o.css({
                                        width: "50%",
                                        right: 0,
                                        left: ""
                                    });
                                    r.velocity({
                                        translateX: [ 0, -1 * t.menuWidth ]
                                    }, {
                                        duration: 300,
                                        queue: !1,
                                        easing: "easeOutQuad"
                                    });
                                } else {
                                    o.css({
                                        width: "50%",
                                        right: "",
                                        left: 0
                                    });
                                    r.velocity({
                                        translateX: [ 0, t.menuWidth ]
                                    }, {
                                        duration: 300,
                                        queue: !1,
                                        easing: "easeOutQuad"
                                    });
                                }
                                // Overlay close on click
                                i.css("opacity", 0).click(function() {
                                    l = !1;
                                    s = !1;
                                    a();
                                    i.velocity({
                                        opacity: 0
                                    }, {
                                        duration: 300,
                                        queue: !1,
                                        easing: "easeOutQuad",
                                        complete: function() {
                                            e(this).remove();
                                        }
                                    });
                                });
                                // Append body
                                e("body").append(i);
                                i.velocity({
                                    opacity: 1
                                }, {
                                    duration: 300,
                                    queue: !1,
                                    easing: "easeOutQuad",
                                    complete: function() {
                                        l = !0;
                                        s = !1;
                                    }
                                });
                                // Callback
                                if ("function" === typeof t.onOpen) t.onOpen.call(this, r);
                            }
                            return !1;
                        });
                    });
                },
                destroy: function() {
                    var t = e("#sidenav-overlay");
                    var n = e('.drag-target[data-sidenav="' + e(this).attr("data-activates") + '"]');
                    t.trigger("click");
                    n.remove();
                    e(this).off("click");
                    t.remove();
                },
                show: function() {
                    this.trigger("click");
                },
                hide: function() {
                    e("#sidenav-overlay").trigger("click");
                }
            };
            e.fn.sideNav = function(n) {
                if (t[n]) return t[n].apply(this, Array.prototype.slice.call(arguments, 1)); else if ("object" === typeof n || !n) // Default to "init"
                return t.init.apply(this, arguments); else e.error("Method " + n + " does not exist on jQuery.sideNav");
            };
        }(l);
        /**
  * Extend jquery with a scrollspy plugin.
  * This watches the window scroll and fires events when elements are scrolled into viewport.
  *
  * throttle() and getTime() taken from Underscore.js
  * https://github.com/jashkenas/underscore
  *
  * @author Copyright 2013 John Smart
  * @license https://raw.github.com/thesmart/jquery-scrollspy/master/LICENSE
  * @see https://github.com/thesmart
  * @version 0.1.2
  */
        !function(e) {
            function t(t, n, i, r) {
                var a = e();
                e.each(o, function(e, o) {
                    if (o.height() > 0) {
                        var s = o.offset().top, l = o.offset().left, u = l + o.width(), c = s + o.height();
                        if (!(l > n || u < r || s > i || c < t)) a.push(o);
                    }
                });
                return a;
            }
            /**
   * Called when the user scrolls the window
   */
            function n(n) {
                // unique tick id
                ++l;
                // viewport rectangle
                var i = r.scrollTop(), o = r.scrollLeft(), s = o + r.width(), u = i + r.height();
                // determine which elements are in view
                var f = t(i + c.top + n || 200, s + c.right, u + c.bottom, o + c.left);
                e.each(f, function(e, t) {
                    if ("number" != typeof t.data("scrollSpy:ticks")) // entered into view
                    t.triggerHandler("scrollSpy:enter");
                    // update tick id
                    t.data("scrollSpy:ticks", l);
                });
                // determine which elements are no longer in view
                e.each(a, function(e, t) {
                    var n = t.data("scrollSpy:ticks");
                    if ("number" == typeof n && n !== l) {
                        // exited from view
                        t.triggerHandler("scrollSpy:exit");
                        t.data("scrollSpy:ticks", null);
                    }
                });
                // remember elements in view for next tick
                a = f;
            }
            /**
   * Called when window is resized
  */
            function i() {
                r.trigger("scrollSpy:winSize");
            }
            var r = e(window);
            var o = [];
            var a = [];
            var s = !1;
            var l = 0;
            var u = 1;
            var c = {
                top: 0,
                right: 0,
                bottom: 0,
                left: 0
            };
            /**
   * Enables ScrollSpy using a selector
   * @param {jQuery|string} selector  The elements collection, or a selector
   * @param {Object=} options	Optional.
         throttle : number -> scrollspy throttling. Default: 100 ms
         offsetTop : number -> offset from top. Default: 0
         offsetRight : number -> offset from right. Default: 0
         offsetBottom : number -> offset from bottom. Default: 0
         offsetLeft : number -> offset from left. Default: 0
  			activeClass : string -> Class name to be added to the active link. Default: active
   * @returns {jQuery}
   */
            e.scrollSpy = function(t, i) {
                var a = {
                    throttle: 100,
                    scrollOffset: 200,
                    // offset - 200 allows elements near bottom of page to scroll
                    activeClass: "active",
                    getActiveElement: function(e) {
                        return 'a[href="#' + e + '"]';
                    }
                };
                i = e.extend(a, i);
                var l = [];
                t = e(t);
                t.each(function(t, n) {
                    o.push(e(n));
                    e(n).data("scrollSpy:id", t);
                    // Smooth scroll to section
                    e('a[href="#' + e(n).attr("id") + '"]').click(function(t) {
                        t.preventDefault();
                        var n = e(Materialize.escapeHash(this.hash)).offset().top + 1;
                        e("html, body").animate({
                            scrollTop: n - i.scrollOffset
                        }, {
                            duration: 400,
                            queue: !1,
                            easing: "easeOutCubic"
                        });
                    });
                });
                c.top = i.offsetTop || 0;
                c.right = i.offsetRight || 0;
                c.bottom = i.offsetBottom || 0;
                c.left = i.offsetLeft || 0;
                var u = Materialize.throttle(function() {
                    n(i.scrollOffset);
                }, i.throttle || 100);
                var f = function() {
                    e(document).ready(u);
                };
                if (!s) {
                    r.on("scroll", f);
                    r.on("resize", f);
                    s = !0;
                }
                // perform a scan once, after current execution context, and after dom is ready
                setTimeout(f, 0);
                t.on("scrollSpy:enter", function() {
                    l = e.grep(l, function(e) {
                        return 0 != e.height();
                    });
                    var t = e(this);
                    if (l[0]) {
                        e(i.getActiveElement(l[0].attr("id"))).removeClass(i.activeClass);
                        if (t.data("scrollSpy:id") < l[0].data("scrollSpy:id")) l.unshift(e(this)); else l.push(e(this));
                    } else l.push(e(this));
                    e(i.getActiveElement(l[0].attr("id"))).addClass(i.activeClass);
                });
                t.on("scrollSpy:exit", function() {
                    l = e.grep(l, function(e) {
                        return 0 != e.height();
                    });
                    if (l[0]) {
                        e(i.getActiveElement(l[0].attr("id"))).removeClass(i.activeClass);
                        var t = e(this);
                        l = e.grep(l, function(e) {
                            return e.attr("id") != t.attr("id");
                        });
                        if (l[0]) // Check if empty
                        e(i.getActiveElement(l[0].attr("id"))).addClass(i.activeClass);
                    }
                });
                return t;
            };
            /**
   * Listen for window resize events
   * @param {Object=} options						Optional. Set { throttle: number } to change throttling. Default: 100 ms
   * @returns {jQuery}		$(window)
   */
            e.winSizeSpy = function(t) {
                e.winSizeSpy = function() {
                    return r;
                };
                // lock from multiple calls
                t = t || {
                    throttle: 100
                };
                return r.on("resize", Materialize.throttle(i, t.throttle || 100));
            };
            /**
   * Enables ScrollSpy on a collection of elements
   * e.g. $('.scrollSpy').scrollSpy()
   * @param {Object=} options	Optional.
  										throttle : number -> scrollspy throttling. Default: 100 ms
  										offsetTop : number -> offset from top. Default: 0
  										offsetRight : number -> offset from right. Default: 0
  										offsetBottom : number -> offset from bottom. Default: 0
  										offsetLeft : number -> offset from left. Default: 0
   * @returns {jQuery}
   */
            e.fn.scrollSpy = function(t) {
                return e.scrollSpy(e(this), t);
            };
        }(l);
        !function(e) {
            e(document).ready(function() {
                function t(t) {
                    // Set font properties of hiddenDiv
                    var n = t.css("font-family");
                    var r = t.css("font-size");
                    var o = t.css("line-height");
                    var a = t.css("padding");
                    if (r) i.css("font-size", r);
                    if (n) i.css("font-family", n);
                    if (o) i.css("line-height", o);
                    if (a) i.css("padding", a);
                    // Set original-height, if none
                    if (!t.data("original-height")) t.data("original-height", t.height());
                    if ("off" === t.attr("wrap")) i.css("overflow-wrap", "normal").css("white-space", "pre");
                    i.text(t.val() + "\n");
                    var s = i.html().replace(/\n/g, "<br>");
                    i.html(s);
                    // When textarea is hidden, width goes crazy.
                    // Approximate with half of window size
                    if (t.is(":visible")) i.css("width", t.width()); else i.css("width", e(window).width() / 2);
                    /**
       * Resize if the new height is greater than the
       * original height of the textarea
       */
                    if (t.data("original-height") <= i.height()) t.css("height", i.height()); else if (t.val().length < t.data("previous-length")) /**
         * In case the new height is less than original height, it
         * means the textarea has less text than before
         * So we set the height to the original one
         */
                    t.css("height", t.data("original-height"));
                    t.data("previous-length", t.val().length);
                }
                // Function to update labels of text fields
                Materialize.updateTextFields = function() {
                    e("input[type=text], input[type=password], input[type=email], input[type=url], input[type=tel], input[type=number], input[type=search], textarea").each(function(t, n) {
                        var i = e(this);
                        if (e(n).val().length > 0 || e(n).is(":focus") || n.autofocus || i.attr("placeholder") !== undefined) i.siblings("label").addClass("active"); else if (e(n)[0].validity) i.siblings("label").toggleClass("active", !0 === e(n)[0].validity.badInput); else i.siblings("label").removeClass("active");
                    });
                };
                // Text based inputs
                var n = "input[type=text], input[type=password], input[type=email], input[type=url], input[type=tel], input[type=number], input[type=search], textarea";
                // Add active if form auto complete
                e(document).on("change", n, function() {
                    if (0 !== e(this).val().length || e(this).attr("placeholder") !== undefined) e(this).siblings("label").addClass("active");
                    validate_field(e(this));
                });
                // Add active if input element has been pre-populated on document ready
                e(document).ready(function() {
                    Materialize.updateTextFields();
                });
                // HTML DOM FORM RESET handling
                e(document).on("reset", function(t) {
                    var i = e(t.target);
                    if (i.is("form")) {
                        i.find(n).removeClass("valid").removeClass("invalid");
                        i.find(n).each(function() {
                            if ("" === e(this).attr("value")) e(this).siblings("label").removeClass("active");
                        });
                        // Reset select
                        i.find("select.initialized").each(function() {
                            var e = i.find("option[selected]").text();
                            i.siblings("input.select-dropdown").val(e);
                        });
                    }
                });
                // Add active when element has focus
                e(document).on("focus", n, function() {
                    e(this).siblings("label, .prefix").addClass("active");
                });
                e(document).on("blur", n, function() {
                    var t = e(this);
                    var n = ".prefix";
                    if (0 === t.val().length && !0 !== t[0].validity.badInput && t.attr("placeholder") === undefined) n += ", label";
                    t.siblings(n).removeClass("active");
                    validate_field(t);
                });
                window.validate_field = function(e) {
                    var t = e.attr("data-length") !== undefined;
                    var n = parseInt(e.attr("data-length"));
                    var i = e.val().length;
                    if (0 === e.val().length && !1 === e[0].validity.badInput && !e.is(":required")) {
                        if (e.hasClass("validate")) {
                            e.removeClass("valid");
                            e.removeClass("invalid");
                        }
                    } else if (e.hasClass("validate")) // Check for character counter attributes
                    if (e.is(":valid") && t && i <= n || e.is(":valid") && !t) {
                        e.removeClass("invalid");
                        e.addClass("valid");
                    } else {
                        e.removeClass("valid");
                        e.addClass("invalid");
                    }
                };
                e(document).on("keyup.radio", "input[type=radio], input[type=checkbox]", function(t) {
                    // TAB, check if tabbing to radio or checkbox.
                    if (9 === t.which) {
                        e(this).addClass("tabbed");
                        e(this).one("blur", function(t) {
                            e(this).removeClass("tabbed");
                        });
                        return;
                    }
                });
                // Textarea Auto Resize
                var i = e(".hiddendiv").first();
                if (!i.length) {
                    i = e('<div class="hiddendiv common"></div>');
                    e("body").append(i);
                }
                var r = ".materialize-textarea";
                e(r).each(function() {
                    var t = e(this);
                    /**
       * Instead of resizing textarea on document load,
       * store the original height and the original length
       */
                    t.data("original-height", t.height());
                    t.data("previous-length", t.val().length);
                });
                e("body").on("keyup keydown autoresize", r, function() {
                    t(e(this));
                });
                // File Input Path
                e(document).on("change", '.file-field input[type="file"]', function() {
                    var t = e(this).closest(".file-field");
                    var n = t.find("input.file-path");
                    var i = e(this)[0].files;
                    var r = [];
                    for (var o = 0; o < i.length; o++) r.push(i[o].name);
                    n.val(r.join(", "));
                    n.trigger("change");
                });
                /****************
    *  Range Input  *
    ****************/
                var o = "input[type=range]";
                var a = !1;
                var s;
                e(o).each(function() {
                    var t = e('<span class="thumb"><span class="value"></span></span>');
                    e(this).after(t);
                });
                var l = function(e) {
                    var t = parseInt(e.parent().css("padding-left"));
                    var n = -7 + t + "px";
                    e.velocity({
                        height: "30px",
                        width: "30px",
                        top: "-30px",
                        marginLeft: n
                    }, {
                        duration: 300,
                        easing: "easeOutExpo"
                    });
                };
                var u = function(e) {
                    var t = e.width() - 15;
                    var n = parseFloat(e.attr("max"));
                    var i = parseFloat(e.attr("min"));
                    return (parseFloat(e.val()) - i) / (n - i) * t;
                };
                var c = ".range-field";
                e(document).on("change", o, function(t) {
                    var n = e(this).siblings(".thumb");
                    n.find(".value").html(e(this).val());
                    if (!n.hasClass("active")) l(n);
                    var i = u(e(this));
                    n.addClass("active").css("left", i);
                });
                e(document).on("mousedown touchstart", o, function(t) {
                    var n = e(this).siblings(".thumb");
                    // If thumb indicator does not exist yet, create it
                    if (n.length <= 0) {
                        n = e('<span class="thumb"><span class="value"></span></span>');
                        e(this).after(n);
                    }
                    // Set indicator value
                    n.find(".value").html(e(this).val());
                    a = !0;
                    e(this).addClass("active");
                    if (!n.hasClass("active")) l(n);
                    if ("input" !== t.type) {
                        var i = u(e(this));
                        n.addClass("active").css("left", i);
                    }
                });
                e(document).on("mouseup touchend", c, function() {
                    a = !1;
                    e(this).removeClass("active");
                });
                e(document).on("input mousemove touchmove", c, function(t) {
                    var n = e(this).children(".thumb");
                    var i;
                    var r = e(this).find(o);
                    if (a) {
                        if (!n.hasClass("active")) l(n);
                        var s = u(r);
                        n.addClass("active").css("left", s);
                        n.find(".value").html(n.siblings(o).val());
                    }
                });
                e(document).on("mouseout touchleave", c, function() {
                    if (!a) {
                        var t = e(this).children(".thumb");
                        var n = parseInt(e(this).css("padding-left"));
                        var i = 7 + n + "px";
                        if (t.hasClass("active")) t.velocity({
                            height: "0",
                            width: "0",
                            top: "10px",
                            marginLeft: i
                        }, {
                            duration: 100
                        });
                        t.removeClass("active");
                    }
                });
                /**************************
     * Auto complete plugin  *
     *************************/
                e.fn.autocomplete = function(t) {
                    // Defaults
                    var n = {
                        data: {},
                        limit: Infinity,
                        onAutocomplete: null,
                        minLength: 1
                    };
                    t = e.extend(n, t);
                    return this.each(function() {
                        var n = e(this);
                        var i = t.data, r = 0, o = -1, a, s = n.closest(".input-field");
                        // Div to append on
                        // Check if data isn't empty
                        if (!e.isEmptyObject(i)) {
                            var l = e('<ul class="autocomplete-content dropdown-content"></ul>');
                            var u;
                            // Append autocomplete element.
                            // Prevent double structure init.
                            if (s.length) {
                                u = s.children(".autocomplete-content.dropdown-content").first();
                                if (!u.length) s.append(l);
                            } else {
                                u = n.next(".autocomplete-content.dropdown-content");
                                if (!u.length) n.after(l);
                            }
                            if (u.length) l = u;
                            // Highlight partial match.
                            var c = function(e, t) {
                                var n = t.find("img");
                                var i = t.text().toLowerCase().indexOf("" + e.toLowerCase()), r = i + e.length - 1, o = t.text().slice(0, i), a = t.text().slice(i, r + 1), s = t.text().slice(r + 1);
                                t.html("<span>" + o + "<span class='highlight'>" + a + "</span>" + s + "</span>");
                                if (n.length) t.prepend(n);
                            };
                            // Reset current element position
                            var f = function() {
                                o = -1;
                                l.find(".active").removeClass("active");
                            };
                            // Remove autocomplete elements
                            var d = function() {
                                l.empty();
                                f();
                                a = undefined;
                            };
                            n.off("blur.autocomplete").on("blur.autocomplete", function() {
                                d();
                            });
                            // Perform search
                            n.off("keyup.autocomplete focus.autocomplete").on("keyup.autocomplete focus.autocomplete", function(o) {
                                // Reset count.
                                r = 0;
                                var s = n.val().toLowerCase();
                                // Don't capture enter or arrow key usage.
                                if (13 === o.which || 38 === o.which || 40 === o.which) return;
                                // Check if the input isn't empty
                                if (a !== s) {
                                    d();
                                    if (s.length >= t.minLength) for (var u in i) if (i.hasOwnProperty(u) && -1 !== u.toLowerCase().indexOf(s)) {
                                        // Break if past limit
                                        if (r >= t.limit) break;
                                        var f = e("<li></li>");
                                        if (i[u]) f.append('<img src="' + i[u] + '" class="right circle"><span>' + u + "</span>"); else f.append("<span>" + u + "</span>");
                                        l.append(f);
                                        c(s, f);
                                        r++;
                                    }
                                }
                                // Update oldVal
                                a = s;
                            });
                            n.off("keydown.autocomplete").on("keydown.autocomplete", function(e) {
                                // Arrow keys and enter key usage
                                var t = e.which, n, i = l.children("li").length, r = l.children(".active").first();
                                // select element on Enter
                                if (13 === t && o >= 0) {
                                    n = l.children("li").eq(o);
                                    if (n.length) {
                                        n.trigger("mousedown.autocomplete");
                                        e.preventDefault();
                                    }
                                    return;
                                }
                                // Capture up and down key
                                if (38 === t || 40 === t) {
                                    e.preventDefault();
                                    if (38 === t && o > 0) o--;
                                    if (40 === t && o < i - 1) o++;
                                    r.removeClass("active");
                                    if (o >= 0) l.children("li").eq(o).addClass("active");
                                }
                            });
                            // Set input value
                            l.off("mousedown.autocomplete touchstart.autocomplete").on("mousedown.autocomplete touchstart.autocomplete", "li", function() {
                                var i = e(this).text().trim();
                                n.val(i);
                                n.trigger("change");
                                d();
                                // Handle onAutocomplete callback.
                                if ("function" === typeof t.onAutocomplete) t.onAutocomplete.call(this, i);
                            });
                        } else n.off("keyup.autocomplete focus.autocomplete");
                    });
                };
            });
            // End of $(document).ready
            /*******************
   *  Select Plugin  *
   ******************/
            e.fn.material_select = function(t) {
                function n(e, t, n) {
                    var r = e.indexOf(t), o = -1 === r;
                    if (o) e.push(t); else e.splice(r, 1);
                    n.siblings("ul.dropdown-content").find("li:not(.optgroup)").eq(t).toggleClass("active");
                    // use notAdded instead of true (to detect if the option is selected or not)
                    n.find("option").eq(t).prop("selected", o);
                    i(e, n);
                    return o;
                }
                function i(e, t) {
                    var n = "";
                    for (var i = 0, r = e.length; i < r; i++) {
                        var o = t.find("option").eq(e[i]).text();
                        0 === i ? n += o : n += ", " + o;
                    }
                    if ("" === n) n = t.find("option:disabled").eq(0).text();
                    t.siblings("input.select-dropdown").val(n);
                }
                e(this).each(function() {
                    var i = e(this);
                    if (i.hasClass("browser-default")) return;
                    var r = i.attr("multiple") ? !0 : !1, o = i.attr("data-select-id");
                    // Tear down structure if Select needs to be rebuilt
                    if (o) {
                        i.parent().find("span.caret").remove();
                        i.parent().find("input").remove();
                        i.unwrap();
                        e("ul#select-options-" + o).remove();
                    }
                    // If destroying the select, remove the selelct-id and reset it to it's uninitialized state.
                    if ("destroy" === t) {
                        i.removeAttr("data-select-id").removeClass("initialized");
                        e(window).off("click.select");
                        return;
                    }
                    var a = Materialize.guid();
                    i.attr("data-select-id", a);
                    var s = e('<div class="select-wrapper"></div>');
                    s.addClass(i.attr("class"));
                    if (i.is(":disabled")) s.addClass("disabled");
                    var l = e('<ul id="select-options-' + a + '" class="dropdown-content select-dropdown ' + (r ? "multiple-select-dropdown" : "") + '"></ul>'), u = i.children("option, optgroup"), c = [], f = !1;
                    var d = i.find("option:selected").html() || i.find("option:first").html() || "";
                    // Function that renders and appends the option taking into
                    // account type and possible image icon.
                    var p = function(t, n, i) {
                        // Add disabled attr if disabled
                        var o = n.is(":disabled") ? "disabled " : "";
                        var a = "optgroup-option" === i ? "optgroup-option " : "";
                        var s = r ? '<input type="checkbox"' + o + "/><label></label>" : "";
                        // add icons
                        var u = n.data("icon");
                        var c = n.attr("class");
                        if (u) {
                            var f = "";
                            if (c) f = ' class="' + c + '"';
                            // Check for multiple type.
                            l.append(e('<li class="' + o + a + '"><img alt="" src="' + u + '"' + f + "><span>" + s + n.html() + "</span></li>"));
                            return !0;
                        }
                        // Check for multiple type.
                        l.append(e('<li class="' + o + a + '"><span>' + s + n.html() + "</span></li>"));
                    };
                    /* Create dropdown structure. */
                    if (u.length) u.each(function() {
                        if (e(this).is("option")) // Direct descendant option.
                        if (r) p(i, e(this), "multiple"); else p(i, e(this)); else if (e(this).is("optgroup")) {
                            // Optgroup.
                            var t = e(this).children("option");
                            l.append(e('<li class="optgroup"><span>' + e(this).attr("label") + "</span></li>"));
                            t.each(function() {
                                p(i, e(this), "optgroup-option");
                            });
                        }
                    });
                    l.find("li:not(.optgroup)").each(function(o) {
                        e(this).click(function(a) {
                            // Check if option element is disabled
                            if (!e(this).hasClass("disabled") && !e(this).hasClass("optgroup")) {
                                var s = !0;
                                if (r) {
                                    e('input[type="checkbox"]', this).prop("checked", function(e, t) {
                                        return !t;
                                    });
                                    s = n(c, o, i);
                                    g.trigger("focus");
                                } else {
                                    l.find("li").removeClass("active");
                                    e(this).toggleClass("active");
                                    g.val(e(this).text());
                                }
                                m(l, e(this));
                                i.find("option").eq(o).prop("selected", s);
                                // Trigger onchange() event
                                i.trigger("change");
                                if ("undefined" !== typeof t) t();
                            }
                            a.stopPropagation();
                        });
                    });
                    // Wrap Elements
                    i.wrap(s);
                    // Add Select Display Element
                    var h = e('<span class="caret">&#9660;</span>');
                    // escape double quotes
                    var v = d.replace(/"/g, "&quot;");
                    var g = e('<input type="text" class="select-dropdown" readonly="true" ' + (i.is(":disabled") ? "disabled" : "") + ' data-activates="select-options-' + a + '" value="' + v + '"/>');
                    i.before(g);
                    g.before(h);
                    g.after(l);
                    // Check if section element is disabled
                    if (!i.is(":disabled")) g.dropdown({
                        hover: !1
                    });
                    // Copy tabindex
                    if (i.attr("tabindex")) e(g[0]).attr("tabindex", i.attr("tabindex"));
                    i.addClass("initialized");
                    g.on({
                        focus: function() {
                            if (e("ul.select-dropdown").not(l[0]).is(":visible")) {
                                e("input.select-dropdown").trigger("close");
                                e(window).off("click.select");
                            }
                            if (!l.is(":visible")) {
                                e(this).trigger("open", [ "focus" ]);
                                var t = e(this).val();
                                if (r && t.indexOf(",") >= 0) t = t.split(",")[0];
                                var n = l.find("li").filter(function() {
                                    return e(this).text().toLowerCase() === t.toLowerCase();
                                })[0];
                                m(l, n, !0);
                                e(window).off("click.select").on("click.select", function() {
                                    r && (f || g.trigger("close"));
                                    e(window).off("click.select");
                                });
                            }
                        },
                        click: function(e) {
                            e.stopPropagation();
                        }
                    });
                    g.on("blur", function() {
                        if (!r) {
                            e(this).trigger("close");
                            e(window).off("click.select");
                        }
                        l.find("li.selected").removeClass("selected");
                    });
                    l.hover(function() {
                        f = !0;
                    }, function() {
                        f = !1;
                    });
                    // Add initial multiple selections.
                    if (r) i.find("option:selected:not(:disabled)").each(function() {
                        var t = e(this).index();
                        n(c, t, i);
                        l.find("li").eq(t).find(":checkbox").prop("checked", !0);
                    });
                    /**
       * Make option as selected and scroll to selected position
       * @param {jQuery} collection  Select options jQuery element
       * @param {Element} newOption  element of the new option
       * @param {Boolean} firstActivation  If on first activation of select
       */
                    var m = function(t, n, i) {
                        if (n) {
                            t.find("li.selected").removeClass("selected");
                            var o = e(n);
                            o.addClass("selected");
                            if (!r || i) l.scrollTo(o);
                        }
                    };
                    // Allow user to search by typing
                    // this array is cleared after 1 second
                    var y = [], b = function(t) {
                        // TAB - switch to another input
                        if (9 == t.which) {
                            g.trigger("close");
                            return;
                        }
                        // ARROW DOWN WHEN SELECT IS CLOSED - open select options
                        if (40 == t.which && !l.is(":visible")) {
                            g.trigger("open");
                            return;
                        }
                        // ENTER WHEN SELECT IS CLOSED - submit form
                        if (13 == t.which && !l.is(":visible")) return;
                        t.preventDefault();
                        // CASE WHEN USER TYPE LETTERS
                        var n = String.fromCharCode(t.which).toLowerCase(), i = [ 9, 13, 27, 38, 40 ];
                        if (n && -1 === i.indexOf(t.which)) {
                            y.push(n);
                            var o = y.join(""), a = l.find("li").filter(function() {
                                return 0 === e(this).text().toLowerCase().indexOf(o);
                            })[0];
                            if (a) m(l, a);
                        }
                        // ENTER - select option and close when select options are opened
                        if (13 == t.which) {
                            var s = l.find("li.selected:not(.disabled)")[0];
                            if (s) {
                                e(s).trigger("click");
                                if (!r) g.trigger("close");
                            }
                        }
                        // ARROW DOWN - move to next not disabled option
                        if (40 == t.which) {
                            if (l.find("li.selected").length) a = l.find("li.selected").next("li:not(.disabled)")[0]; else a = l.find("li:not(.disabled)")[0];
                            m(l, a);
                        }
                        // ESC - close options
                        if (27 == t.which) g.trigger("close");
                        // ARROW UP - move to previous not disabled option
                        if (38 == t.which) {
                            a = l.find("li.selected").prev("li:not(.disabled)")[0];
                            if (a) m(l, a);
                        }
                        // Automaticaly clean filter query so user can search again by starting letters
                        setTimeout(function() {
                            y = [];
                        }, 1e3);
                    };
                    g.on("keydown", b);
                });
            };
        }(l);
        !function(e) {
            var t = {
                init: function(t) {
                    var n = {
                        indicators: !0,
                        height: 400,
                        transition: 500,
                        interval: 6e3
                    };
                    t = e.extend(n, t);
                    return this.each(function() {
                        // Transitions the caption depending on alignment
                        function n(e, t) {
                            if (e.hasClass("center-align")) e.velocity({
                                opacity: 0,
                                translateY: -100
                            }, {
                                duration: t,
                                queue: !1
                            }); else if (e.hasClass("right-align")) e.velocity({
                                opacity: 0,
                                translateX: 100
                            }, {
                                duration: t,
                                queue: !1
                            }); else if (e.hasClass("left-align")) e.velocity({
                                opacity: 0,
                                translateX: -100
                            }, {
                                duration: t,
                                queue: !1
                            });
                        }
                        // This function will transition the slide to any index of the next slide
                        function i(e) {
                            // Wrap around indices.
                            if (e >= a.length) e = 0; else if (e < 0) e = a.length - 1;
                            s = o.find(".active").index();
                            // Only do if index changes
                            if (s != e) {
                                l = a.eq(s);
                                $caption = l.find(".caption");
                                l.removeClass("active");
                                l.velocity({
                                    opacity: 0
                                }, {
                                    duration: t.transition,
                                    queue: !1,
                                    easing: "easeOutQuad",
                                    complete: function() {
                                        a.not(".active").velocity({
                                            opacity: 0,
                                            translateX: 0,
                                            translateY: 0
                                        }, {
                                            duration: 0,
                                            queue: !1
                                        });
                                    }
                                });
                                n($caption, t.transition);
                                // Update indicators
                                if (t.indicators) u.eq(s).removeClass("active");
                                a.eq(e).velocity({
                                    opacity: 1
                                }, {
                                    duration: t.transition,
                                    queue: !1,
                                    easing: "easeOutQuad"
                                });
                                a.eq(e).find(".caption").velocity({
                                    opacity: 1,
                                    translateX: 0,
                                    translateY: 0
                                }, {
                                    duration: t.transition,
                                    delay: t.transition,
                                    queue: !1,
                                    easing: "easeOutQuad"
                                });
                                a.eq(e).addClass("active");
                                // Update indicators
                                if (t.indicators) u.eq(e).addClass("active");
                            }
                        }
                        // For each slider, we want to keep track of
                        // which slide is active and its associated content
                        var r = e(this);
                        var o = r.find("ul.slides").first();
                        var a = o.find("> li");
                        var s = o.find(".active").index();
                        var l, u, c;
                        if (-1 != s) l = a.eq(s);
                        // Set height of slider
                        // If fullscreen, do nothing
                        if (!r.hasClass("fullscreen")) {
                            if (t.indicators) // Add height if indicators are present
                            r.height(t.height + 40); else r.height(t.height);
                            o.height(t.height);
                        }
                        // Set initial positions of captions
                        a.find(".caption").each(function() {
                            n(e(this), 0);
                        });
                        // Move img src into background-image
                        a.find("img").each(function() {
                            var t = "data:image/gif;base64,R0lGODlhAQABAIABAP///wAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==";
                            if (e(this).attr("src") !== t) {
                                e(this).css("background-image", 'url("' + e(this).attr("src") + '")');
                                e(this).attr("src", t);
                            }
                        });
                        // dynamically add indicators
                        if (t.indicators) {
                            u = e('<ul class="indicators"></ul>');
                            a.each(function(n) {
                                var r = e('<li class="indicator-item"></li>');
                                // Handle clicks on indicators
                                r.click(function() {
                                    i(o.parent().find(e(this)).index());
                                    // reset interval
                                    clearInterval(c);
                                    c = setInterval(function() {
                                        s = o.find(".active").index();
                                        if (a.length == s + 1) s = 0; else s += 1;
                                        i(s);
                                    }, t.transition + t.interval);
                                });
                                u.append(r);
                            });
                            r.append(u);
                            u = r.find("ul.indicators").find("li.indicator-item");
                        }
                        if (l) l.show(); else {
                            a.first().addClass("active").velocity({
                                opacity: 1
                            }, {
                                duration: t.transition,
                                queue: !1,
                                easing: "easeOutQuad"
                            });
                            s = 0;
                            l = a.eq(s);
                            // Update indicators
                            if (t.indicators) u.eq(s).addClass("active");
                        }
                        // Adjust height to current slide
                        l.find("img").each(function() {
                            l.find(".caption").velocity({
                                opacity: 1,
                                translateX: 0,
                                translateY: 0
                            }, {
                                duration: t.transition,
                                queue: !1,
                                easing: "easeOutQuad"
                            });
                        });
                        // auto scroll
                        c = setInterval(function() {
                            s = o.find(".active").index();
                            i(s + 1);
                        }, t.transition + t.interval);
                        // HammerJS, Swipe navigation
                        // Touch Event
                        var f = !1;
                        var d = !1;
                        var p = !1;
                        r.hammer({
                            prevent_default: !1
                        }).on("pan", function(e) {
                            if ("touch" === e.gesture.pointerType) {
                                // reset interval
                                clearInterval(c);
                                var t = e.gesture.direction;
                                var n = e.gesture.deltaX;
                                var i = e.gesture.velocityX;
                                var s = e.gesture.velocityY;
                                $curr_slide = o.find(".active");
                                if (Math.abs(i) > Math.abs(s)) $curr_slide.velocity({
                                    translateX: n
                                }, {
                                    duration: 50,
                                    queue: !1,
                                    easing: "easeOutQuad"
                                });
                                // Swipe Left
                                if (4 === t && (n > r.innerWidth() / 2 || i < -.65)) p = !0; else if (2 === t && (n < -1 * r.innerWidth() / 2 || i > .65)) d = !0;
                                // Make Slide Behind active slide visible
                                var l;
                                if (d) {
                                    l = $curr_slide.next();
                                    if (0 === l.length) l = a.first();
                                    l.velocity({
                                        opacity: 1
                                    }, {
                                        duration: 300,
                                        queue: !1,
                                        easing: "easeOutQuad"
                                    });
                                }
                                if (p) {
                                    l = $curr_slide.prev();
                                    if (0 === l.length) l = a.last();
                                    l.velocity({
                                        opacity: 1
                                    }, {
                                        duration: 300,
                                        queue: !1,
                                        easing: "easeOutQuad"
                                    });
                                }
                            }
                        }).on("panend", function(e) {
                            if ("touch" === e.gesture.pointerType) {
                                $curr_slide = o.find(".active");
                                f = !1;
                                curr_index = o.find(".active").index();
                                if (!p && !d || a.length <= 1) // Return to original spot
                                $curr_slide.velocity({
                                    translateX: 0
                                }, {
                                    duration: 300,
                                    queue: !1,
                                    easing: "easeOutQuad"
                                }); else if (d) {
                                    i(curr_index + 1);
                                    $curr_slide.velocity({
                                        translateX: -1 * r.innerWidth()
                                    }, {
                                        duration: 300,
                                        queue: !1,
                                        easing: "easeOutQuad",
                                        complete: function() {
                                            $curr_slide.velocity({
                                                opacity: 0,
                                                translateX: 0
                                            }, {
                                                duration: 0,
                                                queue: !1
                                            });
                                        }
                                    });
                                } else if (p) {
                                    i(curr_index - 1);
                                    $curr_slide.velocity({
                                        translateX: r.innerWidth()
                                    }, {
                                        duration: 300,
                                        queue: !1,
                                        easing: "easeOutQuad",
                                        complete: function() {
                                            $curr_slide.velocity({
                                                opacity: 0,
                                                translateX: 0
                                            }, {
                                                duration: 0,
                                                queue: !1
                                            });
                                        }
                                    });
                                }
                                d = !1;
                                p = !1;
                                // Restart interval
                                clearInterval(c);
                                c = setInterval(function() {
                                    s = o.find(".active").index();
                                    if (a.length == s + 1) s = 0; else s += 1;
                                    i(s);
                                }, t.transition + t.interval);
                            }
                        });
                        r.on("sliderPause", function() {
                            clearInterval(c);
                        });
                        r.on("sliderStart", function() {
                            clearInterval(c);
                            c = setInterval(function() {
                                s = o.find(".active").index();
                                if (a.length == s + 1) s = 0; else s += 1;
                                i(s);
                            }, t.transition + t.interval);
                        });
                        r.on("sliderNext", function() {
                            s = o.find(".active").index();
                            i(s + 1);
                        });
                        r.on("sliderPrev", function() {
                            s = o.find(".active").index();
                            i(s - 1);
                        });
                    });
                },
                pause: function() {
                    e(this).trigger("sliderPause");
                },
                start: function() {
                    e(this).trigger("sliderStart");
                },
                next: function() {
                    e(this).trigger("sliderNext");
                },
                prev: function() {
                    e(this).trigger("sliderPrev");
                }
            };
            e.fn.slider = function(n) {
                if (t[n]) return t[n].apply(this, Array.prototype.slice.call(arguments, 1)); else if ("object" === typeof n || !n) // Default to "init"
                return t.init.apply(this, arguments); else e.error("Method " + n + " does not exist on jQuery.tooltip");
            };
        }(l);
        !function(e) {
            e(document).ready(function() {
                e(document).on("click.card", ".card", function(t) {
                    if (e(this).find("> .card-reveal").length) {
                        var n = e(t.target).closest(".card");
                        if (n.data("initialOverflow") === undefined) n.data("initialOverflow", n.css("overflow") === undefined ? "" : n.css("overflow"));
                        if (e(t.target).is(e(".card-reveal .card-title")) || e(t.target).is(e(".card-reveal .card-title i"))) // Make Reveal animate down and display none
                        e(this).find(".card-reveal").velocity({
                            translateY: 0
                        }, {
                            duration: 225,
                            queue: !1,
                            easing: "easeInOutQuad",
                            complete: function() {
                                e(this).css({
                                    display: "none"
                                });
                                n.css("overflow", n.data("initialOverflow"));
                            }
                        }); else if (e(t.target).is(e(".card .activator")) || e(t.target).is(e(".card .activator i"))) {
                            n.css("overflow", "hidden");
                            e(this).find(".card-reveal").css({
                                display: "block"
                            }).velocity("stop", !1).velocity({
                                translateY: "-100%"
                            }, {
                                duration: 300,
                                queue: !1,
                                easing: "easeInOutQuad"
                            });
                        }
                    }
                });
            });
        }(l);
        !function(e) {
            var t = {
                data: [],
                placeholder: "",
                secondaryPlaceholder: "",
                autocompleteOptions: {}
            };
            e(document).ready(function() {
                // Handle removal of static chips.
                e(document).on("click", ".chip .close", function(t) {
                    if (e(this).closest(".chips").attr("data-initialized")) return;
                    e(this).closest(".chip").remove();
                });
            });
            e.fn.material_chip = function(n) {
                var i = this;
                this.$el = e(this);
                this.$document = e(document);
                this.SELS = {
                    CHIPS: ".chips",
                    CHIP: ".chip",
                    INPUT: "input",
                    DELETE: ".material-icons",
                    SELECTED_CHIP: ".selected"
                };
                if ("data" === n) return this.$el.data("chips");
                var r = e.extend({}, t, n);
                i.hasAutocomplete = !e.isEmptyObject(r.autocompleteOptions.data);
                // Initialize
                this.init = function() {
                    var t = 0;
                    var n;
                    i.$el.each(function() {
                        var n = e(this);
                        var o = Materialize.guid();
                        i.chipId = o;
                        if (!r.data || !(r.data instanceof Array)) r.data = [];
                        n.data("chips", r.data);
                        n.attr("data-index", t);
                        n.attr("data-initialized", !0);
                        if (!n.hasClass(i.SELS.CHIPS)) n.addClass("chips");
                        i.chips(n, o);
                        t++;
                    });
                };
                this.handleEvents = function() {
                    var t = i.SELS;
                    i.$document.off("click.chips-focus", t.CHIPS).on("click.chips-focus", t.CHIPS, function(n) {
                        e(n.target).find(t.INPUT).focus();
                    });
                    i.$document.off("click.chips-select", t.CHIP).on("click.chips-select", t.CHIP, function(n) {
                        var r = e(n.target);
                        if (r.length) {
                            var o = r.hasClass("selected");
                            var a = r.closest(t.CHIPS);
                            e(t.CHIP).removeClass("selected");
                            if (!o) i.selectChip(r.index(), a);
                        }
                    });
                    i.$document.off("keydown.chips").on("keydown.chips", function(n) {
                        if (e(n.target).is("input, textarea")) return;
                        // delete
                        var r = i.$document.find(t.CHIP + t.SELECTED_CHIP);
                        var o = r.closest(t.CHIPS);
                        var a = r.siblings(t.CHIP).length;
                        var s;
                        if (!r.length) return;
                        if (8 === n.which || 46 === n.which) {
                            n.preventDefault();
                            s = r.index();
                            i.deleteChip(s, o);
                            var l = null;
                            if (s + 1 < a) l = s; else if (s === a || s + 1 === a) l = a - 1;
                            if (l < 0) l = null;
                            if (null !== l) i.selectChip(l, o);
                            if (!a) o.find("input").focus();
                        } else if (37 === n.which) {
                            s = r.index() - 1;
                            if (s < 0) return;
                            e(t.CHIP).removeClass("selected");
                            i.selectChip(s, o);
                        } else if (39 === n.which) {
                            s = r.index() + 1;
                            e(t.CHIP).removeClass("selected");
                            if (s > a) {
                                o.find("input").focus();
                                return;
                            }
                            i.selectChip(s, o);
                        }
                    });
                    i.$document.off("focusin.chips", t.CHIPS + " " + t.INPUT).on("focusin.chips", t.CHIPS + " " + t.INPUT, function(n) {
                        var i = e(n.target).closest(t.CHIPS);
                        i.addClass("focus");
                        i.siblings("label, .prefix").addClass("active");
                        e(t.CHIP).removeClass("selected");
                    });
                    i.$document.off("focusout.chips", t.CHIPS + " " + t.INPUT).on("focusout.chips", t.CHIPS + " " + t.INPUT, function(n) {
                        var i = e(n.target).closest(t.CHIPS);
                        i.removeClass("focus");
                        // Remove active if empty
                        if (i.data("chips") === undefined || !i.data("chips").length) i.siblings("label").removeClass("active");
                        i.siblings(".prefix").removeClass("active");
                    });
                    i.$document.off("keydown.chips-add", t.CHIPS + " " + t.INPUT).on("keydown.chips-add", t.CHIPS + " " + t.INPUT, function(n) {
                        var r = e(n.target);
                        var o = r.closest(t.CHIPS);
                        var a = o.children(t.CHIP).length;
                        // enter
                        if (13 === n.which) {
                            // Override enter if autocompleting.
                            if (i.hasAutocomplete && o.find(".autocomplete-content.dropdown-content").length && o.find(".autocomplete-content.dropdown-content").children().length) return;
                            n.preventDefault();
                            i.addChip({
                                tag: r.val()
                            }, o);
                            r.val("");
                            return;
                        }
                        // delete or left
                        if ((8 === n.keyCode || 37 === n.keyCode) && "" === r.val() && a) {
                            n.preventDefault();
                            i.selectChip(a - 1, o);
                            r.blur();
                            return;
                        }
                    });
                    // Click on delete icon in chip.
                    i.$document.off("click.chips-delete", t.CHIPS + " " + t.DELETE).on("click.chips-delete", t.CHIPS + " " + t.DELETE, function(n) {
                        var r = e(n.target);
                        var o = r.closest(t.CHIPS);
                        var a = r.closest(t.CHIP);
                        n.stopPropagation();
                        i.deleteChip(a.index(), o);
                        o.find("input").focus();
                    });
                };
                this.chips = function(t, n) {
                    t.empty();
                    t.data("chips").forEach(function(e) {
                        t.append(i.renderChip(e));
                    });
                    t.append(e('<input id="' + n + '" class="input" placeholder="">'));
                    i.setPlaceholder(t);
                    // Set for attribute for label
                    var o = t.next("label");
                    if (o.length) {
                        o.attr("for", n);
                        if (t.data("chips") !== undefined && t.data("chips").length) o.addClass("active");
                    }
                    // Setup autocomplete if needed.
                    var a = e("#" + n);
                    if (i.hasAutocomplete) {
                        r.autocompleteOptions.onAutocomplete = function(e) {
                            i.addChip({
                                tag: e
                            }, t);
                            a.val("");
                            a.focus();
                        };
                        a.autocomplete(r.autocompleteOptions);
                    }
                };
                /**
     * Render chip jQuery element.
     * @param {Object} elem
     * @return {jQuery}
     */
                this.renderChip = function(t) {
                    if (!t.tag) return;
                    var n = e('<div class="chip"></div>');
                    n.text(t.tag);
                    if (t.image) n.prepend(e("<img />").attr("src", t.image));
                    n.append(e('<i class="material-icons close">close</i>'));
                    return n;
                };
                this.setPlaceholder = function(e) {
                    if (e.data("chips") !== undefined && !e.data("chips").length && r.placeholder) e.find("input").prop("placeholder", r.placeholder); else if ((e.data("chips") === undefined || e.data("chips").length) && r.secondaryPlaceholder) e.find("input").prop("placeholder", r.secondaryPlaceholder);
                };
                this.isValid = function(e, t) {
                    var n = e.data("chips");
                    var i = !1;
                    for (var r = 0; r < n.length; r++) if (n[r].tag === t.tag) {
                        i = !0;
                        return;
                    }
                    return "" !== t.tag && !i;
                };
                this.addChip = function(e, t) {
                    if (!i.isValid(t, e)) return;
                    var n = i.renderChip(e);
                    var r = [];
                    var o = t.data("chips");
                    for (var a = 0; a < o.length; a++) r.push(o[a]);
                    r.push(e);
                    t.data("chips", r);
                    n.insertBefore(t.find("input"));
                    t.trigger("chip.add", e);
                    i.setPlaceholder(t);
                };
                this.deleteChip = function(e, t) {
                    var n = t.data("chips")[e];
                    t.find(".chip").eq(e).remove();
                    var r = [];
                    var o = t.data("chips");
                    for (var a = 0; a < o.length; a++) if (a !== e) r.push(o[a]);
                    t.data("chips", r);
                    t.trigger("chip.delete", n);
                    i.setPlaceholder(t);
                };
                this.selectChip = function(e, t) {
                    var n = t.find(".chip").eq(e);
                    if (n && !1 === n.hasClass("selected")) {
                        n.addClass("selected");
                        t.trigger("chip.select", t.data("chips")[e]);
                    }
                };
                this.getChipsElement = function(e, t) {
                    return t.eq(e);
                };
                // init
                this.init();
                this.handleEvents();
            };
        }(l);
        !function(e) {
            e.fn.pushpin = function(t) {
                // Defaults
                var n = {
                    top: 0,
                    bottom: Infinity,
                    offset: 0
                };
                // Remove pushpin event and classes
                if ("remove" === t) {
                    this.each(function() {
                        if (id = e(this).data("pushpin-id")) {
                            e(window).off("scroll." + id);
                            e(this).removeData("pushpin-id").removeClass("pin-top pinned pin-bottom").removeAttr("style");
                        }
                    });
                    return !1;
                }
                t = e.extend(n, t);
                $index = 0;
                return this.each(function() {
                    function n(e) {
                        e.removeClass("pin-top");
                        e.removeClass("pinned");
                        e.removeClass("pin-bottom");
                    }
                    function i(i, r) {
                        i.each(function() {
                            // Add position fixed (because its between top and bottom)
                            if (t.top <= r && t.bottom >= r && !e(this).hasClass("pinned")) {
                                n(e(this));
                                e(this).css("top", t.offset);
                                e(this).addClass("pinned");
                            }
                            // Add pin-top (when scrolled position is above top)
                            if (r < t.top && !e(this).hasClass("pin-top")) {
                                n(e(this));
                                e(this).css("top", 0);
                                e(this).addClass("pin-top");
                            }
                            // Add pin-bottom (when scrolled position is below bottom)
                            if (r > t.bottom && !e(this).hasClass("pin-bottom")) {
                                n(e(this));
                                e(this).addClass("pin-bottom");
                                e(this).css("top", t.bottom - a);
                            }
                        });
                    }
                    var r = Materialize.guid(), o = e(this), a = e(this).offset().top;
                    e(this).data("pushpin-id", r);
                    i(o, e(window).scrollTop());
                    e(window).on("scroll." + r, function() {
                        var n = e(window).scrollTop() + t.offset;
                        i(o, n);
                    });
                });
            };
        }(l);
        !function(e) {
            e(document).ready(function() {
                // jQuery reverse
                e.fn.reverse = [].reverse;
                // Hover behaviour: make sure this doesn't work on .click-to-toggle FABs!
                e(document).on("mouseenter.fixedActionBtn", ".fixed-action-btn:not(.click-to-toggle):not(.toolbar)", function(n) {
                    var i = e(this);
                    t(i);
                });
                e(document).on("mouseleave.fixedActionBtn", ".fixed-action-btn:not(.click-to-toggle):not(.toolbar)", function(t) {
                    var i = e(this);
                    n(i);
                });
                // Toggle-on-click behaviour.
                e(document).on("click.fabClickToggle", ".fixed-action-btn.click-to-toggle > a", function(i) {
                    var r = e(this);
                    var o = r.parent();
                    if (o.hasClass("active")) n(o); else t(o);
                });
                // Toolbar transition behaviour.
                e(document).on("click.fabToolbar", ".fixed-action-btn.toolbar > a", function(t) {
                    var n = e(this);
                    var r = n.parent();
                    i(r);
                });
            });
            e.fn.extend({
                openFAB: function() {
                    t(e(this));
                },
                closeFAB: function() {
                    n(e(this));
                },
                openToolbar: function() {
                    i(e(this));
                },
                closeToolbar: function() {
                    r(e(this));
                }
            });
            var t = function(t) {
                var n = t;
                if (!1 === n.hasClass("active")) {
                    // Get direction option
                    var i = n.hasClass("horizontal");
                    var r, o;
                    if (!0 === i) o = 40; else r = 40;
                    n.addClass("active");
                    n.find("ul .btn-floating").velocity({
                        scaleY: ".4",
                        scaleX: ".4",
                        translateY: r + "px",
                        translateX: o + "px"
                    }, {
                        duration: 0
                    });
                    var a = 0;
                    n.find("ul .btn-floating").reverse().each(function() {
                        e(this).velocity({
                            opacity: "1",
                            scaleX: "1",
                            scaleY: "1",
                            translateY: "0",
                            translateX: "0"
                        }, {
                            duration: 80,
                            delay: a
                        });
                        a += 40;
                    });
                }
            };
            var n = function(e) {
                var t = e;
                // Get direction option
                var n = t.hasClass("horizontal");
                var i, r;
                if (!0 === n) r = 40; else i = 40;
                t.removeClass("active");
                var o = 0;
                t.find("ul .btn-floating").velocity("stop", !0);
                t.find("ul .btn-floating").velocity({
                    opacity: "0",
                    scaleX: ".4",
                    scaleY: ".4",
                    translateY: i + "px",
                    translateX: r + "px"
                }, {
                    duration: 80
                });
            };
            /**
   * Transform FAB into toolbar
   * @param  {Object}  object jQuery object
   */
            var i = function(t) {
                if ("true" === t.attr("data-open")) return;
                var n, i, o;
                var a = window.innerWidth;
                var s = window.innerHeight;
                var l = t[0].getBoundingClientRect();
                var u = t.find("> a").first();
                var c = t.find("> ul").first();
                var f = e('<div class="fab-backdrop"></div>');
                var d = u.css("background-color");
                u.append(f);
                n = l.left - a / 2 + l.width / 2;
                i = s - l.bottom;
                o = a / f.width();
                t.attr("data-origin-bottom", l.bottom);
                t.attr("data-origin-left", l.left);
                t.attr("data-origin-width", l.width);
                // Set initial state
                t.addClass("active");
                t.attr("data-open", !0);
                t.css({
                    "text-align": "center",
                    width: "100%",
                    bottom: 0,
                    left: 0,
                    transform: "translateX(" + n + "px)",
                    transition: "none"
                });
                u.css({
                    transform: "translateY(" + -i + "px)",
                    transition: "none"
                });
                f.css({
                    "background-color": d
                });
                setTimeout(function() {
                    t.css({
                        transform: "",
                        transition: "transform .2s cubic-bezier(0.550, 0.085, 0.680, 0.530), background-color 0s linear .2s"
                    });
                    u.css({
                        overflow: "visible",
                        transform: "",
                        transition: "transform .2s"
                    });
                    setTimeout(function() {
                        t.css({
                            overflow: "hidden",
                            "background-color": d
                        });
                        f.css({
                            transform: "scale(" + o + ")",
                            transition: "transform .2s cubic-bezier(0.550, 0.055, 0.675, 0.190)"
                        });
                        c.find("> li > a").css({
                            opacity: 1
                        });
                        // Scroll to close.
                        e(window).on("scroll.fabToolbarClose", function() {
                            r(t);
                            e(window).off("scroll.fabToolbarClose");
                            e(document).off("click.fabToolbarClose");
                        });
                        e(document).on("click.fabToolbarClose", function(n) {
                            if (!e(n.target).closest(c).length) {
                                r(t);
                                e(window).off("scroll.fabToolbarClose");
                                e(document).off("click.fabToolbarClose");
                            }
                        });
                    }, 100);
                }, 0);
            };
            /**
   * Transform toolbar back into FAB
   * @param  {Object}  object jQuery object
   */
            var r = function(e) {
                if ("true" !== e.attr("data-open")) return;
                var t, n, i;
                var r = window.innerWidth;
                var o = window.innerHeight;
                var a = e.attr("data-origin-width");
                var s = e.attr("data-origin-bottom");
                var l = e.attr("data-origin-left");
                var u = e.find("> .btn-floating").first();
                var c = e.find("> ul").first();
                var f = e.find(".fab-backdrop");
                var d = u.css("background-color");
                t = l - r / 2 + a / 2;
                n = o - s;
                i = r / f.width();
                // Hide backdrop
                e.removeClass("active");
                e.attr("data-open", !1);
                e.css({
                    "background-color": "transparent",
                    transition: "none"
                });
                u.css({
                    transition: "none"
                });
                f.css({
                    transform: "scale(0)",
                    "background-color": d
                });
                c.find("> li > a").css({
                    opacity: ""
                });
                setTimeout(function() {
                    f.remove();
                    // Set initial state.
                    e.css({
                        "text-align": "",
                        width: "",
                        bottom: "",
                        left: "",
                        overflow: "",
                        "background-color": "",
                        transform: "translate3d(" + -t + "px,0,0)"
                    });
                    u.css({
                        overflow: "",
                        transform: "translate3d(0," + n + "px,0)"
                    });
                    setTimeout(function() {
                        e.css({
                            transform: "translate3d(0,0,0)",
                            transition: "transform .2s"
                        });
                        u.css({
                            transform: "translate3d(0,0,0)",
                            transition: "transform .2s cubic-bezier(0.550, 0.055, 0.675, 0.190)"
                        });
                    }, 20);
                }, 200);
            };
        }(l);
        !function(e) {
            // Image transition function
            Materialize.fadeInImage = function(t) {
                var n;
                if ("string" === typeof t) n = e(t); else if ("object" === typeof t) n = t; else return;
                n.css({
                    opacity: 0
                });
                e(n).velocity({
                    opacity: 1
                }, {
                    duration: 650,
                    queue: !1,
                    easing: "easeOutSine"
                });
                e(n).velocity({
                    opacity: 1
                }, {
                    duration: 1300,
                    queue: !1,
                    easing: "swing",
                    step: function(t, n) {
                        n.start = 100;
                        var i = t / 100;
                        var r = 150 - (100 - t) / 1.75;
                        if (r < 100) r = 100;
                        if (t >= 0) e(this).css({
                            "-webkit-filter": "grayscale(" + i + ")" + "brightness(" + r + "%)",
                            filter: "grayscale(" + i + ")" + "brightness(" + r + "%)"
                        });
                    }
                });
            };
            // Horizontal staggered list
            Materialize.showStaggeredList = function(t) {
                var n;
                if ("string" === typeof t) n = e(t); else if ("object" === typeof t) n = t; else return;
                var i = 0;
                n.find("li").velocity({
                    translateX: "-100px"
                }, {
                    duration: 0
                });
                n.find("li").each(function() {
                    e(this).velocity({
                        opacity: "1",
                        translateX: "0"
                    }, {
                        duration: 800,
                        delay: i,
                        easing: [ 60, 10 ]
                    });
                    i += 120;
                });
            };
            e(document).ready(function() {
                // Hardcoded .staggered-list scrollFire
                // var staggeredListOptions = [];
                // $('ul.staggered-list').each(function (i) {
                //   var label = 'scrollFire-' + i;
                //   $(this).addClass(label);
                //   staggeredListOptions.push(
                //     {selector: 'ul.staggered-list.' + label,
                //      offset: 200,
                //      callback: 'showStaggeredList("ul.staggered-list.' + label + '")'});
                // });
                // scrollFire(staggeredListOptions);
                // HammerJS, Swipe navigation
                // Touch Event
                var t = !1;
                var n = !1;
                // Dismissible Collections
                e(".dismissable").each(function() {
                    e(this).hammer({
                        prevent_default: !1
                    }).on("pan", function(i) {
                        if ("touch" === i.gesture.pointerType) {
                            var r = e(this);
                            var o = i.gesture.direction;
                            var a = i.gesture.deltaX;
                            var s = i.gesture.velocityX;
                            r.velocity({
                                translateX: a
                            }, {
                                duration: 50,
                                queue: !1,
                                easing: "easeOutQuad"
                            });
                            // Swipe Left
                            if (4 === o && (a > r.innerWidth() / 2 || s < -.75)) t = !0;
                            // Swipe Right
                            if (2 === o && (a < -1 * r.innerWidth() / 2 || s > .75)) n = !0;
                        }
                    }).on("panend", function(i) {
                        // Reset if collection is moved back into original position
                        if (Math.abs(i.gesture.deltaX) < e(this).innerWidth() / 2) {
                            n = !1;
                            t = !1;
                        }
                        if ("touch" === i.gesture.pointerType) {
                            var r = e(this);
                            if (t || n) {
                                var o;
                                if (t) o = r.innerWidth(); else o = -1 * r.innerWidth();
                                r.velocity({
                                    translateX: o
                                }, {
                                    duration: 100,
                                    queue: !1,
                                    easing: "easeOutQuad",
                                    complete: function() {
                                        r.css("border", "none");
                                        r.velocity({
                                            height: 0,
                                            padding: 0
                                        }, {
                                            duration: 200,
                                            queue: !1,
                                            easing: "easeOutQuad",
                                            complete: function() {
                                                r.remove();
                                            }
                                        });
                                    }
                                });
                            } else r.velocity({
                                translateX: 0
                            }, {
                                duration: 100,
                                queue: !1,
                                easing: "easeOutQuad"
                            });
                            t = !1;
                            n = !1;
                        }
                    });
                });
            });
        }(l);
        !function(e) {
            var t = !1;
            // Input: Array of JSON objects {selector, offset, callback}
            Materialize.scrollFire = function(e) {
                var n = function() {
                    var t = window.pageYOffset + window.innerHeight;
                    for (var n = 0; n < e.length; n++) {
                        // Get options from each line
                        var i = e[n];
                        var r = i.selector, o = i.offset, a = i.callback;
                        var s = document.querySelector(r);
                        if (null !== s) {
                            if (t > s.getBoundingClientRect().top + window.pageYOffset + o) if (!0 !== i.done) {
                                if ("function" === typeof a) a.call(this, s); else if ("string" === typeof a) {
                                    var l = new Function(a);
                                    l(s);
                                }
                                i.done = !0;
                            }
                        }
                    }
                };
                var i = Materialize.throttle(function() {
                    n();
                }, e.throttle || 100);
                if (!t) {
                    window.addEventListener("scroll", i);
                    window.addEventListener("resize", i);
                    t = !0;
                }
                // perform a scan once, after current execution context, and after dom is ready
                setTimeout(i, 0);
            };
        }(l);
        /*!
  * pickadate.js v3.5.0, 2014/04/13
  * By Amsul, http://amsul.ca
  * Hosted on http://amsul.github.io/pickadate.js
  * Licensed under MIT
  */
        !function(e) {
            Materialize.Picker = e(l);
        }(function(e) {
            /**
   * The picker constructor that creates a blank picker.
   */
            function t(o, a, l, f) {
                function d() {
                    // Create a picker wrapper holder
                    // Create a picker wrapper node
                    // Create a picker frame
                    // Create a picker box node
                    // Create the components nodes.
                    // The picker box class
                    // Picker wrap class
                    // Picker frame class
                    // Picker holder class
                    return t._.node("div", t._.node("div", t._.node("div", t._.node("div", k.component.nodes(b.open), w.box), w.wrap), w.frame), w.holder);
                }
                //createWrappedComponent
                /**
     * Prepare the input element with all bindings.
     */
                function p() {
                    T.data(a, k).addClass(w.input).attr("tabindex", -1).val(T.data("value") ? k.get("select", x.format) : o.value);
                    // Only bind keydown events if the element isnât editable.
                    if (!x.editable) T.on("focus." + b.id + " click." + b.id, function(e) {
                        e.preventDefault();
                        k.$root.eq(0).focus();
                    }).on("keydown." + b.id, g);
                    // Update the aria attributes.
                    r(o, {
                        haspopup: !0,
                        expanded: !1,
                        readonly: !1,
                        owns: o.id + "_root"
                    });
                }
                /**
     * Prepare the root picker element with all bindings.
     */
                function h() {
                    k.$root.on({
                        // For iOS8.
                        keydown: g,
                        // When something within the root is focused, stop from bubbling
                        // to the doc and remove the âfocusedâ state from the root.
                        focusin: function(e) {
                            k.$root.removeClass(w.focused);
                            e.stopPropagation();
                        },
                        // When something within the root holder is clicked, stop it
                        // from bubbling to the doc.
                        "mousedown click": function(t) {
                            var n = t.target;
                            // Make sure the target isnât the root holder so it can bubble up.
                            if (n != k.$root.children()[0]) {
                                t.stopPropagation();
                                // * For mousedown events, cancel the default action in order to
                                //   prevent cases where focus is shifted onto external elements
                                //   when using things like jQuery mobile or MagnificPopup (ref: #249 & #120).
                                //   Also, for Firefox, donât prevent action on the `option` element.
                                if ("mousedown" == t.type && !e(n).is("input, select, textarea, button, option")) {
                                    t.preventDefault();
                                    // Re-focus onto the root so that users can click away
                                    // from elements focused within the picker.
                                    k.$root.eq(0).focus();
                                }
                            }
                        }
                    }).on({
                        focus: function() {
                            T.addClass(w.target);
                        },
                        blur: function() {
                            T.removeClass(w.target);
                        }
                    }).on("focus.toOpen", m).on("click", "[data-pick], [data-nav], [data-clear], [data-close]", function() {
                        var t = e(this), n = t.data(), i = t.hasClass(w.navDisabled) || t.hasClass(w.disabled), // * For IE, non-focusable elements can be active elements as well
                        //   (http://stackoverflow.com/a/2684561).
                        r = s();
                        r = r && (r.type || r.href);
                        // If itâs disabled or nothing inside is actively focused, re-focus the element.
                        if (i || r && !e.contains(k.$root[0], r)) k.$root.eq(0).focus();
                        // If something is superficially changed, update the `highlight` based on the `nav`.
                        if (!i && n.nav) k.set("highlight", k.component.item.highlight, {
                            nav: n.nav
                        }); else if (!i && "pick" in n) {
                            k.set("select", n.pick);
                            if (x.closeOnSelect) k.close(!0);
                        } else if (n.clear) {
                            k.clear();
                            if (x.closeOnSelect) k.close(!0);
                        } else if (n.close) k.close(!0);
                    });
                    //P.$root
                    r(k.$root[0], "hidden", !0);
                }
                /**
     * Prepare the hidden input element along with all bindings.
     */
                function v() {
                    var t;
                    if (!0 === x.hiddenName) {
                        t = o.name;
                        o.name = "";
                    } else {
                        t = [ "string" == typeof x.hiddenPrefix ? x.hiddenPrefix : "", "string" == typeof x.hiddenSuffix ? x.hiddenSuffix : "_submit" ];
                        t = t[0] + o.name + t[1];
                    }
                    k._hidden = e("<input " + "type=hidden " + // Create the name using the original inputâs with a prefix and suffix.
                    'name="' + t + '"' + (// If the element has a value, set the hidden value as well.
                    T.data("value") || o.value ? ' value="' + k.get("select", x.formatSubmit) + '"' : "") + ">")[0];
                    T.on("change." + b.id, function() {
                        k._hidden.value = o.value ? k.get("select", x.formatSubmit) : "";
                    });
                    // Insert the hidden input as specified in the settings.
                    if (x.container) e(x.container).append(k._hidden); else T.before(k._hidden);
                }
                // For iOS8.
                function g(e) {
                    var t = e.keyCode, // Check if one of the delete keys was pressed.
                    n = /^(8|46)$/.test(t);
                    // For some reason IE clears the input value on âescapeâ.
                    if (27 == t) {
                        k.close();
                        return !1;
                    }
                    // Check if `space` or `delete` was pressed or the picker is closed with a key movement.
                    if (32 == t || n || !b.open && k.component.key[t]) {
                        // Prevent it from moving the page and bubbling to doc.
                        e.preventDefault();
                        e.stopPropagation();
                        // If `delete` was pressed, clear the values and close the picker.
                        // Otherwise open the picker.
                        if (n) k.clear().close(); else k.open();
                    }
                }
                // Separated for IE
                function m(e) {
                    // Stop the event from propagating to the doc.
                    e.stopPropagation();
                    // If itâs a focus event, add the âfocusedâ class to the root.
                    if ("focus" == e.type) k.$root.addClass(w.focused);
                    // And then finally open the picker.
                    k.open();
                }
                // If thereâs no element, return the picker constructor.
                if (!o) return t;
                var y = !1, // The state of the picker.
                b = {
                    id: o.id || "P" + Math.abs(~~(Math.random() * new Date()))
                }, // Merge the defaults and options passed.
                x = l ? e.extend(!0, {}, l.defaults, f) : f || {}, // Merge the default classes with the settings classes.
                w = e.extend({}, t.klasses(), x.klass), // The element node wrapper into a jQuery object.
                T = e(o), // Pseudo picker constructor.
                C = function() {
                    return this.start();
                }, // The picker prototype.
                k = C.prototype = {
                    constructor: C,
                    $node: T,
                    /**
       * Initialize everything
       */
                    start: function() {
                        // If itâs already started, do nothing.
                        if (b && b.start) return k;
                        // Update the picker states.
                        b.methods = {};
                        b.start = !0;
                        b.open = !1;
                        b.type = o.type;
                        // Confirm focus state, convert into text input to remove UA stylings,
                        // and set as readonly to prevent keyboard popup.
                        o.autofocus = o == s();
                        o.readOnly = !x.editable;
                        o.id = o.id || b.id;
                        if ("text" != o.type) o.type = "text";
                        // Create a new picker component with the settings.
                        k.component = new l(k, x);
                        // Create the picker root with a holder and then prepare it.
                        k.$root = e(t._.node("div", d(), w.picker, 'id="' + o.id + '_root" tabindex="0"'));
                        h();
                        // If thereâs a format for the hidden input element, create the element.
                        if (x.formatSubmit) v();
                        // Prepare the input element.
                        p();
                        // Insert the root as specified in the settings.
                        if (x.container) e(x.container).append(k.$root); else T.before(k.$root);
                        // Bind the default component and settings events.
                        k.on({
                            start: k.component.onStart,
                            render: k.component.onRender,
                            stop: k.component.onStop,
                            open: k.component.onOpen,
                            close: k.component.onClose,
                            set: k.component.onSet
                        }).on({
                            start: x.onStart,
                            render: x.onRender,
                            stop: x.onStop,
                            open: x.onOpen,
                            close: x.onClose,
                            set: x.onSet
                        });
                        // Once weâre all set, check the theme in use.
                        y = n(k.$root.children()[0]);
                        // If the element has autofocus, open the picker.
                        if (o.autofocus) k.open();
                        // Trigger queued the âstartâ and ârenderâ events.
                        return k.trigger("start").trigger("render");
                    },
                    //start
                    /**
       * Render a new picker
       */
                    render: function(e) {
                        // Insert a new component holder in the root or box.
                        if (e) k.$root.html(d()); else k.$root.find("." + w.box).html(k.component.nodes(b.open));
                        // Trigger the queued ârenderâ events.
                        return k.trigger("render");
                    },
                    //render
                    /**
       * Destroy everything
       */
                    stop: function() {
                        // If itâs already stopped, do nothing.
                        if (!b.start) return k;
                        // Then close the picker.
                        k.close();
                        // Remove the hidden field.
                        if (k._hidden) k._hidden.parentNode.removeChild(k._hidden);
                        // Remove the root.
                        k.$root.remove();
                        // Remove the input class, remove the stored data, and unbind
                        // the events (after a tick for IE - see `P.close`).
                        T.removeClass(w.input).removeData(a);
                        setTimeout(function() {
                            T.off("." + b.id);
                        }, 0);
                        // Restore the element state
                        o.type = b.type;
                        o.readOnly = !1;
                        // Trigger the queued âstopâ events.
                        k.trigger("stop");
                        // Reset the picker states.
                        b.methods = {};
                        b.start = !1;
                        return k;
                    },
                    //stop
                    /**
       * Open up the picker
       */
                    open: function(n) {
                        // If itâs already open, do nothing.
                        if (b.open) return k;
                        // Add the âactiveâ class.
                        T.addClass(w.active);
                        r(o, "expanded", !0);
                        // * A Firefox bug, when `html` has `overflow:hidden`, results in
                        //   killing transitions :(. So add the âopenedâ state on the next tick.
                        //   Bug: https://bugzilla.mozilla.org/show_bug.cgi?id=625289
                        setTimeout(function() {
                            // Add the âopenedâ class to the picker root.
                            k.$root.addClass(w.opened);
                            r(k.$root[0], "hidden", !1);
                        }, 0);
                        // If we have to give focus, bind the element and doc events.
                        if (!1 !== n) {
                            // Set it as open.
                            b.open = !0;
                            // Prevent the page from scrolling.
                            if (y) c.css("overflow", "hidden").css("padding-right", "+=" + i());
                            // Pass focus to the root elementâs jQuery object.
                            // * Workaround for iOS8 to bring the pickerâs root into view.
                            k.$root.eq(0).focus();
                            // Bind the document events.
                            u.on("click." + b.id + " focusin." + b.id, function(e) {
                                var t = e.target;
                                // If the target of the event is not the element, close the picker picker.
                                // * Donât worry about clicks or focusins on the root because those donât bubble up.
                                //   Also, for Firefox, a click on an `option` element bubbles up directly
                                //   to the doc. So make sure the target wasn't the doc.
                                // * In Firefox stopPropagation() doesnât prevent right-click events from bubbling,
                                //   which causes the picker to unexpectedly close when right-clicking it. So make
                                //   sure the event wasnât a right-click.
                                if (t != o && t != document && 3 != e.which) // If the target was the holder that covers the screen,
                                // keep the element focused to maintain tabindex.
                                k.close(t === k.$root.children()[0]);
                            }).on("keydown." + b.id, function(n) {
                                var // Get the keycode.
                                i = n.keyCode, // Translate that to a selection change.
                                r = k.component.key[i], // Grab the target.
                                o = n.target;
                                // On escape, close the picker and give focus.
                                if (27 == i) k.close(!0); else if (o == k.$root[0] && (r || 13 == i)) {
                                    // Prevent the default action to stop page movement.
                                    n.preventDefault();
                                    // Trigger the key movement action.
                                    if (r) t._.trigger(k.component.key.go, k, [ t._.trigger(r) ]); else if (!k.$root.find("." + w.highlighted).hasClass(w.disabled)) {
                                        k.set("select", k.component.item.highlight);
                                        if (x.closeOnSelect) k.close(!0);
                                    }
                                } else if (e.contains(k.$root[0], o) && 13 == i) {
                                    n.preventDefault();
                                    o.click();
                                }
                            });
                        }
                        // Trigger the queued âopenâ events.
                        return k.trigger("open");
                    },
                    //open
                    /**
       * Close the picker
       */
                    close: function(e) {
                        // If we need to give focus, do it before changing states.
                        if (e) {
                            // ....ah yes! It wouldâve been incomplete without a crazy workaround for IE :|
                            // The focus is triggered *after* the close has completed - causing it
                            // to open again. So unbind and rebind the event at the next tick.
                            k.$root.off("focus.toOpen").eq(0).focus();
                            setTimeout(function() {
                                k.$root.on("focus.toOpen", m);
                            }, 0);
                        }
                        // Remove the âactiveâ class.
                        T.removeClass(w.active);
                        r(o, "expanded", !1);
                        // * A Firefox bug, when `html` has `overflow:hidden`, results in
                        //   killing transitions :(. So remove the âopenedâ state on the next tick.
                        //   Bug: https://bugzilla.mozilla.org/show_bug.cgi?id=625289
                        setTimeout(function() {
                            // Remove the âopenedâ and âfocusedâ class from the picker root.
                            k.$root.removeClass(w.opened + " " + w.focused);
                            r(k.$root[0], "hidden", !0);
                        }, 0);
                        // If itâs already closed, do nothing more.
                        if (!b.open) return k;
                        // Set it as closed.
                        b.open = !1;
                        // Allow the page to scroll.
                        if (y) c.css("overflow", "").css("padding-right", "-=" + i());
                        // Unbind the document events.
                        u.off("." + b.id);
                        // Trigger the queued âcloseâ events.
                        return k.trigger("close");
                    },
                    //close
                    /**
       * Clear the values
       */
                    clear: function(e) {
                        return k.set("clear", null, e);
                    },
                    //clear
                    /**
       * Set something
       */
                    set: function(t, n, i) {
                        var r, o, a = e.isPlainObject(t), s = a ? t : {};
                        // Make sure we have usable options.
                        i = a && e.isPlainObject(n) ? n : i || {};
                        if (t) {
                            // If the thing isnât an object, make it one.
                            if (!a) s[t] = n;
                            // Go through the things of items to set.
                            for (r in s) {
                                // Grab the value of the thing.
                                o = s[r];
                                // First, if the item exists and thereâs a value, set it.
                                if (r in k.component.item) {
                                    if (o === undefined) o = null;
                                    k.component.set(r, o, i);
                                }
                                // Then, check to update the element value and broadcast a change.
                                if ("select" == r || "clear" == r) T.val("clear" == r ? "" : k.get(r, x.format)).trigger("change");
                            }
                            // Render a new picker.
                            k.render();
                        }
                        // When the method isnât muted, trigger queued âsetâ events and pass the `thingObject`.
                        return i.muted ? k : k.trigger("set", s);
                    },
                    //set
                    /**
       * Get something
       */
                    get: function(e, n) {
                        // Make sure thereâs something to get.
                        e = e || "value";
                        // If a picker state exists, return that.
                        if (null != b[e]) return b[e];
                        // Return the submission value, if that.
                        if ("valueSubmit" == e) {
                            if (k._hidden) return k._hidden.value;
                            e = "value";
                        }
                        // Return the value, if that.
                        if ("value" == e) return o.value;
                        // Check if a component item exists, return that.
                        if (e in k.component.item) {
                            if ("string" == typeof n) {
                                var i = k.component.get(e);
                                return i ? t._.trigger(k.component.formats.toString, k.component, [ n, i ]) : "";
                            }
                            return k.component.get(e);
                        }
                    },
                    //get
                    /**
       * Bind events on the things.
       */
                    on: function(t, n, i) {
                        var r, o, a = e.isPlainObject(t), s = a ? t : {};
                        if (t) {
                            // If the thing isnât an object, make it one.
                            if (!a) s[t] = n;
                            // Go through the things to bind to.
                            for (r in s) {
                                // Grab the method of the thing.
                                o = s[r];
                                // If it was an internal binding, prefix it.
                                if (i) r = "_" + r;
                                // Make sure the thing methods collection exists.
                                b.methods[r] = b.methods[r] || [];
                                // Add the method to the relative method collection.
                                b.methods[r].push(o);
                            }
                        }
                        return k;
                    },
                    //on
                    /**
       * Unbind events on the things.
       */
                    off: function() {
                        var e, t, n = arguments;
                        for (e = 0, namesCount = n.length; e < namesCount; e += 1) {
                            t = n[e];
                            if (t in b.methods) delete b.methods[t];
                        }
                        return k;
                    },
                    /**
       * Fire off method events.
       */
                    trigger: function(e, n) {
                        var i = function(e) {
                            var i = b.methods[e];
                            if (i) i.map(function(e) {
                                t._.trigger(e, k, [ n ]);
                            });
                        };
                        i("_" + e);
                        i(e);
                        return k;
                    }
                };
                // Return a new picker instance.
                return new C();
            }
            //PickerConstructor.klasses
            /**
   * Check if the default theme is being used.
   */
            function n(e) {
                var t, n = "position";
                // For IE.
                if (e.currentStyle) t = e.currentStyle[n]; else if (window.getComputedStyle) t = getComputedStyle(e)[n];
                return "fixed" == t;
            }
            /**
   * Get the width of the browserâs scrollbar.
   * Taken from: https://github.com/VodkaBears/Remodal/blob/master/src/jquery.remodal.js
   */
            function i() {
                if (c.height() <= l.height()) return 0;
                var t = e('<div style="visibility:hidden;width:100px" />').appendTo("body");
                // Get the width without scrollbars.
                var n = t[0].offsetWidth;
                // Force adding scrollbars.
                t.css("overflow", "scroll");
                // Add the inner div.
                var i = e('<div style="width:100%" />').appendTo(t);
                // Get the width with scrollbars.
                var r = i[0].offsetWidth;
                // Remove the divs.
                t.remove();
                // Return the difference between the widths.
                return n - r;
            }
            //PickerConstructor.extend
            function r(t, n, i) {
                if (e.isPlainObject(n)) for (var r in n) o(t, r, n[r]); else o(t, n, i);
            }
            function o(e, t, n) {
                e.setAttribute(("role" == t ? "" : "aria-") + t, n);
            }
            function a(t, n) {
                if (!e.isPlainObject(t)) t = {
                    attribute: n
                };
                n = "";
                for (var i in t) {
                    var r = ("role" == i ? "" : "aria-") + i;
                    n += null == t[i] ? "" : r + '="' + t[i] + '"';
                }
                return n;
            }
            // IE8 bug throws an error for activeElements within iframes.
            function s() {
                try {
                    return document.activeElement;
                } catch (e) {}
            }
            var l = e(window);
            var u = e(document);
            var c = e(document.documentElement);
            //PickerConstructor
            /**
   * The default classes and prefix to use for the HTML classes.
   */
            t.klasses = function(e) {
                e = e || "picker";
                return {
                    picker: e,
                    opened: e + "--opened",
                    focused: e + "--focused",
                    input: e + "__input",
                    active: e + "__input--active",
                    target: e + "__input--target",
                    holder: e + "__holder",
                    frame: e + "__frame",
                    wrap: e + "__wrap",
                    box: e + "__box"
                };
            };
            /**
   * PickerConstructor helper methods.
   */
            t._ = {
                /**
     * Create a group of nodes. Expects:
     * `
        {
            min:    {Integer},
            max:    {Integer},
            i:      {Integer},
            node:   {String},
            item:   {Function}
        }
     * `
     */
                group: function(e) {
                    var // Scope for the looped object
                    n, // Create the nodes list
                    i = "", // The counter starts from the `min`
                    r = t._.trigger(e.min, e);
                    // Loop from the `min` to `max`, incrementing by `i`
                    for (;r <= t._.trigger(e.max, e, [ r ]); r += e.i) {
                        // Trigger the `item` function within scope of the object
                        n = t._.trigger(e.item, e, [ r ]);
                        // Splice the subgroup and create nodes out of the sub nodes
                        i += t._.node(e.node, n[0], // the node
                        n[1], // the classes
                        n[2]);
                    }
                    // Return the list of nodes
                    return i;
                },
                //group
                /**
     * Create a dom node string
     */
                node: function(t, n, i, r) {
                    // If the item is false-y, just return an empty string
                    if (!n) return "";
                    // If the item is an array, do a join
                    n = e.isArray(n) ? n.join("") : n;
                    // Check for the class
                    i = i ? ' class="' + i + '"' : "";
                    // Check for any attributes
                    r = r ? " " + r : "";
                    // Return the wrapped item
                    return "<" + t + i + r + ">" + n + "</" + t + ">";
                },
                //node
                /**
     * Lead numbers below 10 with a zero.
     */
                lead: function(e) {
                    return (e < 10 ? "0" : "") + e;
                },
                /**
     * Trigger a function otherwise return the value.
     */
                trigger: function(e, t, n) {
                    return "function" == typeof e ? e.apply(t, n || []) : e;
                },
                /**
     * If the second character is a digit, length is 2 otherwise 1.
     */
                digits: function(e) {
                    return /\d/.test(e[1]) ? 2 : 1;
                },
                /**
     * Tell if something is a date object.
     */
                isDate: function(e) {
                    return {}.toString.call(e).indexOf("Date") > -1 && this.isInteger(e.getDate());
                },
                /**
     * Tell if something is an integer.
     */
                isInteger: function(e) {
                    return {}.toString.call(e).indexOf("Number") > -1 && e % 1 === 0;
                },
                /**
     * Create ARIA attribute strings.
     */
                ariaAttr: a
            };
            t.extend = function(n, i) {
                // Extend jQuery.
                e.fn[n] = function(r, o) {
                    // Grab the component data.
                    var a = this.data(n);
                    // If the picker is requested, return the data object.
                    if ("picker" == r) return a;
                    // If the component data exists and `options` is a string, carry out the action.
                    if (a && "string" == typeof r) return t._.trigger(a[r], a, [ o ]);
                    // Otherwise go through each matched element and if the component
                    // doesnât exist, create a new picker using `this` element
                    // and merging the defaults and options with a deep copy.
                    return this.each(function() {
                        if (!e(this).data(n)) new t(this, n, i, r);
                    });
                };
                // Set the defaults.
                e.fn[n].defaults = i.defaults;
            };
            // Expose the picker constructor.
            return t;
        });
        /*!
  * Date picker for pickadate.js v3.5.0
  * http://amsul.github.io/pickadate.js/date.htm
  */
        !function(e) {
            e(Materialize.Picker, l);
        }(function(e, t) {
            /**
   * The date picker constructor
   */
            function n(e, t) {
                var n = this, i = e.$node[0], r = i.value, o = e.$node.data("value"), a = o || r, s = o ? t.formatSubmit : t.format, l = function() {
                    // For IE.
                    // For normal browsers.
                    return i.currentStyle ? "rtl" == i.currentStyle.direction : "rtl" == getComputedStyle(e.$root[0]).direction;
                };
                n.settings = t;
                n.$node = e.$node;
                // The queue of methods that will be used to build item objects.
                n.queue = {
                    min: "measure create",
                    max: "measure create",
                    now: "now create",
                    select: "parse create validate",
                    highlight: "parse navigate create validate",
                    view: "parse create validate viewset",
                    disable: "deactivate",
                    enable: "activate"
                };
                n.item = {};
                n.item.clear = null;
                n.item.disable = (t.disable || []).slice(0);
                n.item.enable = -function(e) {
                    return !0 === e[0] ? e.shift() : -1;
                }(n.item.disable);
                n.set("min", t.min).set("max", t.max).set("now");
                // When thereâs a value, set the `select`, which in turn
                // also sets the `highlight` and `view`.
                if (a) n.set("select", a, {
                    format: s
                }); else n.set("select", null).set("highlight", n.item.now);
                // The keycode to movement mapping.
                n.key = {
                    40: 7,
                    // Down
                    38: -7,
                    // Up
                    39: function() {
                        return l() ? -1 : 1;
                    },
                    // Right
                    37: function() {
                        return l() ? 1 : -1;
                    },
                    // Left
                    go: function(e) {
                        var t = n.item.highlight, i = new Date(t.year, t.month, t.date + e);
                        n.set("highlight", i, {
                            interval: e
                        });
                        this.render();
                    }
                };
                e.on("render", function() {
                    e.$root.find("." + t.klass.selectMonth).on("change", function() {
                        var n = this.value;
                        if (n) {
                            e.set("highlight", [ e.get("view").year, n, e.get("highlight").date ]);
                            e.$root.find("." + t.klass.selectMonth).trigger("focus");
                        }
                    });
                    e.$root.find("." + t.klass.selectYear).on("change", function() {
                        var n = this.value;
                        if (n) {
                            e.set("highlight", [ n, e.get("view").month, e.get("highlight").date ]);
                            e.$root.find("." + t.klass.selectYear).trigger("focus");
                        }
                    });
                }, 1).on("open", function() {
                    var i = "";
                    if (n.disabled(n.get("now"))) i = ":not(." + t.klass.buttonToday + ")";
                    e.$root.find("button" + i + ", select").attr("disabled", !1);
                }, 1).on("close", function() {
                    e.$root.find("button, select").attr("disabled", !0);
                }, 1);
            }
            /**
   * Globals and constants
   */
            var i = 7, r = 6, o = e._;
            //DatePicker
            /**
   * Set a datepicker item object.
   */
            n.prototype.set = function(e, t, n) {
                var i = this, r = i.item;
                // If the value is `null` just set it immediately.
                if (null === t) {
                    if ("clear" == e) e = "select";
                    r[e] = t;
                    return i;
                }
                // Otherwise go through the queue of methods, and invoke the functions.
                // Update this as the time unit, and set the final value as this item.
                // * In the case of `enable`, keep the queue but set `disable` instead.
                //   And in the case of `flip`, keep the queue but set `enable` instead.
                r["enable" == e ? "disable" : "flip" == e ? "enable" : e] = i.queue[e].split(" ").map(function(r) {
                    t = i[r](e, t, n);
                    return t;
                }).pop();
                // Check if we need to cascade through more updates.
                if ("select" == e) i.set("highlight", r.select, n); else if ("highlight" == e) i.set("view", r.highlight, n); else if (e.match(/^(flip|min|max|disable|enable)$/)) {
                    if (r.select && i.disabled(r.select)) i.set("select", r.select, n);
                    if (r.highlight && i.disabled(r.highlight)) i.set("highlight", r.highlight, n);
                }
                return i;
            };
            //DatePicker.prototype.set
            /**
   * Get a datepicker item object.
   */
            n.prototype.get = function(e) {
                return this.item[e];
            };
            //DatePicker.prototype.get
            /**
   * Create a picker date object.
   */
            n.prototype.create = function(e, n, i) {
                var r, a = this;
                // If thereâs no value, use the type as the value.
                n = n === undefined ? e : n;
                // If itâs infinity, update the value.
                if (n == -Infinity || n == Infinity) r = n; else if (t.isPlainObject(n) && o.isInteger(n.pick)) n = n.obj; else if (t.isArray(n)) {
                    n = new Date(n[0], n[1], n[2]);
                    n = o.isDate(n) ? n : a.create().obj;
                } else if (o.isInteger(n) || o.isDate(n)) n = a.normalize(new Date(n), i); else n = a.now(e, n, i);
                // Return the compiled object.
                return {
                    year: r || n.getFullYear(),
                    month: r || n.getMonth(),
                    date: r || n.getDate(),
                    day: r || n.getDay(),
                    obj: r || n,
                    pick: r || n.getTime()
                };
            };
            //DatePicker.prototype.create
            /**
   * Create a range limit object using an array, date object,
   * literal âtrueâ, or integer relative to another time.
   */
            n.prototype.createRange = function(e, n) {
                var i = this, r = function(e) {
                    if (!0 === e || t.isArray(e) || o.isDate(e)) return i.create(e);
                    return e;
                };
                // Create objects if possible.
                if (!o.isInteger(e)) e = r(e);
                if (!o.isInteger(n)) n = r(n);
                // Create relative dates.
                if (o.isInteger(e) && t.isPlainObject(n)) e = [ n.year, n.month, n.date + e ]; else if (o.isInteger(n) && t.isPlainObject(e)) n = [ e.year, e.month, e.date + n ];
                return {
                    from: r(e),
                    to: r(n)
                };
            };
            //DatePicker.prototype.createRange
            /**
   * Check if a date unit falls within a date range object.
   */
            n.prototype.withinRange = function(e, t) {
                e = this.createRange(e.from, e.to);
                return t.pick >= e.from.pick && t.pick <= e.to.pick;
            };
            /**
   * Check if two date range objects overlap.
   */
            n.prototype.overlapRanges = function(e, t) {
                var n = this;
                // Convert the ranges into comparable dates.
                e = n.createRange(e.from, e.to);
                t = n.createRange(t.from, t.to);
                return n.withinRange(e, t.from) || n.withinRange(e, t.to) || n.withinRange(t, e.from) || n.withinRange(t, e.to);
            };
            /**
   * Get the date today.
   */
            n.prototype.now = function(e, t, n) {
                t = new Date();
                if (n && n.rel) t.setDate(t.getDate() + n.rel);
                return this.normalize(t, n);
            };
            /**
   * Navigate to next/prev month.
   */
            n.prototype.navigate = function(e, n, i) {
                var r, o, a, s, l = t.isArray(n), u = t.isPlainObject(n), c = this.item.view;
                /*,
                                        safety = 100*/
                if (l || u) {
                    if (u) {
                        o = n.year;
                        a = n.month;
                        s = n.date;
                    } else {
                        o = +n[0];
                        a = +n[1];
                        s = +n[2];
                    }
                    // If weâre navigating months but the view is in a different
                    // month, navigate to the viewâs year and month.
                    if (i && i.nav && c && c.month !== a) {
                        o = c.year;
                        a = c.month;
                    }
                    // Figure out the expected target year and month.
                    r = new Date(o, a + (i && i.nav ? i.nav : 0), 1);
                    o = r.getFullYear();
                    a = r.getMonth();
                    // If the month weâre going to doesnât have enough days,
                    // keep decreasing the date until we reach the monthâs last date.
                    for (;/*safety &&*/ new Date(o, a, s).getMonth() !== a; ) s -= 1;
                    n = [ o, a, s ];
                }
                return n;
            };
            //DatePicker.prototype.navigate
            /**
   * Normalize a date by setting the hours to midnight.
   */
            n.prototype.normalize = function(e) {
                e.setHours(0, 0, 0, 0);
                return e;
            };
            /**
   * Measure the range of dates.
   */
            n.prototype.measure = function(e, t) {
                var n = this;
                // If itâs anything false-y, remove the limits.
                if (!t) t = "min" == e ? -Infinity : Infinity; else if ("string" == typeof t) t = n.parse(e, t); else if (o.isInteger(t)) t = n.now(e, t, {
                    rel: t
                });
                return t;
            };
            ///DatePicker.prototype.measure
            /**
   * Create a viewset object based on navigation.
   */
            n.prototype.viewset = function(e, t) {
                return this.create([ t.year, t.month, 1 ]);
            };
            /**
   * Validate a date as enabled and shift if needed.
   */
            n.prototype.validate = function(e, n, i) {
                var r = this, // Keep a reference to the original date.
                a = n, // Make sure we have an interval.
                s = i && i.interval ? i.interval : 1, // Check if the calendar enabled dates are inverted.
                l = -1 === r.item.enable, // Check if we have any enabled dates after/before now.
                u, c, // The min & max limits.
                f = r.item.min, d = r.item.max, // Check if weâve reached the limit during shifting.
                p, h, // Check if the calendar is inverted and at least one weekday is enabled.
                v = l && r.item.disable.filter(function(e) {
                    // If thereâs a date, check where it is relative to the target.
                    if (t.isArray(e)) {
                        var i = r.create(e).pick;
                        if (i < n.pick) u = !0; else if (i > n.pick) c = !0;
                    }
                    // Return only integers for enabled weekdays.
                    return o.isInteger(e);
                }).length;
                /*,
               safety = 100*/
                // Cases to validate for:
                // [1] Not inverted and date disabled.
                // [2] Inverted and some dates enabled.
                // [3] Not inverted and out of range.
                //
                // Cases to **not** validate for:
                // â¢ Navigating months.
                // â¢ Not inverted and date enabled.
                // â¢ Inverted and all dates disabled.
                // â¢ ..and anything else.
                if (!i || !i.nav) if (/* 1 */
                !l && r.disabled(n) || /* 2 */
                l && r.disabled(n) && (v || u || c) || /* 3 */
                !l && (n.pick <= f.pick || n.pick >= d.pick)) {
                    // When inverted, flip the direction if there arenât any enabled weekdays
                    // and there are no enabled dates in the direction of the interval.
                    if (l && !v && (!c && s > 0 || !u && s < 0)) s *= -1;
                    // Keep looping until we reach an enabled date.
                    for (;/*safety &&*/ r.disabled(n); ) {
                        /*safety -= 1
        if ( !safety ) {
            throw 'Fell into an infinite loop while validating ' + dateObject.obj + '.'
        }*/
                        // If weâve looped into the next/prev month with a large interval, return to the original date and flatten the interval.
                        if (Math.abs(s) > 1 && (n.month < a.month || n.month > a.month)) {
                            n = a;
                            s = s > 0 ? 1 : -1;
                        }
                        // If weâve reached the min/max limit, reverse the direction, flatten the interval and set it to the limit.
                        if (n.pick <= f.pick) {
                            p = !0;
                            s = 1;
                            n = r.create([ f.year, f.month, f.date + (n.pick === f.pick ? 0 : -1) ]);
                        } else if (n.pick >= d.pick) {
                            h = !0;
                            s = -1;
                            n = r.create([ d.year, d.month, d.date + (n.pick === d.pick ? 0 : 1) ]);
                        }
                        // If weâve reached both limits, just break out of the loop.
                        if (p && h) break;
                        // Finally, create the shifted date using the interval and keep looping.
                        n = r.create([ n.year, n.month, n.date + s ]);
                    }
                }
                //endif
                // Return the date object settled on.
                return n;
            };
            //DatePicker.prototype.validate
            /**
   * Check if a date is disabled.
   */
            n.prototype.disabled = function(e) {
                var n = this, // Filter through the disabled dates to check if this is one.
                i = n.item.disable.filter(function(i) {
                    // If the date is a number, match the weekday with 0index and `firstDay` check.
                    if (o.isInteger(i)) return e.day === (n.settings.firstDay ? i : i - 1) % 7;
                    // If itâs an array or a native JS date, create and match the exact date.
                    if (t.isArray(i) || o.isDate(i)) return e.pick === n.create(i).pick;
                    // If itâs an object, match a date within the âfromâ and âtoâ range.
                    if (t.isPlainObject(i)) return n.withinRange(i, e);
                });
                // If this date matches a disabled date, confirm itâs not inverted.
                i = i.length && !i.filter(function(e) {
                    return t.isArray(e) && "inverted" == e[3] || t.isPlainObject(e) && e.inverted;
                }).length;
                // Check the calendar âenabledâ flag and respectively flip the
                // disabled state. Then also check if itâs beyond the min/max limits.
                return -1 === n.item.enable ? !i : i || e.pick < n.item.min.pick || e.pick > n.item.max.pick;
            };
            //DatePicker.prototype.disabled
            /**
   * Parse a string into a usable type.
   */
            n.prototype.parse = function(e, t, n) {
                var i = this, r = {};
                // If itâs already parsed, weâre good.
                if (!t || "string" != typeof t) return t;
                // We need a `.format` to parse the value with.
                if (!n || !n.format) {
                    n = n || {};
                    n.format = i.settings.format;
                }
                // Convert the format into an array and then map through it.
                i.formats.toArray(n.format).map(function(e) {
                    var // Grab the formatting label.
                    n = i.formats[e], // The format length is from the formatting label function or the
                    // label length without the escaping exclamation (!) mark.
                    a = n ? o.trigger(n, i, [ t, r ]) : e.replace(/^!/, "").length;
                    // If there's a format label, split the value up to the format length.
                    // Then add it to the parsing object with appropriate label.
                    if (n) r[e] = t.substr(0, a);
                    // Update the value as the substring from format length to end.
                    t = t.substr(a);
                });
                // Compensate for month 0index.
                return [ r.yyyy || r.yy, +(r.mm || r.m) - 1, r.dd || r.d ];
            };
            //DatePicker.prototype.parse
            /**
   * Various formats to display the object in.
   */
            n.prototype.formats = function() {
                // Return the length of the first word in a collection.
                function e(e, t, n) {
                    // Grab the first word from the string.
                    var i = e.match(/\w+/)[0];
                    // If there's no month index, add it to the date object
                    if (!n.mm && !n.m) n.m = t.indexOf(i) + 1;
                    // Return the length of the word.
                    return i.length;
                }
                // Get the length of the first word in a string.
                function t(e) {
                    return e.match(/\w+/)[0].length;
                }
                return {
                    d: function(e, t) {
                        // If there's string, then get the digits length.
                        // Otherwise return the selected date.
                        return e ? o.digits(e) : t.date;
                    },
                    dd: function(e, t) {
                        // If there's a string, then the length is always 2.
                        // Otherwise return the selected date with a leading zero.
                        return e ? 2 : o.lead(t.date);
                    },
                    ddd: function(e, n) {
                        // If there's a string, then get the length of the first word.
                        // Otherwise return the short selected weekday.
                        return e ? t(e) : this.settings.weekdaysShort[n.day];
                    },
                    dddd: function(e, n) {
                        // If there's a string, then get the length of the first word.
                        // Otherwise return the full selected weekday.
                        return e ? t(e) : this.settings.weekdaysFull[n.day];
                    },
                    m: function(e, t) {
                        // If there's a string, then get the length of the digits
                        // Otherwise return the selected month with 0index compensation.
                        return e ? o.digits(e) : t.month + 1;
                    },
                    mm: function(e, t) {
                        // If there's a string, then the length is always 2.
                        // Otherwise return the selected month with 0index and leading zero.
                        return e ? 2 : o.lead(t.month + 1);
                    },
                    mmm: function(t, n) {
                        var i = this.settings.monthsShort;
                        // If there's a string, get length of the relevant month from the short
                        // months collection. Otherwise return the selected month from that collection.
                        return t ? e(t, i, n) : i[n.month];
                    },
                    mmmm: function(t, n) {
                        var i = this.settings.monthsFull;
                        // If there's a string, get length of the relevant month from the full
                        // months collection. Otherwise return the selected month from that collection.
                        return t ? e(t, i, n) : i[n.month];
                    },
                    yy: function(e, t) {
                        // If there's a string, then the length is always 2.
                        // Otherwise return the selected year by slicing out the first 2 digits.
                        return e ? 2 : ("" + t.year).slice(2);
                    },
                    yyyy: function(e, t) {
                        // If there's a string, then the length is always 4.
                        // Otherwise return the selected year.
                        return e ? 4 : t.year;
                    },
                    // Create an array by splitting the formatting string passed.
                    toArray: function(e) {
                        return e.split(/(d{1,4}|m{1,4}|y{4}|yy|!.)/g);
                    },
                    // Format an object into a string using the formatting options.
                    toString: function(e, t) {
                        var n = this;
                        return n.formats.toArray(e).map(function(e) {
                            return o.trigger(n.formats[e], n, [ 0, t ]) || e.replace(/^!/, "");
                        }).join("");
                    }
                };
            }();
            //DatePicker.prototype.formats
            /**
   * Check if two date units are the exact.
   */
            n.prototype.isDateExact = function(e, n) {
                var i = this;
                // When weâre working with weekdays, do a direct comparison.
                if (o.isInteger(e) && o.isInteger(n) || "boolean" == typeof e && "boolean" == typeof n) return e === n;
                // When weâre working with date representations, compare the âpickâ value.
                if ((o.isDate(e) || t.isArray(e)) && (o.isDate(n) || t.isArray(n))) return i.create(e).pick === i.create(n).pick;
                // When weâre working with range objects, compare the âfromâ and âtoâ.
                if (t.isPlainObject(e) && t.isPlainObject(n)) return i.isDateExact(e.from, n.from) && i.isDateExact(e.to, n.to);
                return !1;
            };
            /**
   * Check if two date units overlap.
   */
            n.prototype.isDateOverlap = function(e, n) {
                var i = this, r = i.settings.firstDay ? 1 : 0;
                // When weâre working with a weekday index, compare the days.
                if (o.isInteger(e) && (o.isDate(n) || t.isArray(n))) {
                    e = e % 7 + r;
                    return e === i.create(n).day + 1;
                }
                if (o.isInteger(n) && (o.isDate(e) || t.isArray(e))) {
                    n = n % 7 + r;
                    return n === i.create(e).day + 1;
                }
                // When weâre working with range objects, check if the ranges overlap.
                if (t.isPlainObject(e) && t.isPlainObject(n)) return i.overlapRanges(e, n);
                return !1;
            };
            /**
   * Flip the âenabledâ state.
   */
            n.prototype.flipEnable = function(e) {
                var t = this.item;
                t.enable = e || (-1 == t.enable ? 1 : -1);
            };
            /**
   * Mark a collection of dates as âdisabledâ.
   */
            n.prototype.deactivate = function(e, n) {
                var i = this, r = i.item.disable.slice(0);
                // If weâre flipping, thatâs all we need to do.
                if ("flip" == n) i.flipEnable(); else if (!1 === n) {
                    i.flipEnable(1);
                    r = [];
                } else if (!0 === n) {
                    i.flipEnable(-1);
                    r = [];
                } else n.map(function(e) {
                    var n;
                    // When we have disabled items, check for matches.
                    // If something is matched, immediately break out.
                    for (var a = 0; a < r.length; a += 1) if (i.isDateExact(e, r[a])) {
                        n = !0;
                        break;
                    }
                    // If nothing was found, add the validated unit to the collection.
                    if (!n) if (o.isInteger(e) || o.isDate(e) || t.isArray(e) || t.isPlainObject(e) && e.from && e.to) r.push(e);
                });
                // Return the updated collection.
                return r;
            };
            //DatePicker.prototype.deactivate
            /**
   * Mark a collection of dates as âenabledâ.
   */
            n.prototype.activate = function(e, n) {
                var i = this, r = i.item.disable, a = r.length;
                // If weâre flipping, thatâs all we need to do.
                if ("flip" == n) i.flipEnable(); else if (!0 === n) {
                    i.flipEnable(1);
                    r = [];
                } else if (!1 === n) {
                    i.flipEnable(-1);
                    r = [];
                } else n.map(function(e) {
                    var n, s, l, u;
                    // Go through the disabled items and try to find a match.
                    for (l = 0; l < a; l += 1) {
                        s = r[l];
                        // When an exact match is found, remove it from the collection.
                        if (i.isDateExact(s, e)) {
                            n = r[l] = null;
                            u = !0;
                            break;
                        } else if (i.isDateOverlap(s, e)) {
                            if (t.isPlainObject(e)) {
                                e.inverted = !0;
                                n = e;
                            } else if (t.isArray(e)) {
                                n = e;
                                if (!n[3]) n.push("inverted");
                            } else if (o.isDate(e)) n = [ e.getFullYear(), e.getMonth(), e.getDate(), "inverted" ];
                            break;
                        }
                    }
                    // If a match was found, remove a previous duplicate entry.
                    if (n) for (l = 0; l < a; l += 1) if (i.isDateExact(r[l], e)) {
                        r[l] = null;
                        break;
                    }
                    // In the event that weâre dealing with an exact range of dates,
                    // make sure there are no âinvertedâ dates because of it.
                    if (u) for (l = 0; l < a; l += 1) if (i.isDateOverlap(r[l], e)) {
                        r[l] = null;
                        break;
                    }
                    // If something is still matched, add it into the collection.
                    if (n) r.push(n);
                });
                // Return the updated collection.
                return r.filter(function(e) {
                    return null != e;
                });
            };
            //DatePicker.prototype.activate
            /**
   * Create a string for the nodes in the picker.
   */
            n.prototype.nodes = function(e) {
                var t = this, n = t.settings, a = t.item, s = a.now, l = a.select, u = a.highlight, c = a.view, f = a.disable, d = a.min, p = a.max, // Create the calendar table head using a copy of weekday labels collection.
                // * We do a copy so we don't mutate the original array.
                h = function(e, t) {
                    // If the first day should be Monday, move Sunday to the end.
                    if (n.firstDay) {
                        e.push(e.shift());
                        t.push(t.shift());
                    }
                    // Create and return the table head group.
                    return o.node("thead", o.node("tr", o.group({
                        min: 0,
                        max: i - 1,
                        i: 1,
                        node: "th",
                        item: function(i) {
                            return [ e[i], n.klass.weekdays, 'scope=col title="' + t[i] + '"' ];
                        }
                    })));
                }((n.showWeekdaysFull ? n.weekdaysFull : n.weekdaysLetter).slice(0), n.weekdaysFull.slice(0)), //tableHead
                // Create the nav for next/prev month.
                v = function(e) {
                    // Otherwise, return the created month tag.
                    // If the focused month is outside the range, disabled the button.
                    return o.node("div", " ", n.klass["nav" + (e ? "Next" : "Prev")] + (e && c.year >= p.year && c.month >= p.month || !e && c.year <= d.year && c.month <= d.month ? " " + n.klass.navDisabled : ""), "data-nav=" + (e || -1) + " " + o.ariaAttr({
                        role: "button",
                        controls: t.$node[0].id + "_table"
                    }) + " " + 'title="' + (e ? n.labelMonthNext : n.labelMonthPrev) + '"');
                }, //createMonthNav
                // Create the month label.
                //Materialize modified
                g = function(i) {
                    var r = n.showMonthsShort ? n.monthsShort : n.monthsFull;
                    // Materialize modified
                    if ("short_months" == i) r = n.monthsShort;
                    // If there are months to select, add a dropdown menu.
                    if (n.selectMonths && i == undefined) return o.node("select", o.group({
                        min: 0,
                        max: 11,
                        i: 1,
                        node: "option",
                        item: function(e) {
                            return [ // The looped month and no classes.
                            r[e], 0, // Set the value and selected index.
                            "value=" + e + (c.month == e ? " selected" : "") + (c.year == d.year && e < d.month || c.year == p.year && e > p.month ? " disabled" : "") ];
                        }
                    }), n.klass.selectMonth + " browser-default", (e ? "" : "disabled") + " " + o.ariaAttr({
                        controls: t.$node[0].id + "_table"
                    }) + " " + 'title="' + n.labelMonthSelect + '"');
                    // Materialize modified
                    if ("short_months" == i) if (null != l) return r[l.month]; else return r[c.month];
                    // If there's a need for a month selector
                    return o.node("div", r[c.month], n.klass.month);
                }, //createMonthLabel
                // Create the year label.
                // Materialize modified
                m = function(i) {
                    var r = c.year, // If years selector is set to a literal "true", set it to 5. Otherwise
                    // divide in half to get half before and half after focused year.
                    a = !0 === n.selectYears ? 5 : ~~(n.selectYears / 2);
                    // If there are years to select, add a dropdown menu.
                    if (a) {
                        var s = d.year, l = p.year, u = r - a, f = r + a;
                        // If the min year is greater than the lowest year, increase the highest year
                        // by the difference and set the lowest year to the min year.
                        if (s > u) {
                            f += s - u;
                            u = s;
                        }
                        // If the max year is less than the highest year, decrease the lowest year
                        // by the lower of the two: available and needed years. Then set the
                        // highest year to the max year.
                        if (l < f) {
                            var h = u - s, v = f - l;
                            u -= h > v ? v : h;
                            f = l;
                        }
                        if (n.selectYears && i == undefined) return o.node("select", o.group({
                            min: u,
                            max: f,
                            i: 1,
                            node: "option",
                            item: function(e) {
                                return [ // The looped year and no classes.
                                e, 0, // Set the value and selected index.
                                "value=" + e + (r == e ? " selected" : "") ];
                            }
                        }), n.klass.selectYear + " browser-default", (e ? "" : "disabled") + " " + o.ariaAttr({
                            controls: t.$node[0].id + "_table"
                        }) + " " + 'title="' + n.labelYearSelect + '"');
                    }
                    // Materialize modified
                    if ("raw" == i) return o.node("div", r);
                    // Otherwise just return the year focused
                    return o.node("div", r, n.klass.year);
                };
                //createYearLabel
                // Materialize modified
                createDayLabel = function() {
                    if (null != l) return l.date; else return s.date;
                };
                createWeekdayLabel = function() {
                    var e;
                    if (null != l) e = l.day; else e = s.day;
                    return n.weekdaysShort[e];
                };
                // Create and return the entire calendar.
                // Date presentation View
                // Div for Year
                // Div for short Month
                // Div for Day
                // Calendar container
                // * For Firefox forms to submit, make sure to set the buttonsâ `type` attributes as âbuttonâ.
                return o.node("div", o.node("div", m("raw"), n.klass.year_display) + o.node("span", createWeekdayLabel() + ", ", "picker__weekday-display") + o.node("span", g("short_months") + " ", n.klass.month_display) + o.node("span", createDayLabel(), n.klass.day_display), n.klass.date_display) + o.node("div", o.node("div", o.node("div", (n.selectYears ? g() + m() : g() + m()) + v() + v(1), n.klass.header) + o.node("table", h + o.node("tbody", o.group({
                    min: 0,
                    max: r - 1,
                    i: 1,
                    node: "tr",
                    item: function(e) {
                        // If Monday is the first day and the month starts on Sunday, shift the date back a week.
                        var r = n.firstDay && 0 === t.create([ c.year, c.month, 1 ]).day ? -7 : 0;
                        return [ o.group({
                            min: i * e - c.day + r + 1,
                            // Add 1 for weekday 0index
                            max: function() {
                                return this.min + i - 1;
                            },
                            i: 1,
                            node: "td",
                            item: function(e) {
                                // Convert the time date from a relative date to a target date.
                                e = t.create([ c.year, c.month, e + (n.firstDay ? 1 : 0) ]);
                                var i = l && l.pick == e.pick, r = u && u.pick == e.pick, a = f && t.disabled(e) || e.pick < d.pick || e.pick > p.pick, h = o.trigger(t.formats.toString, t, [ n.format, e ]);
                                return [ o.node("div", e.date, function(t) {
                                    // Add the `infocus` or `outfocus` classes based on month in view.
                                    t.push(c.month == e.month ? n.klass.infocus : n.klass.outfocus);
                                    // Add the `today` class if needed.
                                    if (s.pick == e.pick) t.push(n.klass.now);
                                    // Add the `selected` class if something's selected and the time matches.
                                    if (i) t.push(n.klass.selected);
                                    // Add the `highlighted` class if something's highlighted and the time matches.
                                    if (r) t.push(n.klass.highlighted);
                                    // Add the `disabled` class if something's disabled and the object matches.
                                    if (a) t.push(n.klass.disabled);
                                    return t.join(" ");
                                }([ n.klass.day ]), "data-pick=" + e.pick + " " + o.ariaAttr({
                                    role: "gridcell",
                                    label: h,
                                    selected: i && t.$node.val() === h ? !0 : null,
                                    activedescendant: r ? !0 : null,
                                    disabled: a ? !0 : null
                                }) + " " + (a ? "" : 'tabindex="0"')), "", o.ariaAttr({
                                    role: "presentation"
                                }) ];
                            }
                        }) ];
                    }
                })), n.klass.table, 'id="' + t.$node[0].id + "_table" + '" ' + o.ariaAttr({
                    role: "grid",
                    controls: t.$node[0].id,
                    readonly: !0
                })), n.klass.calendar_container) + o.node("div", o.node("button", n.today, "btn-flat picker__today waves-effect", "type=button data-pick=" + s.pick + (e && !t.disabled(s) ? "" : " disabled") + " " + o.ariaAttr({
                    controls: t.$node[0].id
                })) + o.node("button", n.clear, "btn-flat picker__clear waves-effect", "type=button data-clear=1" + (e ? "" : " disabled") + " " + o.ariaAttr({
                    controls: t.$node[0].id
                })) + o.node("button", n.close, "btn-flat picker__close waves-effect", "type=button data-close=true " + (e ? "" : " disabled") + " " + o.ariaAttr({
                    controls: t.$node[0].id
                })), n.klass.footer), "picker__container__wrapper");
            };
            //DatePicker.prototype.nodes
            /**
   * The date picker defaults.
   */
            n.defaults = function(e) {
                return {
                    // The title label to use for the month nav buttons
                    labelMonthNext: "Next month",
                    labelMonthPrev: "Previous month",
                    // The title label to use for the dropdown selectors
                    labelMonthSelect: "Select a month",
                    labelYearSelect: "Select a year",
                    // Months and weekdays
                    monthsFull: [ "January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December" ],
                    monthsShort: [ "Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec" ],
                    weekdaysFull: [ "Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday" ],
                    weekdaysShort: [ "Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat" ],
                    // Materialize modified
                    weekdaysLetter: [ "S", "M", "T", "W", "T", "F", "S" ],
                    // Today and clear
                    today: "Today",
                    clear: "Clear",
                    close: "Ok",
                    // Picker close behavior (Prevent a change in behaviour for backwards compatibility)
                    closeOnSelect: !1,
                    // The format to show on the `input` element
                    format: "d mmmm, yyyy",
                    // Classes
                    klass: {
                        table: e + "table",
                        header: e + "header",
                        // Materialize Added klasses
                        date_display: e + "date-display",
                        day_display: e + "day-display",
                        month_display: e + "month-display",
                        year_display: e + "year-display",
                        calendar_container: e + "calendar-container",
                        // end
                        navPrev: e + "nav--prev",
                        navNext: e + "nav--next",
                        navDisabled: e + "nav--disabled",
                        month: e + "month",
                        year: e + "year",
                        selectMonth: e + "select--month",
                        selectYear: e + "select--year",
                        weekdays: e + "weekday",
                        day: e + "day",
                        disabled: e + "day--disabled",
                        selected: e + "day--selected",
                        highlighted: e + "day--highlighted",
                        now: e + "day--today",
                        infocus: e + "day--infocus",
                        outfocus: e + "day--outfocus",
                        footer: e + "footer",
                        buttonClear: e + "button--clear",
                        buttonToday: e + "button--today",
                        buttonClose: e + "button--close"
                    }
                };
            }(e.klasses().picker + "__");
            /**
   * Extend the picker to add the date picker.
   */
            e.extend("pickadate", n);
        });
        /*!
  * ClockPicker v0.0.7 (http://weareoutman.github.io/clockpicker/)
  * Copyright 2014 Wang Shenwei.
  * Licensed under MIT (https://github.com/weareoutman/clockpicker/blob/gh-pages/LICENSE)
  *
  * Further modified
  * Copyright 2015 Ching Yaw Hao.
  */
        !function() {
            function e(e) {
                return document.createElementNS(l, e);
            }
            function t(e) {
                return (e < 10 ? "0" : "") + e;
            }
            function n(e) {
                var t = ++g + "";
                return e ? e + t : t;
            }
            // ClockPicker
            function i(i, a) {
                // Mousedown or touchstart
                function l(e, t) {
                    var n = f.offset(), i = /^touch/.test(e.type), r = n.left + m, o = n.top + m, l = (i ? e.originalEvent.touches[0] : e).pageX - r, u = (i ? e.originalEvent.touches[0] : e).pageY - o, c = Math.sqrt(l * l + u * u), d = !1;
                    // When clicking on minutes view space, check the mouse position
                    if (t && (c < y - x || c > y + x)) return;
                    e.preventDefault();
                    // Set cursor style of body after 200ms
                    var v = setTimeout(function() {
                        D.popover.addClass("clockpicker-moving");
                    }, 200);
                    // Clock
                    D.setHand(l, u, !t, !0);
                    // Mousemove on document
                    s.off(p).on(p, function(e) {
                        e.preventDefault();
                        var t = /^touch/.test(e.type), n = (t ? e.originalEvent.touches[0] : e).pageX - r, i = (t ? e.originalEvent.touches[0] : e).pageY - o;
                        if (!d && n === l && i === u) // Clicking in chrome on windows will trigger a mousemove event
                        return;
                        d = !0;
                        D.setHand(n, i, !1, !0);
                    });
                    // Mouseup on document
                    s.off(h).on(h, function(e) {
                        s.off(h);
                        e.preventDefault();
                        var n = /^touch/.test(e.type), i = (n ? e.originalEvent.changedTouches[0] : e).pageX - r, c = (n ? e.originalEvent.changedTouches[0] : e).pageY - o;
                        if ((t || d) && i === l && c === u) D.setHand(i, c);
                        if ("hours" === D.currentView) D.toggleView("minutes", T / 2); else if (a.autoclose) {
                            D.minutesView.addClass("clockpicker-dial-out");
                            setTimeout(function() {
                                D.done();
                            }, T / 2);
                        }
                        f.prepend(I);
                        // Reset cursor style of body
                        clearTimeout(v);
                        D.popover.removeClass("clockpicker-moving");
                        // Unbind mousemove event
                        s.off(p);
                    });
                }
                var c = o(C), f = c.find(".clockpicker-plate"), v = c.find(".picker__holder"), g = c.find(".clockpicker-hours"), k = c.find(".clockpicker-minutes"), S = c.find(".clockpicker-am-pm-block"), E = "INPUT" === i.prop("tagName"), A = E ? i : i.find("input"), P = o("label[for=" + A.attr("id") + "]"), D = this;
                this.id = n("cp");
                this.element = i;
                this.holder = v;
                this.options = a;
                this.isAppended = !1;
                this.isShown = !1;
                this.currentView = "hours";
                this.isInput = E;
                this.input = A;
                this.label = P;
                this.popover = c;
                this.plate = f;
                this.hoursView = g;
                this.minutesView = k;
                this.amPmBlock = S;
                this.spanHours = c.find(".clockpicker-span-hours");
                this.spanMinutes = c.find(".clockpicker-span-minutes");
                this.spanAmPm = c.find(".clockpicker-span-am-pm");
                this.footer = c.find(".picker__footer");
                this.amOrPm = "PM";
                // Setup for for 12 hour clock if option is selected
                if (a.twelvehour) if (!a.ampmclickable) {
                    this.spanAmPm.empty();
                    o('<div id="click-am">AM</div>').appendTo(this.spanAmPm);
                    o('<div id="click-pm">PM</div>').appendTo(this.spanAmPm);
                } else {
                    this.spanAmPm.empty();
                    o('<div id="click-am">AM</div>').on("click", function() {
                        D.spanAmPm.children("#click-am").addClass("text-primary");
                        D.spanAmPm.children("#click-pm").removeClass("text-primary");
                        D.amOrPm = "AM";
                    }).appendTo(this.spanAmPm);
                    o('<div id="click-pm">PM</div>').on("click", function() {
                        D.spanAmPm.children("#click-pm").addClass("text-primary");
                        D.spanAmPm.children("#click-am").removeClass("text-primary");
                        D.amOrPm = "PM";
                    }).appendTo(this.spanAmPm);
                }
                // Add buttons to footer
                o('<button type="button" class="btn-flat picker__clear" tabindex="' + (a.twelvehour ? "3" : "1") + '">' + a.cleartext + "</button>").click(o.proxy(this.clear, this)).appendTo(this.footer);
                o('<button type="button" class="btn-flat picker__close" tabindex="' + (a.twelvehour ? "3" : "1") + '">' + a.canceltext + "</button>").click(o.proxy(this.hide, this)).appendTo(this.footer);
                o('<button type="button" class="btn-flat picker__close" tabindex="' + (a.twelvehour ? "3" : "1") + '">' + a.donetext + "</button>").click(o.proxy(this.done, this)).appendTo(this.footer);
                this.spanHours.click(o.proxy(this.toggleView, this, "hours"));
                this.spanMinutes.click(o.proxy(this.toggleView, this, "minutes"));
                // Show or toggle
                A.on("focus.clockpicker click.clockpicker", o.proxy(this.show, this));
                // Build ticks
                var O = o('<div class="clockpicker-tick"></div>'), N, q, j, M;
                // Hours view
                if (a.twelvehour) for (N = 1; N < 13; N += 1) {
                    q = O.clone();
                    j = N / 6 * Math.PI;
                    M = y;
                    q.css({
                        left: m + Math.sin(j) * M - x,
                        top: m - Math.cos(j) * M - x
                    });
                    q.html(0 === N ? "00" : N);
                    g.append(q);
                    q.on(d, l);
                } else for (N = 0; N < 24; N += 1) {
                    q = O.clone();
                    j = N / 6 * Math.PI;
                    var L = N > 0 && N < 13;
                    M = L ? b : y;
                    q.css({
                        left: m + Math.sin(j) * M - x,
                        top: m - Math.cos(j) * M - x
                    });
                    q.html(0 === N ? "00" : N);
                    g.append(q);
                    q.on(d, l);
                }
                // Minutes view
                for (N = 0; N < 60; N += 5) {
                    q = O.clone();
                    j = N / 30 * Math.PI;
                    q.css({
                        left: m + Math.sin(j) * y - x,
                        top: m - Math.cos(j) * y - x
                    });
                    q.html(t(N));
                    k.append(q);
                    q.on(d, l);
                }
                // Clicking on minutes view space
                f.on(d, function(e) {
                    if (0 === o(e.target).closest(".clockpicker-tick").length) l(e, !0);
                });
                if (u) {
                    // Draw clock hands and others
                    var I = c.find(".clockpicker-canvas"), H = e("svg");
                    H.setAttribute("class", "clockpicker-svg");
                    H.setAttribute("width", w);
                    H.setAttribute("height", w);
                    var _ = e("g");
                    _.setAttribute("transform", "translate(" + m + "," + m + ")");
                    var F = e("circle");
                    F.setAttribute("class", "clockpicker-canvas-bearing");
                    F.setAttribute("cx", 0);
                    F.setAttribute("cy", 0);
                    F.setAttribute("r", 4);
                    var R = e("line");
                    R.setAttribute("x1", 0);
                    R.setAttribute("y1", 0);
                    var W = e("circle");
                    W.setAttribute("class", "clockpicker-canvas-bg");
                    W.setAttribute("r", x);
                    _.appendChild(R);
                    _.appendChild(W);
                    _.appendChild(F);
                    H.appendChild(_);
                    I.append(H);
                    this.hand = R;
                    this.bg = W;
                    this.bearing = F;
                    this.g = _;
                    this.canvas = I;
                }
                r(this.options.init);
            }
            function r(e) {
                if (e && "function" === typeof e) e();
            }
            var o = window.jQuery, a = o(window), s = o(document);
            // Can I use inline svg ?
            var l = "http://www.w3.org/2000/svg", u = "SVGAngle" in window && function() {
                var e, t = document.createElement("div");
                t.innerHTML = "<svg/>";
                e = (t.firstChild && t.firstChild.namespaceURI) == l;
                t.innerHTML = "";
                return e;
            }();
            // Can I use transition ?
            var c = function() {
                var e = document.createElement("div").style;
                return "transition" in e || "WebkitTransition" in e || "MozTransition" in e || "msTransition" in e || "OTransition" in e;
            }();
            // Listen touch events in touch screen device, instead of mouse events in desktop.
            var f = "ontouchstart" in window, d = "mousedown" + (f ? " touchstart" : ""), p = "mousemove.clockpicker" + (f ? " touchmove.clockpicker" : ""), h = "mouseup.clockpicker" + (f ? " touchend.clockpicker" : "");
            // Vibrate the device if supported
            var v = navigator.vibrate ? "vibrate" : navigator.webkitVibrate ? "webkitVibrate" : null;
            // Get a unique id
            var g = 0;
            // Clock size
            var m = 135, y = 105, // innerRadius = 80 on 12 hour clock
            b = 80, x = 20, w = 2 * m, T = c ? 350 : 1;
            // Popover template
            var C = [ '<div class="clockpicker picker">', '<div class="picker__holder">', '<div class="picker__frame">', '<div class="picker__wrap">', '<div class="picker__box">', '<div class="picker__date-display">', '<div class="clockpicker-display">', '<div class="clockpicker-display-column">', '<span class="clockpicker-span-hours text-primary"></span>', ":", '<span class="clockpicker-span-minutes"></span>', "</div>", '<div class="clockpicker-display-column clockpicker-display-am-pm">', '<div class="clockpicker-span-am-pm"></div>', "</div>", "</div>", "</div>", '<div class="picker__container__wrapper">', '<div class="picker__calendar-container">', '<div class="clockpicker-plate">', '<div class="clockpicker-canvas"></div>', '<div class="clockpicker-dial clockpicker-hours"></div>', '<div class="clockpicker-dial clockpicker-minutes clockpicker-dial-out"></div>', "</div>", '<div class="clockpicker-am-pm-block">', "</div>", "</div>", '<div class="picker__footer">', "</div>", "</div>", "</div>", "</div>", "</div>", "</div>", "</div>" ].join("");
            // Default options
            i.DEFAULTS = {
                default: "",
                // default time, 'now' or '13:14' e.g.
                fromnow: 0,
                // set default time to * milliseconds from now (using with default = 'now')
                donetext: "Ok",
                // done button text
                cleartext: "Clear",
                canceltext: "Cancel",
                autoclose: !1,
                // auto close when minute is selected
                ampmclickable: !0,
                // set am/pm button on itself
                darktheme: !1,
                // set to dark theme
                twelvehour: !0,
                // change to 12 hour AM/PM clock from 24 hour
                vibrate: !0
            };
            // Show or hide popover
            i.prototype.toggle = function() {
                this[this.isShown ? "hide" : "show"]();
            };
            // Set popover position
            i.prototype.locate = function() {
                var e = this.element, t = this.popover, n = e.offset(), i = e.outerWidth(), r = e.outerHeight(), o = this.options.align, a = this;
                t.show();
            };
            // Show popover
            i.prototype.show = function(e) {
                // Not show again
                if (this.isShown) return;
                r(this.options.beforeShow);
                o(":input").each(function() {
                    o(this).attr("tabindex", -1);
                });
                var n = this;
                // Initialize
                this.input.blur();
                this.popover.addClass("picker--opened");
                this.input.addClass("picker__input picker__input--active");
                o(document.body).css("overflow", "hidden");
                // Get the time
                var i = ((this.input.prop("value") || this.options["default"] || "") + "").split(":");
                if (this.options.twelvehour && "undefined" !== typeof i[1]) {
                    if (i[1].indexOf("AM") > 0) this.amOrPm = "AM"; else this.amOrPm = "PM";
                    i[1] = i[1].replace("AM", "").replace("PM", "");
                }
                if ("now" === i[0]) {
                    var l = new Date(+new Date() + this.options.fromnow);
                    i = [ l.getHours(), l.getMinutes() ];
                    if (this.options.twelvehour) this.amOrPm = i[0] >= 12 && i[0] < 24 ? "PM" : "AM";
                }
                this.hours = +i[0] || 0;
                this.minutes = +i[1] || 0;
                this.spanHours.html(this.hours);
                this.spanMinutes.html(t(this.minutes));
                if (!this.isAppended) {
                    // Append popover to body
                    this.popover.insertAfter(this.input);
                    if (this.options.twelvehour) if ("PM" === this.amOrPm) {
                        this.spanAmPm.children("#click-pm").addClass("text-primary");
                        this.spanAmPm.children("#click-am").removeClass("text-primary");
                    } else {
                        this.spanAmPm.children("#click-am").addClass("text-primary");
                        this.spanAmPm.children("#click-pm").removeClass("text-primary");
                    }
                    // Reset position when resize
                    a.on("resize.clockpicker" + this.id, function() {
                        if (n.isShown) n.locate();
                    });
                    this.isAppended = !0;
                }
                // Toggle to hours view
                this.toggleView("hours");
                // Set position
                this.locate();
                this.isShown = !0;
                // Hide when clicking or tabbing on any element except the clock and input
                s.on("click.clockpicker." + this.id + " focusin.clockpicker." + this.id, function(e) {
                    var t = o(e.target);
                    if (0 === t.closest(n.popover.find(".picker__wrap")).length && 0 === t.closest(n.input).length) n.hide();
                });
                // Hide when ESC is pressed
                s.on("keyup.clockpicker." + this.id, function(e) {
                    if (27 === e.keyCode) n.hide();
                });
                r(this.options.afterShow);
            };
            // Hide popover
            i.prototype.hide = function() {
                r(this.options.beforeHide);
                this.input.removeClass("picker__input picker__input--active");
                this.popover.removeClass("picker--opened");
                o(document.body).css("overflow", "visible");
                this.isShown = !1;
                o(":input").each(function(e) {
                    o(this).attr("tabindex", e + 1);
                });
                // Unbinding events on document
                s.off("click.clockpicker." + this.id + " focusin.clockpicker." + this.id);
                s.off("keyup.clockpicker." + this.id);
                this.popover.hide();
                r(this.options.afterHide);
            };
            // Toggle to hours or minutes view
            i.prototype.toggleView = function(e, t) {
                var n = !1;
                if ("minutes" === e && "visible" === o(this.hoursView).css("visibility")) {
                    r(this.options.beforeHourSelect);
                    n = !0;
                }
                var i = "hours" === e, a = i ? this.hoursView : this.minutesView, s = i ? this.minutesView : this.hoursView;
                this.currentView = e;
                this.spanHours.toggleClass("text-primary", i);
                this.spanMinutes.toggleClass("text-primary", !i);
                // Let's make transitions
                s.addClass("clockpicker-dial-out");
                a.css("visibility", "visible").removeClass("clockpicker-dial-out");
                // Reset clock hand
                this.resetClock(t);
                // After transitions ended
                clearTimeout(this.toggleViewTimer);
                this.toggleViewTimer = setTimeout(function() {
                    s.css("visibility", "hidden");
                }, T);
                if (n) r(this.options.afterHourSelect);
            };
            // Reset clock hand
            i.prototype.resetClock = function(e) {
                var t = this.currentView, n = this[t], i = "hours" === t, r = Math.PI / (i ? 6 : 30), o = n * r, a = i && n > 0 && n < 13 ? b : y, s = Math.sin(o) * a, l = -Math.cos(o) * a, c = this;
                if (u && e) {
                    c.canvas.addClass("clockpicker-canvas-out");
                    setTimeout(function() {
                        c.canvas.removeClass("clockpicker-canvas-out");
                        c.setHand(s, l);
                    }, e);
                } else this.setHand(s, l);
            };
            // Set clock hand to (x, y)
            i.prototype.setHand = function(e, n, i, r) {
                var a = Math.atan2(e, -n), s = "hours" === this.currentView, l = Math.PI / (s || i ? 6 : 30), c = Math.sqrt(e * e + n * n), f = this.options, d = s && c < (y + b) / 2, p = d ? b : y, h;
                if (f.twelvehour) p = y;
                // Radian should in range [0, 2PI]
                if (a < 0) a = 2 * Math.PI + a;
                // Get the round value
                h = Math.round(a / l);
                // Get the round radian
                a = h * l;
                // Correct the hours or minutes
                if (f.twelvehour) if (s) {
                    if (0 === h) h = 12;
                } else {
                    if (i) h *= 5;
                    if (60 === h) h = 0;
                } else if (s) {
                    if (12 === h) h = 0;
                    h = d ? 0 === h ? 12 : h : 0 === h ? 0 : h + 12;
                } else {
                    if (i) h *= 5;
                    if (60 === h) h = 0;
                }
                // Once hours or minutes changed, vibrate the device
                if (this[this.currentView] !== h) if (v && this.options.vibrate) // Do not vibrate too frequently
                if (!this.vibrateTimer) {
                    navigator[v](10);
                    this.vibrateTimer = setTimeout(o.proxy(function() {
                        this.vibrateTimer = null;
                    }, this), 100);
                }
                this[this.currentView] = h;
                if (s) this.spanHours.html(h); else this.spanMinutes.html(t(h));
                // If svg is not supported, just add an active class to the tick
                if (!u) {
                    this[s ? "hoursView" : "minutesView"].find(".clockpicker-tick").each(function() {
                        var e = o(this);
                        e.toggleClass("active", h === +e.html());
                    });
                    return;
                }
                // Set clock hand and others' position
                var g = Math.sin(a) * (p - x), m = -Math.cos(a) * (p - x), w = Math.sin(a) * p, T = -Math.cos(a) * p;
                this.hand.setAttribute("x2", g);
                this.hand.setAttribute("y2", m);
                this.bg.setAttribute("cx", w);
                this.bg.setAttribute("cy", T);
            };
            // Hours and minutes are selected
            i.prototype.done = function() {
                r(this.options.beforeDone);
                this.hide();
                this.label.addClass("active");
                var e = this.input.prop("value"), n = t(this.hours) + ":" + t(this.minutes);
                if (this.options.twelvehour) n += this.amOrPm;
                this.input.prop("value", n);
                if (n !== e) {
                    this.input.triggerHandler("change");
                    if (!this.isInput) this.element.trigger("change");
                }
                if (this.options.autoclose) this.input.trigger("blur");
                r(this.options.afterDone);
            };
            // Clear input field
            i.prototype.clear = function() {
                this.hide();
                this.label.removeClass("active");
                var e = this.input.prop("value"), t = "";
                this.input.prop("value", t);
                if (t !== e) {
                    this.input.triggerHandler("change");
                    if (!this.isInput) this.element.trigger("change");
                }
                if (this.options.autoclose) this.input.trigger("blur");
            };
            // Remove clockpicker from input
            i.prototype.remove = function() {
                this.element.removeData("clockpicker");
                this.input.off("focus.clockpicker click.clockpicker");
                if (this.isShown) this.hide();
                if (this.isAppended) {
                    a.off("resize.clockpicker" + this.id);
                    this.popover.remove();
                }
            };
            // Extends $.fn.clockpicker
            o.fn.pickatime = function(e) {
                var t = Array.prototype.slice.call(arguments, 1);
                return this.each(function() {
                    var n = o(this), r = n.data("clockpicker");
                    if (!r) {
                        var a = o.extend({}, i.DEFAULTS, n.data(), "object" == typeof e && e);
                        n.data("clockpicker", new i(n, a));
                    } else // Manual operatsions. show, hide, remove, e.g.
                    if ("function" === typeof r[e]) r[e].apply(r, t);
                });
            };
        }();
        !function(e) {
            function t() {
                var t = +e(this).attr("data-length"), n = +e(this).val().length, i = n <= t;
                e(this).parent().find('span[class="character-counter"]').html(n + "/" + t);
                r(i, e(this));
            }
            function n(t) {
                var n = t.parent().find('span[class="character-counter"]');
                if (n.length) return;
                n = e("<span/>").addClass("character-counter").css("float", "right").css("font-size", "12px").css("height", 1);
                t.parent().append(n);
            }
            function i() {
                e(this).parent().find('span[class="character-counter"]').html("");
            }
            function r(e, t) {
                var n = t.hasClass("invalid");
                if (e && n) t.removeClass("invalid"); else if (!e && !n) {
                    t.removeClass("valid");
                    t.addClass("invalid");
                }
            }
            e.fn.characterCounter = function() {
                return this.each(function() {
                    var r = e(this);
                    // character counter has already been added appended to the parent container
                    if (r.parent().find('span[class="character-counter"]').length) return;
                    if (r.attr("data-length") !== undefined) {
                        r.on("input", t);
                        r.on("focus", t);
                        r.on("blur", i);
                        n(r);
                    }
                });
            };
            e(document).ready(function() {
                e("input, textarea").characterCounter();
            });
        }(l);
        !function(e) {
            var t = {
                init: function(t) {
                    var n = {
                        duration: 200,
                        // ms
                        dist: -100,
                        // zoom scale TODO: make this more intuitive as an option
                        shift: 0,
                        // spacing for center image
                        padding: 0,
                        // Padding between non center items
                        fullWidth: !1,
                        // Change to full width styles
                        indicators: !1,
                        // Toggle indicators
                        noWrap: !1,
                        // Don't wrap around and cycle through items.
                        onCycleTo: null
                    };
                    t = e.extend(n, t);
                    var i = Materialize.objectSelectorString(e(this));
                    return this.each(function(n) {
                        function r() {
                            if ("undefined" !== typeof window.ontouchstart) {
                                R.on("touchstart.carousel", p);
                                R.on("touchmove.carousel", h);
                                R.on("touchend.carousel", v);
                            }
                            R.on("mousedown.carousel", p);
                            R.on("mousemove.carousel", h);
                            R.on("mouseup.carousel", v);
                            R.on("mouseleave.carousel", v);
                            R.on("click.carousel", f);
                        }
                        function o(e) {
                            // touch event
                            if (e.targetTouches && e.targetTouches.length >= 1) return e.targetTouches[0].clientX;
                            // mouse event
                            return e.clientX;
                        }
                        function a(e) {
                            // touch event
                            if (e.targetTouches && e.targetTouches.length >= 1) return e.targetTouches[0].clientY;
                            // mouse event
                            return e.clientY;
                        }
                        function s(e) {
                            return e >= k ? e % k : e < 0 ? s(k + e % k) : e;
                        }
                        function l(n) {
                            // Track scrolling state
                            O = !0;
                            if (!R.hasClass("scrolling")) R.addClass("scrolling");
                            if (null != _) window.clearTimeout(_);
                            _ = window.setTimeout(function() {
                                O = !1;
                                R.removeClass("scrolling");
                            }, t.duration);
                            // Start actual scroll
                            var i, r, o, a, l, u, c, f;
                            var d = w;
                            x = "number" === typeof n ? n : x;
                            w = Math.floor((x + C / 2) / C);
                            o = x - w * C;
                            a = o < 0 ? 1 : -1;
                            l = -a * o * 2 / C;
                            r = k >> 1;
                            if (!t.fullWidth) {
                                c = "translateX(" + (R[0].clientWidth - m) / 2 + "px) ";
                                c += "translateY(" + (R[0].clientHeight - b) / 2 + "px)";
                            } else c = "translateX(0)";
                            // Set indicator active
                            if ($) {
                                var p = w % k;
                                var h = H.find(".indicator-item.active");
                                if (h.index() !== p) {
                                    h.removeClass("active");
                                    H.find(".indicator-item").eq(p).addClass("active");
                                }
                            }
                            // center
                            // Don't show wrapped items.
                            if (!z || w >= 0 && w < k) {
                                u = g[s(w)];
                                // Add active class to center item.
                                if (!e(u).hasClass("active")) {
                                    R.find(".carousel-item").removeClass("active");
                                    e(u).addClass("active");
                                }
                                u.style[N] = c + " translateX(" + -o / 2 + "px)" + " translateX(" + a * t.shift * l * i + "px)" + " translateZ(" + t.dist * l + "px)";
                                u.style.zIndex = 0;
                                if (t.fullWidth) tweenedOpacity = 1; else tweenedOpacity = 1 - .2 * l;
                                u.style.opacity = tweenedOpacity;
                                u.style.display = "block";
                            }
                            for (i = 1; i <= r; ++i) {
                                // right side
                                if (t.fullWidth) {
                                    zTranslation = t.dist;
                                    tweenedOpacity = i === r && o < 0 ? 1 - l : 1;
                                } else {
                                    zTranslation = t.dist * (2 * i + l * a);
                                    tweenedOpacity = 1 - .2 * (2 * i + l * a);
                                }
                                // Don't show wrapped items.
                                if (!z || w + i < k) {
                                    u = g[s(w + i)];
                                    u.style[N] = c + " translateX(" + (t.shift + (C * i - o) / 2) + "px)" + " translateZ(" + zTranslation + "px)";
                                    u.style.zIndex = -i;
                                    u.style.opacity = tweenedOpacity;
                                    u.style.display = "block";
                                }
                                // left side
                                if (t.fullWidth) {
                                    zTranslation = t.dist;
                                    tweenedOpacity = i === r && o > 0 ? 1 - l : 1;
                                } else {
                                    zTranslation = t.dist * (2 * i - l * a);
                                    tweenedOpacity = 1 - .2 * (2 * i - l * a);
                                }
                                // Don't show wrapped items.
                                if (!z || w - i >= 0) {
                                    u = g[s(w - i)];
                                    u.style[N] = c + " translateX(" + (-t.shift + (-C * i - o) / 2) + "px)" + " translateZ(" + zTranslation + "px)";
                                    u.style.zIndex = -i;
                                    u.style.opacity = tweenedOpacity;
                                    u.style.display = "block";
                                }
                            }
                            // center
                            // Don't show wrapped items.
                            if (!z || w >= 0 && w < k) {
                                u = g[s(w)];
                                u.style[N] = c + " translateX(" + -o / 2 + "px)" + " translateX(" + a * t.shift * l + "px)" + " translateZ(" + t.dist * l + "px)";
                                u.style.zIndex = 0;
                                if (t.fullWidth) tweenedOpacity = 1; else tweenedOpacity = 1 - .2 * l;
                                u.style.opacity = tweenedOpacity;
                                u.style.display = "block";
                            }
                            // onCycleTo callback
                            if (d !== w && "function" === typeof t.onCycleTo) {
                                var v = R.find(".carousel-item").eq(s(w));
                                t.onCycleTo.call(this, v, L);
                            }
                            // One time callback
                            if ("function" === typeof F) {
                                F.call(this, v, L);
                                F = null;
                            }
                        }
                        function u() {
                            var e, t, n, i;
                            e = Date.now();
                            t = e - j;
                            j = e;
                            n = x - q;
                            q = x;
                            i = 1e3 * n / (1 + t);
                            D = .8 * i + .2 * D;
                        }
                        function c() {
                            var e, n;
                            if (A) {
                                e = Date.now() - j;
                                n = A * Math.exp(-e / t.duration);
                                if (n > 2 || n < -2) {
                                    l(P - n);
                                    requestAnimationFrame(c);
                                } else l(P);
                            }
                        }
                        function f(n) {
                            // Disable clicks if carousel was dragged.
                            if (L) {
                                n.preventDefault();
                                n.stopPropagation();
                                return !1;
                            } else if (!t.fullWidth) {
                                var i = e(n.target).closest(".carousel-item").index();
                                var r = s(w) - i;
                                // Disable clicks if carousel was shifted by click
                                if (0 !== r) {
                                    n.preventDefault();
                                    n.stopPropagation();
                                }
                                d(i);
                            }
                        }
                        function d(e) {
                            var t = w % k - e;
                            // Account for wraparound.
                            if (!z) if (t < 0) {
                                if (Math.abs(t + k) < Math.abs(t)) t += k;
                            } else if (t > 0) if (Math.abs(t - k) < t) t -= k;
                            // Call prev or next accordingly.
                            if (t < 0) R.trigger("carouselNext", [ Math.abs(t) ]); else if (t > 0) R.trigger("carouselPrev", [ t ]);
                        }
                        function p(t) {
                            // Fixes firefox draggable image bug
                            if ("mousedown" === t.type && e(t.target).is("img")) t.preventDefault();
                            T = !0;
                            L = !1;
                            I = !1;
                            S = o(t);
                            E = a(t);
                            D = A = 0;
                            q = x;
                            j = Date.now();
                            clearInterval(M);
                            M = setInterval(u, 100);
                        }
                        function h(e) {
                            var t, n, i;
                            if (T) {
                                t = o(e);
                                y = a(e);
                                n = S - t;
                                i = Math.abs(E - y);
                                if (i < 30 && !I) {
                                    // If vertical scrolling don't allow dragging.
                                    if (n > 2 || n < -2) {
                                        L = !0;
                                        S = t;
                                        l(x + n);
                                    }
                                } else if (L) {
                                    // If dragging don't allow vertical scroll.
                                    e.preventDefault();
                                    e.stopPropagation();
                                    return !1;
                                } else // Vertical scrolling.
                                I = !0;
                            }
                            if (L) {
                                // If dragging don't allow vertical scroll.
                                e.preventDefault();
                                e.stopPropagation();
                                return !1;
                            }
                        }
                        function v(e) {
                            if (T) T = !1; else return;
                            clearInterval(M);
                            P = x;
                            if (D > 10 || D < -10) {
                                A = .9 * D;
                                P = x + A;
                            }
                            P = Math.round(P / C) * C;
                            // No wrap of items.
                            if (z) if (P >= C * (k - 1)) P = C * (k - 1); else if (P < 0) P = 0;
                            A = P - x;
                            j = Date.now();
                            requestAnimationFrame(c);
                            if (L) {
                                e.preventDefault();
                                e.stopPropagation();
                            }
                            return !1;
                        }
                        var g, m, b, x, w, T, C, k, S, E, A, P, D, O, N, q, j, M, L, I;
                        var H = e('<ul class="indicators"></ul>');
                        var _ = null;
                        var F = null;
                        // Initialize
                        var R = e(this);
                        var W = R.find(".carousel-item").length > 1;
                        var $ = (R.attr("data-indicators") || t.indicators) && W;
                        var z = R.attr("data-no-wrap") || t.noWrap || !W;
                        var V = R.attr("data-namespace") || i + n;
                        R.attr("data-namespace", V);
                        // Options
                        var X = function(t) {
                            var n = R.find(".carousel-item.active").length ? R.find(".carousel-item.active").first() : R.find(".carousel-item").first();
                            var i = n.find("img").first();
                            if (i.length) if (i[0].complete) {
                                // If image won't trigger the load event
                                var r = i.height();
                                if (r > 0) R.css("height", i.height()); else {
                                    // If image still has no height, use the natural dimensions to calculate
                                    var o = i[0].naturalWidth;
                                    var a = i[0].naturalHeight;
                                    var s = R.width() / o * a;
                                    R.css("height", s);
                                }
                            } else // Get height when image is loaded normally
                            i.on("load", function() {
                                R.css("height", e(this).height());
                            }); else if (!t) {
                                var l = n.height();
                                R.css("height", l);
                            }
                        };
                        if (t.fullWidth) {
                            t.dist = 0;
                            X();
                            // Offset fixed items when indicators.
                            if ($) R.find(".carousel-fixed-item").addClass("with-indicators");
                        }
                        // Don't double initialize.
                        if (R.hasClass("initialized")) {
                            // Recalculate variables
                            e(window).trigger("resize");
                            // Redraw carousel.
                            R.trigger("carouselNext", [ 1e-6 ]);
                            return !0;
                        }
                        R.addClass("initialized");
                        T = !1;
                        x = P = 0;
                        g = [];
                        m = R.find(".carousel-item").first().innerWidth();
                        b = R.find(".carousel-item").first().innerHeight();
                        C = 2 * m + t.padding;
                        R.find(".carousel-item").each(function(t) {
                            g.push(e(this)[0]);
                            if ($) {
                                var n = e('<li class="indicator-item"></li>');
                                // Add active to first by default.
                                if (0 === t) n.addClass("active");
                                // Handle clicks on indicators.
                                n.click(function(t) {
                                    t.stopPropagation();
                                    d(e(this).index());
                                });
                                H.append(n);
                            }
                        });
                        if ($) R.append(H);
                        k = g.length;
                        N = "transform";
                        [ "webkit", "Moz", "O", "ms" ].every(function(e) {
                            var t = e + "Transform";
                            if ("undefined" !== typeof document.body.style[t]) {
                                N = t;
                                return !1;
                            }
                            return !0;
                        });
                        var B = Materialize.throttle(function() {
                            if (t.fullWidth) {
                                m = R.find(".carousel-item").first().innerWidth();
                                var e = R.find(".carousel-item.active").height();
                                C = 2 * m + t.padding;
                                x = 2 * w * m;
                                P = x;
                                X(!0);
                            } else l();
                        }, 200);
                        e(window).off("resize.carousel-" + V).on("resize.carousel-" + V, B);
                        r();
                        l(x);
                        e(this).on("carouselNext", function(e, t, n) {
                            if (t === undefined) t = 1;
                            if ("function" === typeof n) F = n;
                            P = C * Math.round(x / C) + C * t;
                            if (x !== P) {
                                A = P - x;
                                j = Date.now();
                                requestAnimationFrame(c);
                            }
                        });
                        e(this).on("carouselPrev", function(e, t, n) {
                            if (t === undefined) t = 1;
                            if ("function" === typeof n) F = n;
                            P = C * Math.round(x / C) - C * t;
                            if (x !== P) {
                                A = P - x;
                                j = Date.now();
                                requestAnimationFrame(c);
                            }
                        });
                        e(this).on("carouselSet", function(e, t, n) {
                            if (t === undefined) t = 0;
                            if ("function" === typeof n) F = n;
                            d(t);
                        });
                    });
                },
                next: function(t, n) {
                    e(this).trigger("carouselNext", [ t, n ]);
                },
                prev: function(t, n) {
                    e(this).trigger("carouselPrev", [ t, n ]);
                },
                set: function(t, n) {
                    e(this).trigger("carouselSet", [ t, n ]);
                },
                destroy: function() {
                    var t = e(this).attr("data-namespace");
                    e(this).removeAttr("data-namespace");
                    e(this).removeClass("initialized");
                    e(this).find(".indicators").remove();
                    // Remove event handlers
                    e(this).off("carouselNext carouselPrev carouselSet");
                    e(window).off("resize.carousel-" + t);
                    if ("undefined" !== typeof window.ontouchstart) e(this).off("touchstart.carousel touchmove.carousel touchend.carousel");
                    e(this).off("mousedown.carousel mousemove.carousel mouseup.carousel mouseleave.carousel click.carousel");
                }
            };
            e.fn.carousel = function(n) {
                if (t[n]) return t[n].apply(this, Array.prototype.slice.call(arguments, 1)); else if ("object" === typeof n || !n) // Default to "init"
                return t.init.apply(this, arguments); else e.error("Method " + n + " does not exist on jQuery.carousel");
            };
        }(l);
        !function(e) {
            var t = {
                init: function(t) {
                    return this.each(function() {
                        var n = e("#" + e(this).attr("data-activates"));
                        var i = e("body");
                        // Creating tap target
                        var r = e(this);
                        var o = r.parent(".tap-target-wrapper");
                        var a = o.find(".tap-target-wave");
                        var s = o.find(".tap-target-origin");
                        var l = r.find(".tap-target-content");
                        // Creating wrapper
                        if (!o.length) o = r.wrap(e('<div class="tap-target-wrapper"></div>')).parent();
                        // Creating content
                        if (!l.length) {
                            l = e('<div class="tap-target-content"></div>');
                            r.append(l);
                        }
                        // Creating foreground wave
                        if (!a.length) {
                            a = e('<div class="tap-target-wave"></div>');
                            // Creating origin
                            if (!s.length) {
                                s = n.clone(!0, !0);
                                s.addClass("tap-target-origin");
                                s.removeAttr("id");
                                s.removeAttr("style");
                                a.append(s);
                            }
                            o.append(a);
                        }
                        // Open
                        var u = function() {
                            if (o.is(".open")) return;
                            // Adding open class
                            o.addClass("open");
                            setTimeout(function() {
                                s.off("click.tapTarget").on("click.tapTarget", function(e) {
                                    c();
                                    s.off("click.tapTarget");
                                });
                                e(document).off("click.tapTarget").on("click.tapTarget", function(t) {
                                    c();
                                    e(document).off("click.tapTarget");
                                });
                                var t = Materialize.throttle(function() {
                                    f();
                                }, 200);
                                e(window).off("resize.tapTarget").on("resize.tapTarget", t);
                            }, 0);
                        };
                        // Close
                        var c = function() {
                            if (!o.is(".open")) return;
                            o.removeClass("open");
                            s.off("click.tapTarget");
                            e(document).off("click.tapTarget");
                            e(window).off("resize.tapTarget");
                        };
                        // Pre calculate
                        var f = function() {
                            // Element or parent is fixed position?
                            var t = "fixed" === n.css("position");
                            if (!t) {
                                var i = n.parents();
                                for (var s = 0; s < i.length; s++) {
                                    t = "fixed" == e(i[s]).css("position");
                                    if (t) break;
                                }
                            }
                            // Calculating origin
                            var u = n.outerWidth();
                            var c = n.outerHeight();
                            var f = t ? n.offset().top - e(document).scrollTop() : n.offset().top;
                            var d = t ? n.offset().left - e(document).scrollLeft() : n.offset().left;
                            // Calculating screen
                            var p = e(window).width();
                            var h = e(window).height();
                            var v = p / 2;
                            var g = h / 2;
                            var m = d <= v;
                            var y = d > v;
                            var b = f <= g;
                            var x = f > g;
                            var w = d >= .25 * p && d <= .75 * p;
                            var T = f >= .25 * h && f <= .75 * h;
                            // Calculating tap target
                            var C = r.outerWidth();
                            var k = r.outerHeight();
                            var S = f + c / 2 - k / 2;
                            var E = d + u / 2 - C / 2;
                            var A = t ? "fixed" : "absolute";
                            // Calculating content
                            var P = w ? C : C / 2 + u;
                            var D = k / 2;
                            var O = b ? k / 2 : 0;
                            var N = 0;
                            var q = m && !w ? C / 2 - u : 0;
                            var j = 0;
                            var M = u;
                            var L = x ? "bottom" : "top";
                            // Calculating wave
                            var I = u > c ? 2 * u : 2 * u;
                            var H = I;
                            var _ = k / 2 - H / 2;
                            var F = C / 2 - I / 2;
                            // Setting tap target
                            var R = {};
                            R.top = b ? S : "";
                            R.right = y ? p - E - C : "";
                            R.bottom = x ? h - S - k : "";
                            R.left = m ? E : "";
                            R.position = A;
                            o.css(R);
                            // Setting content
                            l.css({
                                width: P,
                                height: D,
                                top: O,
                                right: j,
                                bottom: N,
                                left: q,
                                padding: M,
                                verticalAlign: L
                            });
                            // Setting wave
                            a.css({
                                top: _,
                                left: F,
                                width: I,
                                height: H
                            });
                        };
                        if ("open" == t) {
                            f();
                            u();
                        }
                        if ("close" == t) c();
                    });
                },
                open: function() {},
                close: function() {}
            };
            e.fn.tapTarget = function(n) {
                if (t[n] || "object" === typeof n) return t.init.apply(this, arguments);
                e.error("Method " + n + " does not exist on jQuery.tap-target");
            };
        }(l);
    },
    /***/
    113: /***/
    function(e, t, n) {
        /* WEBPACK VAR INJECTION */
        (function(t) {
            e.exports = t.jQuery = n(114);
        }).call(t, n(23));
    },
    /***/
    114: /***/
    function(e, t, n) {
        var i, r;
        /*!
 * jQuery JavaScript Library v3.2.1
 * https://jquery.com/
 *
 * Includes Sizzle.js
 * https://sizzlejs.com/
 *
 * Copyright JS Foundation and other contributors
 * Released under the MIT license
 * https://jquery.org/license
 *
 * Date: 2017-03-20T18:59Z
 */
        !function(t, n) {
            "use strict";
            if ("object" === typeof e && "object" === typeof e.exports) // For CommonJS and CommonJS-like environments where a proper `window`
            // is present, execute the factory and get jQuery.
            // For environments that do not have a `window` with a `document`
            // (such as Node.js), expose a factory as module.exports.
            // This accentuates the need for the creation of a real `window`.
            // e.g. var jQuery = require("jquery")(window);
            // See ticket #14549 for more info.
            e.exports = t.document ? n(t, !0) : function(e) {
                if (!e.document) throw new Error("jQuery requires a window with a document");
                return n(e);
            }; else n(t);
        }("undefined" !== typeof window ? window : this, function(n, o) {
            // Edge <= 12 - 13+, Firefox <=18 - 45+, IE 10 - 11, Safari 5.1 - 9+, iOS 6 - 9.1
            // throw exceptions when non-strict code (e.g., ASP.NET 4.5) accesses strict mode
            // arguments.callee.caller (trac-13335). But as of jQuery 3.0 (2016), strict mode should be common
            // enough that all such attempts are guarded in a try block.
            "use strict";
            function a(e, t) {
                t = t || ae;
                var n = t.createElement("script");
                n.text = e;
                t.head.appendChild(n).parentNode.removeChild(n);
            }
            function s(e) {
                // Support: real iOS 8.2 only (not reproducible in simulator)
                // `in` check used to prevent JIT error (gh-2145)
                // hasOwn isn't used here due to false negatives
                // regarding Nodelist length in IE
                var t = !!e && "length" in e && e.length, n = be.type(e);
                if ("function" === n || be.isWindow(e)) return !1;
                return "array" === n || 0 === t || "number" === typeof t && t > 0 && t - 1 in e;
            }
            function l(e, t) {
                return e.nodeName && e.nodeName.toLowerCase() === t.toLowerCase();
            }
            // Implement the identical functionality for filter and not
            function u(e, t, n) {
                if (be.isFunction(t)) return be.grep(e, function(e, i) {
                    return !!t.call(e, i, e) !== n;
                });
                // Single element
                if (t.nodeType) return be.grep(e, function(e) {
                    return e === t !== n;
                });
                // Arraylike of elements (jQuery, arguments, Array)
                if ("string" !== typeof t) return be.grep(e, function(e) {
                    return fe.call(t, e) > -1 !== n;
                });
                // Simple selector that can be filtered directly, removing non-Elements
                if (De.test(t)) return be.filter(t, e, n);
                // Complex selector, compare the two sets, removing non-Elements
                t = be.filter(t, e);
                return be.grep(e, function(e) {
                    return fe.call(t, e) > -1 !== n && 1 === e.nodeType;
                });
            }
            function c(e, t) {
                for (;(e = e[t]) && 1 !== e.nodeType; ) ;
                return e;
            }
            // Convert String-formatted options into Object-formatted ones
            function f(e) {
                var t = {};
                be.each(e.match(Me) || [], function(e, n) {
                    t[n] = !0;
                });
                return t;
            }
            function d(e) {
                return e;
            }
            function p(e) {
                throw e;
            }
            function h(e, t, n, i) {
                var r;
                try {
                    // Check for promise aspect first to privilege synchronous behavior
                    if (e && be.isFunction(r = e.promise)) r.call(e).done(t).fail(n); else if (e && be.isFunction(r = e.then)) r.call(e, t, n); else // Control `resolve` arguments by letting Array#slice cast boolean `noValue` to integer:
                    // * false: [ value ].slice( 0 ) => resolve( value )
                    // * true: [ value ].slice( 1 ) => resolve()
                    t.apply(undefined, [ e ].slice(i));
                } catch (e) {
                    // Support: Android 4.0 only
                    // Strict mode functions invoked without .call/.apply get global-object context
                    n.apply(undefined, [ e ]);
                }
            }
            // The ready event handler and self cleanup method
            function v() {
                ae.removeEventListener("DOMContentLoaded", v);
                n.removeEventListener("load", v);
                be.ready();
            }
            function g() {
                this.expando = be.expando + g.uid++;
            }
            function m(e) {
                if ("true" === e) return !0;
                if ("false" === e) return !1;
                if ("null" === e) return null;
                // Only convert to a number if it doesn't change the string
                if (e === +e + "") return +e;
                if (We.test(e)) return JSON.parse(e);
                return e;
            }
            function y(e, t, n) {
                var i;
                // If nothing was found internally, try to fetch any
                // data from the HTML5 data-* attribute
                if (n === undefined && 1 === e.nodeType) {
                    i = "data-" + t.replace($e, "-$&").toLowerCase();
                    n = e.getAttribute(i);
                    if ("string" === typeof n) {
                        try {
                            n = m(n);
                        } catch (r) {}
                        // Make sure we set the data so it isn't changed later
                        Re.set(e, t, n);
                    } else n = undefined;
                }
                return n;
            }
            function b(e, t, n, i) {
                var r, o = 1, a = 20, s = i ? function() {
                    return i.cur();
                } : function() {
                    return be.css(e, t, "");
                }, l = s(), u = n && n[3] || (be.cssNumber[t] ? "" : "px"), // Starting value computation is required for potential unit mismatches
                c = (be.cssNumber[t] || "px" !== u && +l) && Ve.exec(be.css(e, t));
                if (c && c[3] !== u) {
                    // Trust units reported by jQuery.css
                    u = u || c[3];
                    // Make sure we update the tween properties later on
                    n = n || [];
                    // Iteratively approximate from a nonzero starting point
                    c = +l || 1;
                    do {
                        // If previous iteration zeroed out, double until we get *something*.
                        // Use string for doubling so we don't accidentally see scale as unchanged below
                        o = o || ".5";
                        // Adjust and apply
                        c /= o;
                        be.style(e, t, c + u);
                    } while (o !== (o = s() / l) && 1 !== o && --a);
                }
                if (n) {
                    c = +c || +l || 0;
                    // Apply relative offset (+=/-=) if specified
                    r = n[1] ? c + (n[1] + 1) * n[2] : +n[2];
                    if (i) {
                        i.unit = u;
                        i.start = c;
                        i.end = r;
                    }
                }
                return r;
            }
            function x(e) {
                var t, n = e.ownerDocument, i = e.nodeName, r = Qe[i];
                if (r) return r;
                t = n.body.appendChild(n.createElement(i));
                r = be.css(t, "display");
                t.parentNode.removeChild(t);
                if ("none" === r) r = "block";
                Qe[i] = r;
                return r;
            }
            function w(e, t) {
                var n, i, r = [], o = 0, a = e.length;
                // Determine new display value for elements that need to change
                for (;o < a; o++) {
                    i = e[o];
                    if (!i.style) continue;
                    n = i.style.display;
                    if (t) {
                        // Since we force visibility upon cascade-hidden elements, an immediate (and slow)
                        // check is required in this first loop unless we have a nonempty display value (either
                        // inline or about-to-be-restored)
                        if ("none" === n) {
                            r[o] = Fe.get(i, "display") || null;
                            if (!r[o]) i.style.display = "";
                        }
                        if ("" === i.style.display && Be(i)) r[o] = x(i);
                    } else if ("none" !== n) {
                        r[o] = "none";
                        // Remember what we're overwriting
                        Fe.set(i, "display", n);
                    }
                }
                // Set the display of the elements in a second loop to avoid constant reflow
                for (o = 0; o < a; o++) if (null != r[o]) e[o].style.display = r[o];
                return e;
            }
            function T(e, t) {
                // Support: IE <=9 - 11 only
                // Use typeof to avoid zero-argument method invocation on host objects (#15151)
                var n;
                if ("undefined" !== typeof e.getElementsByTagName) n = e.getElementsByTagName(t || "*"); else if ("undefined" !== typeof e.querySelectorAll) n = e.querySelectorAll(t || "*"); else n = [];
                if (t === undefined || t && l(e, t)) return be.merge([ e ], n);
                return n;
            }
            // Mark scripts as having already been evaluated
            function C(e, t) {
                var n = 0, i = e.length;
                for (;n < i; n++) Fe.set(e[n], "globalEval", !t || Fe.get(t[n], "globalEval"));
            }
            function k(e, t, n, i, r) {
                var o, a, s, l, u, c, f = t.createDocumentFragment(), d = [], p = 0, h = e.length;
                for (;p < h; p++) {
                    o = e[p];
                    if (o || 0 === o) // Add nodes directly
                    if ("object" === be.type(o)) // Support: Android <=4.0 only, PhantomJS 1 only
                    // push.apply(_, arraylike) throws on ancient WebKit
                    be.merge(d, o.nodeType ? [ o ] : o); else if (!Ke.test(o)) d.push(t.createTextNode(o)); else {
                        a = a || f.appendChild(t.createElement("div"));
                        // Deserialize a standard representation
                        s = (Ge.exec(o) || [ "", "" ])[1].toLowerCase();
                        l = Je[s] || Je._default;
                        a.innerHTML = l[1] + be.htmlPrefilter(o) + l[2];
                        // Descend through wrappers to the right content
                        c = l[0];
                        for (;c--; ) a = a.lastChild;
                        // Support: Android <=4.0 only, PhantomJS 1 only
                        // push.apply(_, arraylike) throws on ancient WebKit
                        be.merge(d, a.childNodes);
                        // Remember the top-level container
                        a = f.firstChild;
                        // Ensure the created nodes are orphaned (#12392)
                        a.textContent = "";
                    }
                }
                // Remove wrapper from fragment
                f.textContent = "";
                p = 0;
                for (;o = d[p++]; ) {
                    // Skip elements already in the context collection (trac-4087)
                    if (i && be.inArray(o, i) > -1) {
                        if (r) r.push(o);
                        continue;
                    }
                    u = be.contains(o.ownerDocument, o);
                    // Append to fragment
                    a = T(f.appendChild(o), "script");
                    // Preserve script evaluation history
                    if (u) C(a);
                    // Capture executables
                    if (n) {
                        c = 0;
                        for (;o = a[c++]; ) if (Ze.test(o.type || "")) n.push(o);
                    }
                }
                return f;
            }
            function S() {
                return !0;
            }
            function E() {
                return !1;
            }
            // Support: IE <=9 only
            // See #13393 for more info
            function A() {
                try {
                    return ae.activeElement;
                } catch (e) {}
            }
            function P(e, t, n, i, r, o) {
                var a, s;
                // Types can be a map of types/handlers
                if ("object" === typeof t) {
                    // ( types-Object, selector, data )
                    if ("string" !== typeof n) {
                        // ( types-Object, data )
                        i = i || n;
                        n = undefined;
                    }
                    for (s in t) P(e, s, n, i, t[s], o);
                    return e;
                }
                if (null == i && null == r) {
                    // ( types, fn )
                    r = n;
                    i = n = undefined;
                } else if (null == r) if ("string" === typeof n) {
                    // ( types, selector, fn )
                    r = i;
                    i = undefined;
                } else {
                    // ( types, data, fn )
                    r = i;
                    i = n;
                    n = undefined;
                }
                if (!1 === r) r = E; else if (!r) return e;
                if (1 === o) {
                    a = r;
                    r = function(e) {
                        // Can use an empty set, since event contains the info
                        be().off(e);
                        return a.apply(this, arguments);
                    };
                    // Use same guid so caller can remove using origFn
                    r.guid = a.guid || (a.guid = be.guid++);
                }
                return e.each(function() {
                    be.event.add(this, t, r, i, n);
                });
            }
            // Prefer a tbody over its parent table for containing new rows
            function D(e, t) {
                if (l(e, "table") && l(11 !== t.nodeType ? t : t.firstChild, "tr")) return be(">tbody", e)[0] || e;
                return e;
            }
            // Replace/restore the type attribute of script elements for safe DOM manipulation
            function O(e) {
                e.type = (null !== e.getAttribute("type")) + "/" + e.type;
                return e;
            }
            function N(e) {
                var t = st.exec(e.type);
                if (t) e.type = t[1]; else e.removeAttribute("type");
                return e;
            }
            function q(e, t) {
                var n, i, r, o, a, s, l, u;
                if (1 !== t.nodeType) return;
                // 1. Copy private data: events, handlers, etc.
                if (Fe.hasData(e)) {
                    o = Fe.access(e);
                    a = Fe.set(t, o);
                    u = o.events;
                    if (u) {
                        delete a.handle;
                        a.events = {};
                        for (r in u) for (n = 0, i = u[r].length; n < i; n++) be.event.add(t, r, u[r][n]);
                    }
                }
                // 2. Copy user data
                if (Re.hasData(e)) {
                    s = Re.access(e);
                    l = be.extend({}, s);
                    Re.set(t, l);
                }
            }
            // Fix IE bugs, see support tests
            function j(e, t) {
                var n = t.nodeName.toLowerCase();
                // Fails to persist the checked state of a cloned checkbox or radio button.
                if ("input" === n && Ue.test(e.type)) t.checked = e.checked; else if ("input" === n || "textarea" === n) t.defaultValue = e.defaultValue;
            }
            function M(e, t, n, i) {
                // Flatten any nested arrays
                t = ue.apply([], t);
                var r, o, s, l, u, c, f = 0, d = e.length, p = d - 1, h = t[0], v = be.isFunction(h);
                // We can't cloneNode fragments that contain checked, in WebKit
                if (v || d > 1 && "string" === typeof h && !me.checkClone && at.test(h)) return e.each(function(r) {
                    var o = e.eq(r);
                    if (v) t[0] = h.call(this, r, o.html());
                    M(o, t, n, i);
                });
                if (d) {
                    r = k(t, e[0].ownerDocument, !1, e, i);
                    o = r.firstChild;
                    if (1 === r.childNodes.length) r = o;
                    // Require either new content or an interest in ignored elements to invoke the callback
                    if (o || i) {
                        s = be.map(T(r, "script"), O);
                        l = s.length;
                        // Use the original fragment for the last item
                        // instead of the first because it can end up
                        // being emptied incorrectly in certain situations (#8070).
                        for (;f < d; f++) {
                            u = r;
                            if (f !== p) {
                                u = be.clone(u, !0, !0);
                                // Keep references to cloned scripts for later restoration
                                if (l) // Support: Android <=4.0 only, PhantomJS 1 only
                                // push.apply(_, arraylike) throws on ancient WebKit
                                be.merge(s, T(u, "script"));
                            }
                            n.call(e[f], u, f);
                        }
                        if (l) {
                            c = s[s.length - 1].ownerDocument;
                            // Reenable scripts
                            be.map(s, N);
                            // Evaluate executable scripts on first document insertion
                            for (f = 0; f < l; f++) {
                                u = s[f];
                                if (Ze.test(u.type || "") && !Fe.access(u, "globalEval") && be.contains(c, u)) if (u.src) {
                                    // Optional AJAX dependency, but won't run scripts if not present
                                    if (be._evalUrl) be._evalUrl(u.src);
                                } else a(u.textContent.replace(lt, ""), c);
                            }
                        }
                    }
                }
                return e;
            }
            function L(e, t, n) {
                var i, r = t ? be.filter(t, e) : e, o = 0;
                for (;null != (i = r[o]); o++) {
                    if (!n && 1 === i.nodeType) be.cleanData(T(i));
                    if (i.parentNode) {
                        if (n && be.contains(i.ownerDocument, i)) C(T(i, "script"));
                        i.parentNode.removeChild(i);
                    }
                }
                return e;
            }
            function I(e, t, n) {
                var i, r, o, a, // Support: Firefox 51+
                // Retrieving style before computed somehow
                // fixes an issue with getting wrong values
                // on detached elements
                s = e.style;
                n = n || ft(e);
                // getPropertyValue is needed for:
                //   .css('filter') (IE 9 only, #12537)
                //   .css('--customProperty) (#3144)
                if (n) {
                    a = n.getPropertyValue(t) || n[t];
                    if ("" === a && !be.contains(e.ownerDocument, e)) a = be.style(e, t);
                    // A tribute to the "awesome hack by Dean Edwards"
                    // Android Browser returns percentage for some values,
                    // but width seems to be reliably pixels.
                    // This is against the CSSOM draft spec:
                    // https://drafts.csswg.org/cssom/#resolved-values
                    if (!me.pixelMarginRight() && ct.test(a) && ut.test(t)) {
                        // Remember the original values
                        i = s.width;
                        r = s.minWidth;
                        o = s.maxWidth;
                        // Put in the new values to get a computed value out
                        s.minWidth = s.maxWidth = s.width = a;
                        a = n.width;
                        // Revert the changed values
                        s.width = i;
                        s.minWidth = r;
                        s.maxWidth = o;
                    }
                }
                // Support: IE <=9 - 11 only
                // IE returns zIndex value as an integer.
                return a !== undefined ? a + "" : a;
            }
            function H(e, t) {
                // Define the hook, we'll check on the first run if it's really needed.
                return {
                    get: function() {
                        if (e()) {
                            // Hook not needed (or it's not possible to use it due
                            // to missing dependency), remove it.
                            delete this.get;
                            return;
                        }
                        // Hook needed; redefine it so that the support test is not executed again.
                        return (this.get = t).apply(this, arguments);
                    }
                };
            }
            // Return a css property mapped to a potentially vendor prefixed property
            function _(e) {
                // Shortcut for names that are not vendor prefixed
                if (e in mt) return e;
                // Check for vendor prefixed names
                var t = e[0].toUpperCase() + e.slice(1), n = gt.length;
                for (;n--; ) {
                    e = gt[n] + t;
                    if (e in mt) return e;
                }
            }
            // Return a property mapped along what jQuery.cssProps suggests or to
            // a vendor prefixed property.
            function F(e) {
                var t = be.cssProps[e];
                if (!t) t = be.cssProps[e] = _(e) || e;
                return t;
            }
            function R(e, t, n) {
                // Any relative (+/-) values have already been
                // normalized at this point
                var i = Ve.exec(t);
                // Guard against undefined "subtract", e.g., when used as in cssHooks
                return i ? Math.max(0, i[2] - (n || 0)) + (i[3] || "px") : t;
            }
            function W(e, t, n, i, r) {
                var o, a = 0;
                // If we already have the right measurement, avoid augmentation
                if (n === (i ? "border" : "content")) o = 4; else o = "width" === t ? 1 : 0;
                for (;o < 4; o += 2) {
                    // Both box models exclude margin, so add it if we want it
                    if ("margin" === n) a += be.css(e, n + Xe[o], !0, r);
                    if (i) {
                        // border-box includes padding, so remove it if we want content
                        if ("content" === n) a -= be.css(e, "padding" + Xe[o], !0, r);
                        // At this point, extra isn't border nor margin, so remove border
                        if ("margin" !== n) a -= be.css(e, "border" + Xe[o] + "Width", !0, r);
                    } else {
                        // At this point, extra isn't content, so add padding
                        a += be.css(e, "padding" + Xe[o], !0, r);
                        // At this point, extra isn't content nor padding, so add border
                        if ("padding" !== n) a += be.css(e, "border" + Xe[o] + "Width", !0, r);
                    }
                }
                return a;
            }
            function $(e, t, n) {
                // Start with computed style
                var i, r = ft(e), o = I(e, t, r), a = "border-box" === be.css(e, "boxSizing", !1, r);
                // Computed unit is not pixels. Stop here and return.
                if (ct.test(o)) return o;
                // Check for style in case a browser which returns unreliable values
                // for getComputedStyle silently falls back to the reliable elem.style
                i = a && (me.boxSizingReliable() || o === e.style[t]);
                // Fall back to offsetWidth/Height when value is "auto"
                // This happens for inline elements with no explicit setting (gh-3571)
                if ("auto" === o) o = e["offset" + t[0].toUpperCase() + t.slice(1)];
                // Normalize "", auto, and prepare for extra
                o = parseFloat(o) || 0;
                // Use the active box-sizing model to add/subtract irrelevant styles
                return o + W(e, t, n || (a ? "border" : "content"), i, r) + "px";
            }
            function z(e, t, n, i, r) {
                return new z.prototype.init(e, t, n, i, r);
            }
            function V() {
                if (bt) {
                    if (!1 === ae.hidden && n.requestAnimationFrame) n.requestAnimationFrame(V); else n.setTimeout(V, be.fx.interval);
                    be.fx.tick();
                }
            }
            // Animations created synchronously will run synchronously
            function X() {
                n.setTimeout(function() {
                    yt = undefined;
                });
                return yt = be.now();
            }
            // Generate parameters to create a standard animation
            function B(e, t) {
                var n, i = 0, r = {
                    height: e
                };
                // If we include width, step value is 1 to do all cssExpand values,
                // otherwise step value is 2 to skip over Left and Right
                t = t ? 1 : 0;
                for (;i < 4; i += 2 - t) {
                    n = Xe[i];
                    r["margin" + n] = r["padding" + n] = e;
                }
                if (t) r.opacity = r.width = e;
                return r;
            }
            function Y(e, t, n) {
                var i, r = (G.tweeners[t] || []).concat(G.tweeners["*"]), o = 0, a = r.length;
                for (;o < a; o++) if (i = r[o].call(n, t, e)) // We're done with this property
                return i;
            }
            function Q(e, t, n) {
                var i, r, o, a, s, l, u, c, f = "width" in t || "height" in t, d = this, p = {}, h = e.style, v = e.nodeType && Be(e), g = Fe.get(e, "fxshow");
                // Queue-skipping animations hijack the fx hooks
                if (!n.queue) {
                    a = be._queueHooks(e, "fx");
                    if (null == a.unqueued) {
                        a.unqueued = 0;
                        s = a.empty.fire;
                        a.empty.fire = function() {
                            if (!a.unqueued) s();
                        };
                    }
                    a.unqueued++;
                    d.always(function() {
                        // Ensure the complete handler is called before this completes
                        d.always(function() {
                            a.unqueued--;
                            if (!be.queue(e, "fx").length) a.empty.fire();
                        });
                    });
                }
                // Detect show/hide animations
                for (i in t) {
                    r = t[i];
                    if (xt.test(r)) {
                        delete t[i];
                        o = o || "toggle" === r;
                        if (r === (v ? "hide" : "show")) // Pretend to be hidden if this is a "show" and
                        // there is still data from a stopped show/hide
                        if ("show" === r && g && g[i] !== undefined) v = !0; else continue;
                        p[i] = g && g[i] || be.style(e, i);
                    }
                }
                // Bail out if this is a no-op like .hide().hide()
                l = !be.isEmptyObject(t);
                if (!l && be.isEmptyObject(p)) return;
                // Restrict "overflow" and "display" styles during box animations
                if (f && 1 === e.nodeType) {
                    // Support: IE <=9 - 11, Edge 12 - 13
                    // Record all 3 overflow attributes because IE does not infer the shorthand
                    // from identically-valued overflowX and overflowY
                    n.overflow = [ h.overflow, h.overflowX, h.overflowY ];
                    // Identify a display type, preferring old show/hide data over the CSS cascade
                    u = g && g.display;
                    if (null == u) u = Fe.get(e, "display");
                    c = be.css(e, "display");
                    if ("none" === c) if (u) c = u; else {
                        // Get nonempty value(s) by temporarily forcing visibility
                        w([ e ], !0);
                        u = e.style.display || u;
                        c = be.css(e, "display");
                        w([ e ]);
                    }
                    // Animate inline elements as inline-block
                    if ("inline" === c || "inline-block" === c && null != u) if ("none" === be.css(e, "float")) {
                        // Restore the original display value at the end of pure show/hide animations
                        if (!l) {
                            d.done(function() {
                                h.display = u;
                            });
                            if (null == u) {
                                c = h.display;
                                u = "none" === c ? "" : c;
                            }
                        }
                        h.display = "inline-block";
                    }
                }
                if (n.overflow) {
                    h.overflow = "hidden";
                    d.always(function() {
                        h.overflow = n.overflow[0];
                        h.overflowX = n.overflow[1];
                        h.overflowY = n.overflow[2];
                    });
                }
                // Implement show/hide animations
                l = !1;
                for (i in p) {
                    // General show/hide setup for this element animation
                    if (!l) {
                        if (g) {
                            if ("hidden" in g) v = g.hidden;
                        } else g = Fe.access(e, "fxshow", {
                            display: u
                        });
                        // Store hidden/visible for toggle so `.stop().toggle()` "reverses"
                        if (o) g.hidden = !v;
                        // Show elements before animating them
                        if (v) w([ e ], !0);
                        /* eslint-disable no-loop-func */
                        d.done(function() {
                            /* eslint-enable no-loop-func */
                            // The final step of a "hide" animation is actually hiding the element
                            if (!v) w([ e ]);
                            Fe.remove(e, "fxshow");
                            for (i in p) be.style(e, i, p[i]);
                        });
                    }
                    // Per-property setup
                    l = Y(v ? g[i] : 0, i, d);
                    if (!(i in g)) {
                        g[i] = l.start;
                        if (v) {
                            l.end = l.start;
                            l.start = 0;
                        }
                    }
                }
            }
            function U(e, t) {
                var n, i, r, o, a;
                // camelCase, specialEasing and expand cssHook pass
                for (n in e) {
                    i = be.camelCase(n);
                    r = t[i];
                    o = e[n];
                    if (Array.isArray(o)) {
                        r = o[1];
                        o = e[n] = o[0];
                    }
                    if (n !== i) {
                        e[i] = o;
                        delete e[n];
                    }
                    a = be.cssHooks[i];
                    if (a && "expand" in a) {
                        o = a.expand(o);
                        delete e[i];
                        // Not quite $.extend, this won't overwrite existing keys.
                        // Reusing 'index' because we have the correct "name"
                        for (n in o) if (!(n in e)) {
                            e[n] = o[n];
                            t[n] = r;
                        }
                    } else t[i] = r;
                }
            }
            function G(e, t, n) {
                var i, r, o = 0, a = G.prefilters.length, s = be.Deferred().always(function() {
                    // Don't match elem in the :animated selector
                    delete l.elem;
                }), l = function() {
                    if (r) return !1;
                    var t = yt || X(), n = Math.max(0, u.startTime + u.duration - t), // Support: Android 2.3 only
                    // Archaic crash bug won't allow us to use `1 - ( 0.5 || 0 )` (#12497)
                    i = n / u.duration || 0, o = 1 - i, a = 0, l = u.tweens.length;
                    for (;a < l; a++) u.tweens[a].run(o);
                    s.notifyWith(e, [ u, o, n ]);
                    // If there's more to do, yield
                    if (o < 1 && l) return n;
                    // If this was an empty animation, synthesize a final progress notification
                    if (!l) s.notifyWith(e, [ u, 1, 0 ]);
                    // Resolve the animation and report its conclusion
                    s.resolveWith(e, [ u ]);
                    return !1;
                }, u = s.promise({
                    elem: e,
                    props: be.extend({}, t),
                    opts: be.extend(!0, {
                        specialEasing: {},
                        easing: be.easing._default
                    }, n),
                    originalProperties: t,
                    originalOptions: n,
                    startTime: yt || X(),
                    duration: n.duration,
                    tweens: [],
                    createTween: function(t, n) {
                        var i = be.Tween(e, u.opts, t, n, u.opts.specialEasing[t] || u.opts.easing);
                        u.tweens.push(i);
                        return i;
                    },
                    stop: function(t) {
                        var n = 0, // If we are going to the end, we want to run all the tweens
                        // otherwise we skip this part
                        i = t ? u.tweens.length : 0;
                        if (r) return this;
                        r = !0;
                        for (;n < i; n++) u.tweens[n].run(1);
                        // Resolve when we played the last frame; otherwise, reject
                        if (t) {
                            s.notifyWith(e, [ u, 1, 0 ]);
                            s.resolveWith(e, [ u, t ]);
                        } else s.rejectWith(e, [ u, t ]);
                        return this;
                    }
                }), c = u.props;
                U(c, u.opts.specialEasing);
                for (;o < a; o++) {
                    i = G.prefilters[o].call(u, e, c, u.opts);
                    if (i) {
                        if (be.isFunction(i.stop)) be._queueHooks(u.elem, u.opts.queue).stop = be.proxy(i.stop, i);
                        return i;
                    }
                }
                be.map(c, Y, u);
                if (be.isFunction(u.opts.start)) u.opts.start.call(e, u);
                // Attach callbacks from options
                u.progress(u.opts.progress).done(u.opts.done, u.opts.complete).fail(u.opts.fail).always(u.opts.always);
                be.fx.timer(be.extend(l, {
                    elem: e,
                    anim: u,
                    queue: u.opts.queue
                }));
                return u;
            }
            // Strip and collapse whitespace according to HTML spec
            // https://html.spec.whatwg.org/multipage/infrastructure.html#strip-and-collapse-whitespace
            function Z(e) {
                return (e.match(Me) || []).join(" ");
            }
            function J(e) {
                return e.getAttribute && e.getAttribute("class") || "";
            }
            function K(e, t, n, i) {
                var r;
                if (Array.isArray(t)) // Serialize array item.
                be.each(t, function(t, r) {
                    if (n || Nt.test(e)) // Treat each array item as a scalar.
                    i(e, r); else // Item is non-scalar (array or object), encode its numeric index.
                    K(e + "[" + ("object" === typeof r && null != r ? t : "") + "]", r, n, i);
                }); else if (!n && "object" === be.type(t)) // Serialize object item.
                for (r in t) K(e + "[" + r + "]", t[r], n, i); else // Serialize scalar item.
                i(e, t);
            }
            // Base "constructor" for jQuery.ajaxPrefilter and jQuery.ajaxTransport
            function ee(e) {
                // dataTypeExpression is optional and defaults to "*"
                return function(t, n) {
                    if ("string" !== typeof t) {
                        n = t;
                        t = "*";
                    }
                    var i, r = 0, o = t.toLowerCase().match(Me) || [];
                    if (be.isFunction(n)) // For each dataType in the dataTypeExpression
                    for (;i = o[r++]; ) // Prepend if requested
                    if ("+" === i[0]) {
                        i = i.slice(1) || "*";
                        (e[i] = e[i] || []).unshift(n);
                    } else (e[i] = e[i] || []).push(n);
                };
            }
            // Base inspection function for prefilters and transports
            function te(e, t, n, i) {
                function r(s) {
                    var l;
                    o[s] = !0;
                    be.each(e[s] || [], function(e, s) {
                        var u = s(t, n, i);
                        if ("string" === typeof u && !a && !o[u]) {
                            t.dataTypes.unshift(u);
                            r(u);
                            return !1;
                        } else if (a) return !(l = u);
                    });
                    return l;
                }
                var o = {}, a = e === zt;
                return r(t.dataTypes[0]) || !o["*"] && r("*");
            }
            // A special extend for ajax options
            // that takes "flat" options (not to be deep extended)
            // Fixes #9887
            function ne(e, t) {
                var n, i, r = be.ajaxSettings.flatOptions || {};
                for (n in t) if (t[n] !== undefined) (r[n] ? e : i || (i = {}))[n] = t[n];
                if (i) be.extend(!0, e, i);
                return e;
            }
            /* Handles responses to an ajax request:
 * - finds the right dataType (mediates between content-type and expected dataType)
 * - returns the corresponding response
 */
            function ie(e, t, n) {
                var i, r, o, a, s = e.contents, l = e.dataTypes;
                // Remove auto dataType and get content-type in the process
                for (;"*" === l[0]; ) {
                    l.shift();
                    if (i === undefined) i = e.mimeType || t.getResponseHeader("Content-Type");
                }
                // Check if we're dealing with a known content-type
                if (i) for (r in s) if (s[r] && s[r].test(i)) {
                    l.unshift(r);
                    break;
                }
                // Check to see if we have a response for the expected dataType
                if (l[0] in n) o = l[0]; else {
                    // Try convertible dataTypes
                    for (r in n) {
                        if (!l[0] || e.converters[r + " " + l[0]]) {
                            o = r;
                            break;
                        }
                        if (!a) a = r;
                    }
                    // Or just use first one
                    o = o || a;
                }
                // If we found a dataType
                // We add the dataType to the list if needed
                // and return the corresponding response
                if (o) {
                    if (o !== l[0]) l.unshift(o);
                    return n[o];
                }
            }
            /* Chain conversions given the request and the original response
 * Also sets the responseXXX fields on the jqXHR instance
 */
            function re(e, t, n, i) {
                var r, o, a, s, l, u = {}, // Work with a copy of dataTypes in case we need to modify it for conversion
                c = e.dataTypes.slice();
                // Create converters map with lowercased keys
                if (c[1]) for (a in e.converters) u[a.toLowerCase()] = e.converters[a];
                o = c.shift();
                // Convert to each sequential dataType
                for (;o; ) {
                    if (e.responseFields[o]) n[e.responseFields[o]] = t;
                    // Apply the dataFilter if provided
                    if (!l && i && e.dataFilter) t = e.dataFilter(t, e.dataType);
                    l = o;
                    o = c.shift();
                    if (o) // There's only work to do if current dataType is non-auto
                    if ("*" === o) o = l; else if ("*" !== l && l !== o) {
                        // Seek a direct converter
                        a = u[l + " " + o] || u["* " + o];
                        // If none found, seek a pair
                        if (!a) for (r in u) {
                            // If conv2 outputs current
                            s = r.split(" ");
                            if (s[1] === o) {
                                // If prev can be converted to accepted input
                                a = u[l + " " + s[0]] || u["* " + s[0]];
                                if (a) {
                                    // Condense equivalence converters
                                    if (!0 === a) a = u[r]; else if (!0 !== u[r]) {
                                        o = s[0];
                                        c.unshift(s[1]);
                                    }
                                    break;
                                }
                            }
                        }
                        // Apply converter (if not an equivalence)
                        if (!0 !== a) // Unless errors are allowed to bubble, catch and return them
                        if (a && e["throws"]) t = a(t); else try {
                            t = a(t);
                        } catch (f) {
                            return {
                                state: "parsererror",
                                error: a ? f : "No conversion from " + l + " to " + o
                            };
                        }
                    }
                }
                return {
                    state: "success",
                    data: t
                };
            }
            var oe = [];
            var ae = n.document;
            var se = Object.getPrototypeOf;
            var le = oe.slice;
            var ue = oe.concat;
            var ce = oe.push;
            var fe = oe.indexOf;
            var de = {};
            var pe = de.toString;
            var he = de.hasOwnProperty;
            var ve = he.toString;
            var ge = ve.call(Object);
            var me = {};
            /* global Symbol */
            // Defining this global in .eslintrc.json would create a danger of using the global
            // unguarded in another place, it seems safer to define global only for this module
            var ye = "3.2.1", // Define a local copy of jQuery
            be = function(e, t) {
                // The jQuery object is actually just the init constructor 'enhanced'
                // Need init if jQuery is called (just allow error to be thrown if not included)
                return new be.fn.init(e, t);
            }, // Support: Android <=4.0 only
            // Make sure we trim BOM and NBSP
            xe = /^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, // Matches dashed string for camelizing
            we = /^-ms-/, Te = /-([a-z])/g, // Used by jQuery.camelCase as callback to replace()
            Ce = function(e, t) {
                return t.toUpperCase();
            };
            be.fn = be.prototype = {
                // The current version of jQuery being used
                jquery: ye,
                constructor: be,
                // The default length of a jQuery object is 0
                length: 0,
                toArray: function() {
                    return le.call(this);
                },
                // Get the Nth element in the matched element set OR
                // Get the whole matched element set as a clean array
                get: function(e) {
                    // Return all the elements in a clean array
                    if (null == e) return le.call(this);
                    // Return just the one element from the set
                    return e < 0 ? this[e + this.length] : this[e];
                },
                // Take an array of elements and push it onto the stack
                // (returning the new matched element set)
                pushStack: function(e) {
                    // Build a new jQuery matched element set
                    var t = be.merge(this.constructor(), e);
                    // Add the old object onto the stack (as a reference)
                    t.prevObject = this;
                    // Return the newly-formed element set
                    return t;
                },
                // Execute a callback for every element in the matched set.
                each: function(e) {
                    return be.each(this, e);
                },
                map: function(e) {
                    return this.pushStack(be.map(this, function(t, n) {
                        return e.call(t, n, t);
                    }));
                },
                slice: function() {
                    return this.pushStack(le.apply(this, arguments));
                },
                first: function() {
                    return this.eq(0);
                },
                last: function() {
                    return this.eq(-1);
                },
                eq: function(e) {
                    var t = this.length, n = +e + (e < 0 ? t : 0);
                    return this.pushStack(n >= 0 && n < t ? [ this[n] ] : []);
                },
                end: function() {
                    return this.prevObject || this.constructor();
                },
                // For internal use only.
                // Behaves like an Array's method, not like a jQuery method.
                push: ce,
                sort: oe.sort,
                splice: oe.splice
            };
            be.extend = be.fn.extend = function() {
                var e, t, n, i, r, o, a = arguments[0] || {}, s = 1, l = arguments.length, u = !1;
                // Handle a deep copy situation
                if ("boolean" === typeof a) {
                    u = a;
                    // Skip the boolean and the target
                    a = arguments[s] || {};
                    s++;
                }
                // Handle case when target is a string or something (possible in deep copy)
                if ("object" !== typeof a && !be.isFunction(a)) a = {};
                // Extend jQuery itself if only one argument is passed
                if (s === l) {
                    a = this;
                    s--;
                }
                for (;s < l; s++) // Only deal with non-null/undefined values
                if (null != (e = arguments[s])) // Extend the base object
                for (t in e) {
                    n = a[t];
                    i = e[t];
                    // Prevent never-ending loop
                    if (a === i) continue;
                    // Recurse if we're merging plain objects or arrays
                    if (u && i && (be.isPlainObject(i) || (r = Array.isArray(i)))) {
                        if (r) {
                            r = !1;
                            o = n && Array.isArray(n) ? n : [];
                        } else o = n && be.isPlainObject(n) ? n : {};
                        // Never move original objects, clone them
                        a[t] = be.extend(u, o, i);
                    } else if (i !== undefined) a[t] = i;
                }
                // Return the modified object
                return a;
            };
            be.extend({
                // Unique for each copy of jQuery on the page
                expando: "jQuery" + (ye + Math.random()).replace(/\D/g, ""),
                // Assume jQuery is ready without the ready module
                isReady: !0,
                error: function(e) {
                    throw new Error(e);
                },
                noop: function() {},
                isFunction: function(e) {
                    return "function" === be.type(e);
                },
                isWindow: function(e) {
                    return null != e && e === e.window;
                },
                isNumeric: function(e) {
                    // As of jQuery 3.0, isNumeric is limited to
                    // strings and numbers (primitives or objects)
                    // that can be coerced to finite numbers (gh-2662)
                    var t = be.type(e);
                    // parseFloat NaNs numeric-cast false positives ("")
                    // ...but misinterprets leading-number strings, particularly hex literals ("0x...")
                    // subtraction forces infinities to NaN
                    return ("number" === t || "string" === t) && !isNaN(e - parseFloat(e));
                },
                isPlainObject: function(e) {
                    var t, n;
                    // Detect obvious negatives
                    // Use toString instead of jQuery.type to catch host objects
                    if (!e || "[object Object]" !== pe.call(e)) return !1;
                    t = se(e);
                    // Objects with no prototype (e.g., `Object.create( null )`) are plain
                    if (!t) return !0;
                    // Objects with prototype are plain iff they were constructed by a global Object function
                    n = he.call(t, "constructor") && t.constructor;
                    return "function" === typeof n && ve.call(n) === ge;
                },
                isEmptyObject: function(e) {
                    /* eslint-disable no-unused-vars */
                    // See https://github.com/eslint/eslint/issues/6125
                    var t;
                    for (t in e) return !1;
                    return !0;
                },
                type: function(e) {
                    if (null == e) return e + "";
                    // Support: Android <=2.3 only (functionish RegExp)
                    return "object" === typeof e || "function" === typeof e ? de[pe.call(e)] || "object" : typeof e;
                },
                // Evaluates a script in a global context
                globalEval: function(e) {
                    a(e);
                },
                // Convert dashed to camelCase; used by the css and data modules
                // Support: IE <=9 - 11, Edge 12 - 13
                // Microsoft forgot to hump their vendor prefix (#9572)
                camelCase: function(e) {
                    return e.replace(we, "ms-").replace(Te, Ce);
                },
                each: function(e, t) {
                    var n, i = 0;
                    if (s(e)) {
                        n = e.length;
                        for (;i < n && !1 !== t.call(e[i], i, e[i]); i++) ;
                    } else for (i in e) if (!1 === t.call(e[i], i, e[i])) break;
                    return e;
                },
                // Support: Android <=4.0 only
                trim: function(e) {
                    return null == e ? "" : (e + "").replace(xe, "");
                },
                // results is for internal usage only
                makeArray: function(e, t) {
                    var n = t || [];
                    if (null != e) if (s(Object(e))) be.merge(n, "string" === typeof e ? [ e ] : e); else ce.call(n, e);
                    return n;
                },
                inArray: function(e, t, n) {
                    return null == t ? -1 : fe.call(t, e, n);
                },
                // Support: Android <=4.0 only, PhantomJS 1 only
                // push.apply(_, arraylike) throws on ancient WebKit
                merge: function(e, t) {
                    var n = +t.length, i = 0, r = e.length;
                    for (;i < n; i++) e[r++] = t[i];
                    e.length = r;
                    return e;
                },
                grep: function(e, t, n) {
                    var i, r = [], o = 0, a = e.length, s = !n;
                    // Go through the array, only saving the items
                    // that pass the validator function
                    for (;o < a; o++) {
                        i = !t(e[o], o);
                        if (i !== s) r.push(e[o]);
                    }
                    return r;
                },
                // arg is for internal usage only
                map: function(e, t, n) {
                    var i, r, o = 0, a = [];
                    // Go through the array, translating each of the items to their new values
                    if (s(e)) {
                        i = e.length;
                        for (;o < i; o++) {
                            r = t(e[o], o, n);
                            if (null != r) a.push(r);
                        }
                    } else for (o in e) {
                        r = t(e[o], o, n);
                        if (null != r) a.push(r);
                    }
                    // Flatten any nested arrays
                    return ue.apply([], a);
                },
                // A global GUID counter for objects
                guid: 1,
                // Bind a function to a context, optionally partially applying any
                // arguments.
                proxy: function(e, t) {
                    var n, i, r;
                    if ("string" === typeof t) {
                        n = e[t];
                        t = e;
                        e = n;
                    }
                    // Quick check to determine if target is callable, in the spec
                    // this throws a TypeError, but we will just return undefined.
                    if (!be.isFunction(e)) return undefined;
                    // Simulated bind
                    i = le.call(arguments, 2);
                    r = function() {
                        return e.apply(t || this, i.concat(le.call(arguments)));
                    };
                    // Set the guid of unique handler to the same of original handler, so it can be removed
                    r.guid = e.guid = e.guid || be.guid++;
                    return r;
                },
                now: Date.now,
                // jQuery.support is not used in Core but other projects attach their
                // properties to it so it needs to exist.
                support: me
            });
            if ("function" === typeof Symbol) be.fn[Symbol.iterator] = oe[Symbol.iterator];
            // Populate the class2type map
            be.each("Boolean Number String Function Array Date RegExp Object Error Symbol".split(" "), function(e, t) {
                de["[object " + t + "]"] = t.toLowerCase();
            });
            var ke = /*!
 * Sizzle CSS Selector Engine v2.3.3
 * https://sizzlejs.com/
 *
 * Copyright jQuery Foundation and other contributors
 * Released under the MIT license
 * http://jquery.org/license
 *
 * Date: 2016-08-08
 */
            function(e) {
                function t(e, t, n, i) {
                    var r, o, a, s, l, u, c, d = t && t.ownerDocument, // nodeType defaults to 9, since context defaults to document
                    h = t ? t.nodeType : 9;
                    n = n || [];
                    // Return early from calls with invalid selector or context
                    if ("string" !== typeof e || !e || 1 !== h && 9 !== h && 11 !== h) return n;
                    // Try to shortcut find operations (as opposed to filters) in HTML documents
                    if (!i) {
                        if ((t ? t.ownerDocument || t : W) !== j) q(t);
                        t = t || j;
                        if (L) {
                            // If the selector is sufficiently simple, try using a "get*By*" DOM method
                            // (excepting DocumentFragment context, where the methods don't exist)
                            if (11 !== h && (l = me.exec(e))) // ID selector
                            if (r = l[1]) {
                                // Document context
                                if (9 === h) if (a = t.getElementById(r)) {
                                    // Support: IE, Opera, Webkit
                                    // TODO: identify versions
                                    // getElementById can match elements by name instead of ID
                                    if (a.id === r) {
                                        n.push(a);
                                        return n;
                                    }
                                } else return n; else // Support: IE, Opera, Webkit
                                // TODO: identify versions
                                // getElementById can match elements by name instead of ID
                                if (d && (a = d.getElementById(r)) && F(t, a) && a.id === r) {
                                    n.push(a);
                                    return n;
                                }
                            } else if (l[2]) {
                                J.apply(n, t.getElementsByTagName(e));
                                return n;
                            } else if ((r = l[3]) && T.getElementsByClassName && t.getElementsByClassName) {
                                J.apply(n, t.getElementsByClassName(r));
                                return n;
                            }
                            // Take advantage of querySelectorAll
                            if (T.qsa && !B[e + " "] && (!I || !I.test(e))) {
                                if (1 !== h) {
                                    d = t;
                                    c = e;
                                } else if ("object" !== t.nodeName.toLowerCase()) {
                                    // Capture the context ID, setting it first if necessary
                                    if (s = t.getAttribute("id")) s = s.replace(we, Te); else t.setAttribute("id", s = R);
                                    // Prefix every selector in the list
                                    u = E(e);
                                    o = u.length;
                                    for (;o--; ) u[o] = "#" + s + " " + p(u[o]);
                                    c = u.join(",");
                                    // Expand context for sibling selectors
                                    d = ye.test(e) && f(t.parentNode) || t;
                                }
                                if (c) try {
                                    J.apply(n, d.querySelectorAll(c));
                                    return n;
                                } catch (v) {} finally {
                                    if (s === R) t.removeAttribute("id");
                                }
                            }
                        }
                    }
                    // All others
                    return P(e.replace(se, "$1"), t, n, i);
                }
                /**
 * Create key-value caches of limited size
 * @returns {function(string, object)} Returns the Object data after storing it on itself with
 *	property name the (space-suffixed) string and (if the cache is larger than Expr.cacheLength)
 *	deleting the oldest entry
 */
                function n() {
                    function e(n, i) {
                        // Use (key + " ") to avoid collision with native prototype properties (see Issue #157)
                        if (t.push(n + " ") > C.cacheLength) // Only keep the most recent entries
                        delete e[t.shift()];
                        return e[n + " "] = i;
                    }
                    var t = [];
                    return e;
                }
                /**
 * Mark a function for special use by Sizzle
 * @param {Function} fn The function to mark
 */
                function i(e) {
                    e[R] = !0;
                    return e;
                }
                /**
 * Support testing using an element
 * @param {Function} fn Passed the created element and returns a boolean result
 */
                function r(e) {
                    var t = j.createElement("fieldset");
                    try {
                        return !!e(t);
                    } catch (n) {
                        return !1;
                    } finally {
                        // Remove from its parent by default
                        if (t.parentNode) t.parentNode.removeChild(t);
                        // release memory in IE
                        t = null;
                    }
                }
                /**
 * Adds the same handler for all of the specified attrs
 * @param {String} attrs Pipe-separated list of attributes
 * @param {Function} handler The method that will be applied
 */
                function o(e, t) {
                    var n = e.split("|"), i = n.length;
                    for (;i--; ) C.attrHandle[n[i]] = t;
                }
                /**
 * Checks document order of two siblings
 * @param {Element} a
 * @param {Element} b
 * @returns {Number} Returns less than 0 if a precedes b, greater than 0 if a follows b
 */
                function a(e, t) {
                    var n = t && e, i = n && 1 === e.nodeType && 1 === t.nodeType && e.sourceIndex - t.sourceIndex;
                    // Use IE sourceIndex if available on both nodes
                    if (i) return i;
                    // Check if b follows a
                    if (n) for (;n = n.nextSibling; ) if (n === t) return -1;
                    return e ? 1 : -1;
                }
                /**
 * Returns a function to use in pseudos for input types
 * @param {String} type
 */
                function s(e) {
                    return function(t) {
                        return "input" === t.nodeName.toLowerCase() && t.type === e;
                    };
                }
                /**
 * Returns a function to use in pseudos for buttons
 * @param {String} type
 */
                function l(e) {
                    return function(t) {
                        var n = t.nodeName.toLowerCase();
                        return ("input" === n || "button" === n) && t.type === e;
                    };
                }
                /**
 * Returns a function to use in pseudos for :enabled/:disabled
 * @param {Boolean} disabled true for :disabled; false for :enabled
 */
                function u(e) {
                    // Known :disabled false positives: fieldset[disabled] > legend:nth-of-type(n+2) :can-disable
                    return function(t) {
                        // Only certain elements can match :enabled or :disabled
                        // https://html.spec.whatwg.org/multipage/scripting.html#selector-enabled
                        // https://html.spec.whatwg.org/multipage/scripting.html#selector-disabled
                        if ("form" in t) {
                            // Check for inherited disabledness on relevant non-disabled elements:
                            // * listed form-associated elements in a disabled fieldset
                            //   https://html.spec.whatwg.org/multipage/forms.html#category-listed
                            //   https://html.spec.whatwg.org/multipage/forms.html#concept-fe-disabled
                            // * option elements in a disabled optgroup
                            //   https://html.spec.whatwg.org/multipage/forms.html#concept-option-disabled
                            // All such elements have a "form" property.
                            if (t.parentNode && !1 === t.disabled) {
                                // Option elements defer to a parent optgroup if present
                                if ("label" in t) if ("label" in t.parentNode) return t.parentNode.disabled === e; else return t.disabled === e;
                                // Support: IE 6 - 11
                                // Use the isDisabled shortcut property to check for disabled fieldset ancestors
                                // Where there is no isDisabled, check manually
                                /* jshint -W018 */
                                return t.isDisabled === e || t.isDisabled !== !e && ke(t) === e;
                            }
                            return t.disabled === e;
                        } else if ("label" in t) return t.disabled === e;
                        // Remaining elements are neither :enabled nor :disabled
                        return !1;
                    };
                }
                /**
 * Returns a function to use in pseudos for positionals
 * @param {Function} fn
 */
                function c(e) {
                    return i(function(t) {
                        t = +t;
                        return i(function(n, i) {
                            var r, o = e([], n.length, t), a = o.length;
                            // Match elements found at the specified indexes
                            for (;a--; ) if (n[r = o[a]]) n[r] = !(i[r] = n[r]);
                        });
                    });
                }
                /**
 * Checks a node for validity as a Sizzle context
 * @param {Element|Object=} context
 * @returns {Element|Object|Boolean} The input node if acceptable, otherwise a falsy value
 */
                function f(e) {
                    return e && "undefined" !== typeof e.getElementsByTagName && e;
                }
                // Easy API for creating new setFilters
                function d() {}
                function p(e) {
                    var t = 0, n = e.length, i = "";
                    for (;t < n; t++) i += e[t].value;
                    return i;
                }
                function h(e, t, n) {
                    var i = t.dir, r = t.next, o = r || i, a = n && "parentNode" === o, s = z++;
                    // Check against closest ancestor/preceding element
                    // Check against all ancestor/preceding elements
                    return t.first ? function(t, n, r) {
                        for (;t = t[i]; ) if (1 === t.nodeType || a) return e(t, n, r);
                        return !1;
                    } : function(t, n, l) {
                        var u, c, f, d = [ $, s ];
                        // We can't set arbitrary data on XML nodes, so they don't benefit from combinator caching
                        if (l) {
                            for (;t = t[i]; ) if (1 === t.nodeType || a) if (e(t, n, l)) return !0;
                        } else for (;t = t[i]; ) if (1 === t.nodeType || a) {
                            f = t[R] || (t[R] = {});
                            // Support: IE <9 only
                            // Defend against cloned attroperties (jQuery gh-1709)
                            c = f[t.uniqueID] || (f[t.uniqueID] = {});
                            if (r && r === t.nodeName.toLowerCase()) t = t[i] || t; else if ((u = c[o]) && u[0] === $ && u[1] === s) // Assign to newCache so results back-propagate to previous elements
                            return d[2] = u[2]; else {
                                // Reuse newcache so results back-propagate to previous elements
                                c[o] = d;
                                // A match means we're done; a fail means we have to keep checking
                                if (d[2] = e(t, n, l)) return !0;
                            }
                        }
                        return !1;
                    };
                }
                function v(e) {
                    return e.length > 1 ? function(t, n, i) {
                        var r = e.length;
                        for (;r--; ) if (!e[r](t, n, i)) return !1;
                        return !0;
                    } : e[0];
                }
                function g(e, n, i) {
                    var r = 0, o = n.length;
                    for (;r < o; r++) t(e, n[r], i);
                    return i;
                }
                function m(e, t, n, i, r) {
                    var o, a = [], s = 0, l = e.length, u = null != t;
                    for (;s < l; s++) if (o = e[s]) if (!n || n(o, i, r)) {
                        a.push(o);
                        if (u) t.push(s);
                    }
                    return a;
                }
                function y(e, t, n, r, o, a) {
                    if (r && !r[R]) r = y(r);
                    if (o && !o[R]) o = y(o, a);
                    return i(function(i, a, s, l) {
                        var u, c, f, d = [], p = [], h = a.length, // Get initial elements from seed or context
                        v = i || g(t || "*", s.nodeType ? [ s ] : s, []), // Prefilter to get matcher input, preserving a map for seed-results synchronization
                        y = e && (i || !t) ? m(v, d, e, s, l) : v, b = n ? // If we have a postFinder, or filtered seed, or non-seed postFilter or preexisting results,
                        o || (i ? e : h || r) ? // ...intermediate processing is necessary
                        [] : // ...otherwise use results directly
                        a : y;
                        // Find primary matches
                        if (n) n(y, b, s, l);
                        // Apply postFilter
                        if (r) {
                            u = m(b, p);
                            r(u, [], s, l);
                            // Un-match failing elements by moving them back to matcherIn
                            c = u.length;
                            for (;c--; ) if (f = u[c]) b[p[c]] = !(y[p[c]] = f);
                        }
                        if (i) {
                            if (o || e) {
                                if (o) {
                                    // Get the final matcherOut by condensing this intermediate into postFinder contexts
                                    u = [];
                                    c = b.length;
                                    for (;c--; ) if (f = b[c]) // Restore matcherIn since elem is not yet a final match
                                    u.push(y[c] = f);
                                    o(null, b = [], u, l);
                                }
                                // Move matched elements from seed to results to keep them synchronized
                                c = b.length;
                                for (;c--; ) if ((f = b[c]) && (u = o ? ee(i, f) : d[c]) > -1) i[u] = !(a[u] = f);
                            }
                        } else {
                            b = m(b === a ? b.splice(h, b.length) : b);
                            if (o) o(null, a, b, l); else J.apply(a, b);
                        }
                    });
                }
                function b(e) {
                    var t, n, i, r = e.length, o = C.relative[e[0].type], a = o || C.relative[" "], s = o ? 1 : 0, // The foundational matcher ensures that elements are reachable from top-level context(s)
                    l = h(function(e) {
                        return e === t;
                    }, a, !0), u = h(function(e) {
                        return ee(t, e) > -1;
                    }, a, !0), c = [ function(e, n, i) {
                        var r = !o && (i || n !== D) || ((t = n).nodeType ? l(e, n, i) : u(e, n, i));
                        // Avoid hanging onto element (issue #299)
                        t = null;
                        return r;
                    } ];
                    for (;s < r; s++) if (n = C.relative[e[s].type]) c = [ h(v(c), n) ]; else {
                        n = C.filter[e[s].type].apply(null, e[s].matches);
                        // Return special upon seeing a positional matcher
                        if (n[R]) {
                            // Find the next relative operator (if any) for proper handling
                            i = ++s;
                            for (;i < r && !C.relative[e[i].type]; i++) ;
                            // If the preceding token was a descendant combinator, insert an implicit any-element `*`
                            return y(s > 1 && v(c), s > 1 && p(e.slice(0, s - 1).concat({
                                value: " " === e[s - 2].type ? "*" : ""
                            })).replace(se, "$1"), n, s < i && b(e.slice(s, i)), i < r && b(e = e.slice(i)), i < r && p(e));
                        }
                        c.push(n);
                    }
                    return v(c);
                }
                function x(e, n) {
                    var r = n.length > 0, o = e.length > 0, a = function(i, a, s, l, u) {
                        var c, f, d, p = 0, h = "0", v = i && [], g = [], y = D, // We must always have either seed elements or outermost context
                        b = i || o && C.find.TAG("*", u), // Use integer dirruns iff this is the outermost matcher
                        x = $ += null == y ? 1 : Math.random() || .1, w = b.length;
                        if (u) D = a === j || a || u;
                        // Add elements passing elementMatchers directly to results
                        // Support: IE<9, Safari
                        // Tolerate NodeList properties (IE: "length"; Safari: <number>) matching elements by id
                        for (;h !== w && null != (c = b[h]); h++) {
                            if (o && c) {
                                f = 0;
                                if (!a && c.ownerDocument !== j) {
                                    q(c);
                                    s = !L;
                                }
                                for (;d = e[f++]; ) if (d(c, a || j, s)) {
                                    l.push(c);
                                    break;
                                }
                                if (u) $ = x;
                            }
                            // Track unmatched elements for set filters
                            if (r) {
                                // They will have gone through all possible matchers
                                if (c = !d && c) p--;
                                // Lengthen the array for every element, matched or not
                                if (i) v.push(c);
                            }
                        }
                        // `i` is now the count of elements visited above, and adding it to `matchedCount`
                        // makes the latter nonnegative.
                        p += h;
                        // Apply set filters to unmatched elements
                        // NOTE: This can be skipped if there are no unmatched elements (i.e., `matchedCount`
                        // equals `i`), unless we didn't visit _any_ elements in the above loop because we have
                        // no element matchers and no seed.
                        // Incrementing an initially-string "0" `i` allows `i` to remain a string only in that
                        // case, which will result in a "00" `matchedCount` that differs from `i` but is also
                        // numerically zero.
                        if (r && h !== p) {
                            f = 0;
                            for (;d = n[f++]; ) d(v, g, a, s);
                            if (i) {
                                // Reintegrate element matches to eliminate the need for sorting
                                if (p > 0) for (;h--; ) if (!v[h] && !g[h]) g[h] = G.call(l);
                                // Discard index placeholder values to get only actual matches
                                g = m(g);
                            }
                            // Add matches to results
                            J.apply(l, g);
                            // Seedless set matches succeeding multiple successful matchers stipulate sorting
                            if (u && !i && g.length > 0 && p + n.length > 1) t.uniqueSort(l);
                        }
                        // Override manipulation of globals by nested matchers
                        if (u) {
                            $ = x;
                            D = y;
                        }
                        return v;
                    };
                    return r ? i(a) : a;
                }
                var w, T, C, k, S, E, A, P, D, O, N, // Local document vars
                q, j, M, L, I, H, _, F, // Instance-specific data
                R = "sizzle" + 1 * new Date(), W = e.document, $ = 0, z = 0, V = n(), X = n(), B = n(), Y = function(e, t) {
                    if (e === t) N = !0;
                    return 0;
                }, // Instance methods
                Q = {}.hasOwnProperty, U = [], G = U.pop, Z = U.push, J = U.push, K = U.slice, // Use a stripped-down indexOf as it's faster than native
                // https://jsperf.com/thor-indexof-vs-for/5
                ee = function(e, t) {
                    var n = 0, i = e.length;
                    for (;n < i; n++) if (e[n] === t) return n;
                    return -1;
                }, te = "checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped", // Regular expressions
                // http://www.w3.org/TR/css3-selectors/#whitespace
                ne = "[\\x20\\t\\r\\n\\f]", // http://www.w3.org/TR/CSS21/syndata.html#value-def-identifier
                ie = "(?:\\\\.|[\\w-]|[^\0-\\xa0])+", // Attribute selectors: http://www.w3.org/TR/selectors/#attribute-selectors
                re = "\\[" + ne + "*(" + ie + ")(?:" + ne + // Operator (capture 2)
                "*([*^$|!~]?=)" + ne + // "Attribute values must be CSS identifiers [capture 5] or strings [capture 3 or capture 4]"
                "*(?:'((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\"|(" + ie + "))|)" + ne + "*\\]", oe = ":(" + ie + ")(?:\\((" + // To reduce the number of selectors needing tokenize in the preFilter, prefer arguments:
                // 1. quoted (capture 3; capture 4 or capture 5)
                "('((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\")|" + // 2. simple (capture 6)
                "((?:\\\\.|[^\\\\()[\\]]|" + re + ")*)|" + // 3. anything else (capture 2)
                ".*" + ")\\)|)", // Leading and non-escaped trailing whitespace, capturing some non-whitespace characters preceding the latter
                ae = new RegExp(ne + "+", "g"), se = new RegExp("^" + ne + "+|((?:^|[^\\\\])(?:\\\\.)*)" + ne + "+$", "g"), le = new RegExp("^" + ne + "*," + ne + "*"), ue = new RegExp("^" + ne + "*([>+~]|" + ne + ")" + ne + "*"), ce = new RegExp("=" + ne + "*([^\\]'\"]*?)" + ne + "*\\]", "g"), fe = new RegExp(oe), de = new RegExp("^" + ie + "$"), pe = {
                    ID: new RegExp("^#(" + ie + ")"),
                    CLASS: new RegExp("^\\.(" + ie + ")"),
                    TAG: new RegExp("^(" + ie + "|[*])"),
                    ATTR: new RegExp("^" + re),
                    PSEUDO: new RegExp("^" + oe),
                    CHILD: new RegExp("^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\(" + ne + "*(even|odd|(([+-]|)(\\d*)n|)" + ne + "*(?:([+-]|)" + ne + "*(\\d+)|))" + ne + "*\\)|)", "i"),
                    bool: new RegExp("^(?:" + te + ")$", "i"),
                    // For use in libraries implementing .is()
                    // We use this for POS matching in `select`
                    needsContext: new RegExp("^" + ne + "*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\(" + ne + "*((?:-\\d)?\\d*)" + ne + "*\\)|)(?=[^-]|$)", "i")
                }, he = /^(?:input|select|textarea|button)$/i, ve = /^h\d$/i, ge = /^[^{]+\{\s*\[native \w/, // Easily-parseable/retrievable ID or TAG or CLASS selectors
                me = /^(?:#([\w-]+)|(\w+)|\.([\w-]+))$/, ye = /[+~]/, // CSS escapes
                // http://www.w3.org/TR/CSS21/syndata.html#escaped-characters
                be = new RegExp("\\\\([\\da-f]{1,6}" + ne + "?|(" + ne + ")|.)", "ig"), xe = function(e, t, n) {
                    var i = "0x" + t - 65536;
                    // NaN means non-codepoint
                    // Support: Firefox<24
                    // Workaround erroneous numeric interpretation of +"0x"
                    // BMP codepoint
                    // Supplemental Plane codepoint (surrogate pair)
                    return i !== i || n ? t : i < 0 ? String.fromCharCode(i + 65536) : String.fromCharCode(i >> 10 | 55296, 1023 & i | 56320);
                }, // CSS string/identifier serialization
                // https://drafts.csswg.org/cssom/#common-serializing-idioms
                we = /([\0-\x1f\x7f]|^-?\d)|^-$|[^\0-\x1f\x7f-\uFFFF\w-]/g, Te = function(e, t) {
                    if (t) {
                        // U+0000 NULL becomes U+FFFD REPLACEMENT CHARACTER
                        if ("\0" === e) return "ï¿½";
                        // Control characters and (dependent upon position) numbers get escaped as code points
                        return e.slice(0, -1) + "\\" + e.charCodeAt(e.length - 1).toString(16) + " ";
                    }
                    // Other potentially-special ASCII characters get backslash-escaped
                    return "\\" + e;
                }, // Used for iframes
                // See setDocument()
                // Removing the function wrapper causes a "Permission Denied"
                // error in IE
                Ce = function() {
                    q();
                }, ke = h(function(e) {
                    return !0 === e.disabled && ("form" in e || "label" in e);
                }, {
                    dir: "parentNode",
                    next: "legend"
                });
                // Optimize for push.apply( _, NodeList )
                try {
                    J.apply(U = K.call(W.childNodes), W.childNodes);
                    // Support: Android<4.0
                    // Detect silently failing push.apply
                    U[W.childNodes.length].nodeType;
                } catch (Se) {
                    J = {
                        apply: U.length ? // Leverage slice if possible
                        function(e, t) {
                            Z.apply(e, K.call(t));
                        } : // Support: IE<9
                        // Otherwise append directly
                        function(e, t) {
                            var n = e.length, i = 0;
                            // Can't trust NodeList.length
                            for (;e[n++] = t[i++]; ) ;
                            e.length = n - 1;
                        }
                    };
                }
                // Expose support vars for convenience
                T = t.support = {};
                /**
 * Detects XML nodes
 * @param {Element|Object} elem An element or a document
 * @returns {Boolean} True iff elem is a non-HTML XML node
 */
                S = t.isXML = function(e) {
                    // documentElement is verified for cases where it doesn't yet exist
                    // (such as loading iframes in IE - #4833)
                    var t = e && (e.ownerDocument || e).documentElement;
                    return t ? "HTML" !== t.nodeName : !1;
                };
                /**
 * Sets document-related variables once based on the current document
 * @param {Element|Object} [doc] An element or document object to use to set the document
 * @returns {Object} Returns the current document
 */
                q = t.setDocument = function(e) {
                    var t, n, i = e ? e.ownerDocument || e : W;
                    // Return early if doc is invalid or already selected
                    if (i === j || 9 !== i.nodeType || !i.documentElement) return j;
                    // Update global variables
                    j = i;
                    M = j.documentElement;
                    L = !S(j);
                    // Support: IE 9-11, Edge
                    // Accessing iframe documents after unload throws "permission denied" errors (jQuery #13936)
                    if (W !== j && (n = j.defaultView) && n.top !== n) // Support: IE 11, Edge
                    if (n.addEventListener) n.addEventListener("unload", Ce, !1); else if (n.attachEvent) n.attachEvent("onunload", Ce);
                    /* Attributes
	---------------------------------------------------------------------- */
                    // Support: IE<8
                    // Verify that getAttribute really returns attributes and not properties
                    // (excepting IE8 booleans)
                    T.attributes = r(function(e) {
                        e.className = "i";
                        return !e.getAttribute("className");
                    });
                    /* getElement(s)By*
	---------------------------------------------------------------------- */
                    // Check if getElementsByTagName("*") returns only elements
                    T.getElementsByTagName = r(function(e) {
                        e.appendChild(j.createComment(""));
                        return !e.getElementsByTagName("*").length;
                    });
                    // Support: IE<9
                    T.getElementsByClassName = ge.test(j.getElementsByClassName);
                    // Support: IE<10
                    // Check if getElementById returns elements by name
                    // The broken getElementById methods don't pick up programmatically-set names,
                    // so use a roundabout getElementsByName test
                    T.getById = r(function(e) {
                        M.appendChild(e).id = R;
                        return !j.getElementsByName || !j.getElementsByName(R).length;
                    });
                    // ID filter and find
                    if (T.getById) {
                        C.filter.ID = function(e) {
                            var t = e.replace(be, xe);
                            return function(e) {
                                return e.getAttribute("id") === t;
                            };
                        };
                        C.find.ID = function(e, t) {
                            if ("undefined" !== typeof t.getElementById && L) {
                                var n = t.getElementById(e);
                                return n ? [ n ] : [];
                            }
                        };
                    } else {
                        C.filter.ID = function(e) {
                            var t = e.replace(be, xe);
                            return function(e) {
                                var n = "undefined" !== typeof e.getAttributeNode && e.getAttributeNode("id");
                                return n && n.value === t;
                            };
                        };
                        // Support: IE 6 - 7 only
                        // getElementById is not reliable as a find shortcut
                        C.find.ID = function(e, t) {
                            if ("undefined" !== typeof t.getElementById && L) {
                                var n, i, r, o = t.getElementById(e);
                                if (o) {
                                    // Verify the id attribute
                                    n = o.getAttributeNode("id");
                                    if (n && n.value === e) return [ o ];
                                    // Fall back on getElementsByName
                                    r = t.getElementsByName(e);
                                    i = 0;
                                    for (;o = r[i++]; ) {
                                        n = o.getAttributeNode("id");
                                        if (n && n.value === e) return [ o ];
                                    }
                                }
                                return [];
                            }
                        };
                    }
                    // Tag
                    C.find.TAG = T.getElementsByTagName ? function(e, t) {
                        if ("undefined" !== typeof t.getElementsByTagName) return t.getElementsByTagName(e); else if (T.qsa) return t.querySelectorAll(e);
                    } : function(e, t) {
                        var n, i = [], r = 0, // By happy coincidence, a (broken) gEBTN appears on DocumentFragment nodes too
                        o = t.getElementsByTagName(e);
                        // Filter out possible comments
                        if ("*" === e) {
                            for (;n = o[r++]; ) if (1 === n.nodeType) i.push(n);
                            return i;
                        }
                        return o;
                    };
                    // Class
                    C.find.CLASS = T.getElementsByClassName && function(e, t) {
                        if ("undefined" !== typeof t.getElementsByClassName && L) return t.getElementsByClassName(e);
                    };
                    /* QSA/matchesSelector
	---------------------------------------------------------------------- */
                    // QSA and matchesSelector support
                    // matchesSelector(:active) reports false when true (IE9/Opera 11.5)
                    H = [];
                    // qSa(:focus) reports false when true (Chrome 21)
                    // We allow this because of a bug in IE8/9 that throws an error
                    // whenever `document.activeElement` is accessed on an iframe
                    // So, we allow :focus to pass through QSA all the time to avoid the IE error
                    // See https://bugs.jquery.com/ticket/13378
                    I = [];
                    if (T.qsa = ge.test(j.querySelectorAll)) {
                        // Build QSA regex
                        // Regex strategy adopted from Diego Perini
                        r(function(e) {
                            // Select is set to empty string on purpose
                            // This is to test IE's treatment of not explicitly
                            // setting a boolean content attribute,
                            // since its presence should be enough
                            // https://bugs.jquery.com/ticket/12359
                            M.appendChild(e).innerHTML = "<a id='" + R + "'></a>" + "<select id='" + R + "-\r\\' msallowcapture=''>" + "<option selected=''></option></select>";
                            // Support: IE8, Opera 11-12.16
                            // Nothing should be selected when empty strings follow ^= or $= or *=
                            // The test attribute must be unknown in Opera but "safe" for WinRT
                            // https://msdn.microsoft.com/en-us/library/ie/hh465388.aspx#attribute_section
                            if (e.querySelectorAll("[msallowcapture^='']").length) I.push("[*^$]=" + ne + "*(?:''|\"\")");
                            // Support: IE8
                            // Boolean attributes and "value" are not treated correctly
                            if (!e.querySelectorAll("[selected]").length) I.push("\\[" + ne + "*(?:value|" + te + ")");
                            // Support: Chrome<29, Android<4.4, Safari<7.0+, iOS<7.0+, PhantomJS<1.9.8+
                            if (!e.querySelectorAll("[id~=" + R + "-]").length) I.push("~=");
                            // Webkit/Opera - :checked should return selected option elements
                            // http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked
                            // IE8 throws error here and will not see later tests
                            if (!e.querySelectorAll(":checked").length) I.push(":checked");
                            // Support: Safari 8+, iOS 8+
                            // https://bugs.webkit.org/show_bug.cgi?id=136851
                            // In-page `selector#id sibling-combinator selector` fails
                            if (!e.querySelectorAll("a#" + R + "+*").length) I.push(".#.+[+~]");
                        });
                        r(function(e) {
                            e.innerHTML = "<a href='' disabled='disabled'></a>" + "<select disabled='disabled'><option/></select>";
                            // Support: Windows 8 Native Apps
                            // The type and name attributes are restricted during .innerHTML assignment
                            var t = j.createElement("input");
                            t.setAttribute("type", "hidden");
                            e.appendChild(t).setAttribute("name", "D");
                            // Support: IE8
                            // Enforce case-sensitivity of name attribute
                            if (e.querySelectorAll("[name=d]").length) I.push("name" + ne + "*[*^$|!~]?=");
                            // FF 3.5 - :enabled/:disabled and hidden elements (hidden elements are still enabled)
                            // IE8 throws error here and will not see later tests
                            if (2 !== e.querySelectorAll(":enabled").length) I.push(":enabled", ":disabled");
                            // Support: IE9-11+
                            // IE's :disabled selector does not pick up the children of disabled fieldsets
                            M.appendChild(e).disabled = !0;
                            if (2 !== e.querySelectorAll(":disabled").length) I.push(":enabled", ":disabled");
                            // Opera 10-11 does not throw on post-comma invalid pseudos
                            e.querySelectorAll("*,:x");
                            I.push(",.*:");
                        });
                    }
                    if (T.matchesSelector = ge.test(_ = M.matches || M.webkitMatchesSelector || M.mozMatchesSelector || M.oMatchesSelector || M.msMatchesSelector)) r(function(e) {
                        // Check to see if it's possible to do matchesSelector
                        // on a disconnected node (IE 9)
                        T.disconnectedMatch = _.call(e, "*");
                        // This should fail with an exception
                        // Gecko does not error, returns false instead
                        _.call(e, "[s!='']:x");
                        H.push("!=", oe);
                    });
                    I = I.length && new RegExp(I.join("|"));
                    H = H.length && new RegExp(H.join("|"));
                    /* Contains
	---------------------------------------------------------------------- */
                    t = ge.test(M.compareDocumentPosition);
                    // Element contains another
                    // Purposefully self-exclusive
                    // As in, an element does not contain itself
                    F = t || ge.test(M.contains) ? function(e, t) {
                        var n = 9 === e.nodeType ? e.documentElement : e, i = t && t.parentNode;
                        return e === i || !(!i || 1 !== i.nodeType || !(n.contains ? n.contains(i) : e.compareDocumentPosition && 16 & e.compareDocumentPosition(i)));
                    } : function(e, t) {
                        if (t) for (;t = t.parentNode; ) if (t === e) return !0;
                        return !1;
                    };
                    /* Sorting
	---------------------------------------------------------------------- */
                    // Document order sorting
                    Y = t ? function(e, t) {
                        // Flag for duplicate removal
                        if (e === t) {
                            N = !0;
                            return 0;
                        }
                        // Sort on method existence if only one input has compareDocumentPosition
                        var n = !e.compareDocumentPosition - !t.compareDocumentPosition;
                        if (n) return n;
                        // Calculate position if both inputs belong to the same document
                        n = (e.ownerDocument || e) === (t.ownerDocument || t) ? e.compareDocumentPosition(t) : // Otherwise we know they are disconnected
                        1;
                        // Disconnected nodes
                        if (1 & n || !T.sortDetached && t.compareDocumentPosition(e) === n) {
                            // Choose the first element that is related to our preferred document
                            if (e === j || e.ownerDocument === W && F(W, e)) return -1;
                            if (t === j || t.ownerDocument === W && F(W, t)) return 1;
                            // Maintain original order
                            return O ? ee(O, e) - ee(O, t) : 0;
                        }
                        return 4 & n ? -1 : 1;
                    } : function(e, t) {
                        // Exit early if the nodes are identical
                        if (e === t) {
                            N = !0;
                            return 0;
                        }
                        var n, i = 0, r = e.parentNode, o = t.parentNode, s = [ e ], l = [ t ];
                        // Parentless nodes are either documents or disconnected
                        if (!r || !o) return e === j ? -1 : t === j ? 1 : r ? -1 : o ? 1 : O ? ee(O, e) - ee(O, t) : 0; else if (r === o) return a(e, t);
                        // Otherwise we need full lists of their ancestors for comparison
                        n = e;
                        for (;n = n.parentNode; ) s.unshift(n);
                        n = t;
                        for (;n = n.parentNode; ) l.unshift(n);
                        // Walk down the tree looking for a discrepancy
                        for (;s[i] === l[i]; ) i++;
                        // Do a sibling check if the nodes have a common ancestor
                        // Otherwise nodes in our document sort first
                        return i ? a(s[i], l[i]) : s[i] === W ? -1 : l[i] === W ? 1 : 0;
                    };
                    return j;
                };
                t.matches = function(e, n) {
                    return t(e, null, null, n);
                };
                t.matchesSelector = function(e, n) {
                    // Set document vars if needed
                    if ((e.ownerDocument || e) !== j) q(e);
                    // Make sure that attribute selectors are quoted
                    n = n.replace(ce, "='$1']");
                    if (T.matchesSelector && L && !B[n + " "] && (!H || !H.test(n)) && (!I || !I.test(n))) try {
                        var i = _.call(e, n);
                        // IE 9's matchesSelector returns false on disconnected nodes
                        if (i || T.disconnectedMatch || // As well, disconnected nodes are said to be in a document
                        // fragment in IE 9
                        e.document && 11 !== e.document.nodeType) return i;
                    } catch (Se) {}
                    return t(n, j, null, [ e ]).length > 0;
                };
                t.contains = function(e, t) {
                    // Set document vars if needed
                    if ((e.ownerDocument || e) !== j) q(e);
                    return F(e, t);
                };
                t.attr = function(e, t) {
                    // Set document vars if needed
                    if ((e.ownerDocument || e) !== j) q(e);
                    var n = C.attrHandle[t.toLowerCase()], // Don't get fooled by Object.prototype properties (jQuery #13807)
                    i = n && Q.call(C.attrHandle, t.toLowerCase()) ? n(e, t, !L) : undefined;
                    return i !== undefined ? i : T.attributes || !L ? e.getAttribute(t) : (i = e.getAttributeNode(t)) && i.specified ? i.value : null;
                };
                t.escape = function(e) {
                    return (e + "").replace(we, Te);
                };
                t.error = function(e) {
                    throw new Error("Syntax error, unrecognized expression: " + e);
                };
                /**
 * Document sorting and removing duplicates
 * @param {ArrayLike} results
 */
                t.uniqueSort = function(e) {
                    var t, n = [], i = 0, r = 0;
                    // Unless we *know* we can detect duplicates, assume their presence
                    N = !T.detectDuplicates;
                    O = !T.sortStable && e.slice(0);
                    e.sort(Y);
                    if (N) {
                        for (;t = e[r++]; ) if (t === e[r]) i = n.push(r);
                        for (;i--; ) e.splice(n[i], 1);
                    }
                    // Clear input after sorting to release objects
                    // See https://github.com/jquery/sizzle/pull/225
                    O = null;
                    return e;
                };
                /**
 * Utility function for retrieving the text value of an array of DOM nodes
 * @param {Array|Element} elem
 */
                k = t.getText = function(e) {
                    var t, n = "", i = 0, r = e.nodeType;
                    if (!r) // If no nodeType, this is expected to be an array
                    for (;t = e[i++]; ) // Do not traverse comment nodes
                    n += k(t); else if (1 === r || 9 === r || 11 === r) // Use textContent for elements
                    // innerText usage removed for consistency of new lines (jQuery #11153)
                    if ("string" === typeof e.textContent) return e.textContent; else // Traverse its children
                    for (e = e.firstChild; e; e = e.nextSibling) n += k(e); else if (3 === r || 4 === r) return e.nodeValue;
                    // Do not include comment or processing instruction nodes
                    return n;
                };
                C = t.selectors = {
                    // Can be adjusted by the user
                    cacheLength: 50,
                    createPseudo: i,
                    match: pe,
                    attrHandle: {},
                    find: {},
                    relative: {
                        ">": {
                            dir: "parentNode",
                            first: !0
                        },
                        " ": {
                            dir: "parentNode"
                        },
                        "+": {
                            dir: "previousSibling",
                            first: !0
                        },
                        "~": {
                            dir: "previousSibling"
                        }
                    },
                    preFilter: {
                        ATTR: function(e) {
                            e[1] = e[1].replace(be, xe);
                            // Move the given value to match[3] whether quoted or unquoted
                            e[3] = (e[3] || e[4] || e[5] || "").replace(be, xe);
                            if ("~=" === e[2]) e[3] = " " + e[3] + " ";
                            return e.slice(0, 4);
                        },
                        CHILD: function(e) {
                            /* matches from matchExpr["CHILD"]
				1 type (only|nth|...)
				2 what (child|of-type)
				3 argument (even|odd|\d*|\d*n([+-]\d+)?|...)
				4 xn-component of xn+y argument ([+-]?\d*n|)
				5 sign of xn-component
				6 x of xn-component
				7 sign of y-component
				8 y of y-component
			*/
                            e[1] = e[1].toLowerCase();
                            if ("nth" === e[1].slice(0, 3)) {
                                // nth-* requires argument
                                if (!e[3]) t.error(e[0]);
                                // numeric x and y parameters for Expr.filter.CHILD
                                // remember that false/true cast respectively to 0/1
                                e[4] = +(e[4] ? e[5] + (e[6] || 1) : 2 * ("even" === e[3] || "odd" === e[3]));
                                e[5] = +(e[7] + e[8] || "odd" === e[3]);
                            } else if (e[3]) t.error(e[0]);
                            return e;
                        },
                        PSEUDO: function(e) {
                            var t, n = !e[6] && e[2];
                            if (pe.CHILD.test(e[0])) return null;
                            // Accept quoted arguments as-is
                            if (e[3]) e[2] = e[4] || e[5] || ""; else if (n && fe.test(n) && (// Get excess from tokenize (recursively)
                            t = E(n, !0)) && (// advance to the next closing parenthesis
                            t = n.indexOf(")", n.length - t) - n.length)) {
                                // excess is a negative index
                                e[0] = e[0].slice(0, t);
                                e[2] = n.slice(0, t);
                            }
                            // Return only captures needed by the pseudo filter method (type and argument)
                            return e.slice(0, 3);
                        }
                    },
                    filter: {
                        TAG: function(e) {
                            var t = e.replace(be, xe).toLowerCase();
                            return "*" === e ? function() {
                                return !0;
                            } : function(e) {
                                return e.nodeName && e.nodeName.toLowerCase() === t;
                            };
                        },
                        CLASS: function(e) {
                            var t = V[e + " "];
                            return t || (t = new RegExp("(^|" + ne + ")" + e + "(" + ne + "|$)")) && V(e, function(e) {
                                return t.test("string" === typeof e.className && e.className || "undefined" !== typeof e.getAttribute && e.getAttribute("class") || "");
                            });
                        },
                        ATTR: function(e, n, i) {
                            return function(r) {
                                var o = t.attr(r, e);
                                if (null == o) return "!=" === n;
                                if (!n) return !0;
                                o += "";
                                return "=" === n ? o === i : "!=" === n ? o !== i : "^=" === n ? i && 0 === o.indexOf(i) : "*=" === n ? i && o.indexOf(i) > -1 : "$=" === n ? i && o.slice(-i.length) === i : "~=" === n ? (" " + o.replace(ae, " ") + " ").indexOf(i) > -1 : "|=" === n ? o === i || o.slice(0, i.length + 1) === i + "-" : !1;
                            };
                        },
                        CHILD: function(e, t, n, i, r) {
                            var o = "nth" !== e.slice(0, 3), a = "last" !== e.slice(-4), s = "of-type" === t;
                            // Shortcut for :nth-*(n)
                            return 1 === i && 0 === r ? function(e) {
                                return !!e.parentNode;
                            } : function(t, n, l) {
                                var u, c, f, d, p, h, v = o !== a ? "nextSibling" : "previousSibling", g = t.parentNode, m = s && t.nodeName.toLowerCase(), y = !l && !s, b = !1;
                                if (g) {
                                    // :(first|last|only)-(child|of-type)
                                    if (o) {
                                        for (;v; ) {
                                            d = t;
                                            for (;d = d[v]; ) if (s ? d.nodeName.toLowerCase() === m : 1 === d.nodeType) return !1;
                                            // Reverse direction for :only-* (if we haven't yet done so)
                                            h = v = "only" === e && !h && "nextSibling";
                                        }
                                        return !0;
                                    }
                                    h = [ a ? g.firstChild : g.lastChild ];
                                    // non-xml :nth-child(...) stores cache data on `parent`
                                    if (a && y) {
                                        // Seek `elem` from a previously-cached index
                                        // ...in a gzip-friendly way
                                        d = g;
                                        f = d[R] || (d[R] = {});
                                        // Support: IE <9 only
                                        // Defend against cloned attroperties (jQuery gh-1709)
                                        c = f[d.uniqueID] || (f[d.uniqueID] = {});
                                        u = c[e] || [];
                                        p = u[0] === $ && u[1];
                                        b = p && u[2];
                                        d = p && g.childNodes[p];
                                        for (;d = ++p && d && d[v] || (// Fallback to seeking `elem` from the start
                                        b = p = 0) || h.pop(); ) // When found, cache indexes on `parent` and break
                                        if (1 === d.nodeType && ++b && d === t) {
                                            c[e] = [ $, p, b ];
                                            break;
                                        }
                                    } else {
                                        // Use previously-cached element index if available
                                        if (y) {
                                            // ...in a gzip-friendly way
                                            d = t;
                                            f = d[R] || (d[R] = {});
                                            // Support: IE <9 only
                                            // Defend against cloned attroperties (jQuery gh-1709)
                                            c = f[d.uniqueID] || (f[d.uniqueID] = {});
                                            u = c[e] || [];
                                            p = u[0] === $ && u[1];
                                            b = p;
                                        }
                                        // xml :nth-child(...)
                                        // or :nth-last-child(...) or :nth(-last)?-of-type(...)
                                        if (!1 === b) // Use the same loop as above to seek `elem` from the start
                                        for (;d = ++p && d && d[v] || (b = p = 0) || h.pop(); ) if ((s ? d.nodeName.toLowerCase() === m : 1 === d.nodeType) && ++b) {
                                            // Cache the index of each encountered element
                                            if (y) {
                                                f = d[R] || (d[R] = {});
                                                // Support: IE <9 only
                                                // Defend against cloned attroperties (jQuery gh-1709)
                                                c = f[d.uniqueID] || (f[d.uniqueID] = {});
                                                c[e] = [ $, b ];
                                            }
                                            if (d === t) break;
                                        }
                                    }
                                    // Incorporate the offset, then check against cycle size
                                    b -= r;
                                    return b === i || b % i === 0 && b / i >= 0;
                                }
                            };
                        },
                        PSEUDO: function(e, n) {
                            // pseudo-class names are case-insensitive
                            // http://www.w3.org/TR/selectors/#pseudo-classes
                            // Prioritize by case sensitivity in case custom pseudos are added with uppercase letters
                            // Remember that setFilters inherits from pseudos
                            var r, o = C.pseudos[e] || C.setFilters[e.toLowerCase()] || t.error("unsupported pseudo: " + e);
                            // The user may use createPseudo to indicate that
                            // arguments are needed to create the filter function
                            // just as Sizzle does
                            if (o[R]) return o(n);
                            // But maintain support for old signatures
                            if (o.length > 1) {
                                r = [ e, e, "", n ];
                                return C.setFilters.hasOwnProperty(e.toLowerCase()) ? i(function(e, t) {
                                    var i, r = o(e, n), a = r.length;
                                    for (;a--; ) {
                                        i = ee(e, r[a]);
                                        e[i] = !(t[i] = r[a]);
                                    }
                                }) : function(e) {
                                    return o(e, 0, r);
                                };
                            }
                            return o;
                        }
                    },
                    pseudos: {
                        // Potentially complex pseudos
                        not: i(function(e) {
                            // Trim the selector passed to compile
                            // to avoid treating leading and trailing
                            // spaces as combinators
                            var t = [], n = [], r = A(e.replace(se, "$1"));
                            return r[R] ? i(function(e, t, n, i) {
                                var o, a = r(e, null, i, []), s = e.length;
                                // Match elements unmatched by `matcher`
                                for (;s--; ) if (o = a[s]) e[s] = !(t[s] = o);
                            }) : function(e, i, o) {
                                t[0] = e;
                                r(t, null, o, n);
                                // Don't keep the element (issue #299)
                                t[0] = null;
                                return !n.pop();
                            };
                        }),
                        has: i(function(e) {
                            return function(n) {
                                return t(e, n).length > 0;
                            };
                        }),
                        contains: i(function(e) {
                            e = e.replace(be, xe);
                            return function(t) {
                                return (t.textContent || t.innerText || k(t)).indexOf(e) > -1;
                            };
                        }),
                        // "Whether an element is represented by a :lang() selector
                        // is based solely on the element's language value
                        // being equal to the identifier C,
                        // or beginning with the identifier C immediately followed by "-".
                        // The matching of C against the element's language value is performed case-insensitively.
                        // The identifier C does not have to be a valid language name."
                        // http://www.w3.org/TR/selectors/#lang-pseudo
                        lang: i(function(e) {
                            // lang value must be a valid identifier
                            if (!de.test(e || "")) t.error("unsupported lang: " + e);
                            e = e.replace(be, xe).toLowerCase();
                            return function(t) {
                                var n;
                                do {
                                    if (n = L ? t.lang : t.getAttribute("xml:lang") || t.getAttribute("lang")) {
                                        n = n.toLowerCase();
                                        return n === e || 0 === n.indexOf(e + "-");
                                    }
                                } while ((t = t.parentNode) && 1 === t.nodeType);
                                return !1;
                            };
                        }),
                        // Miscellaneous
                        target: function(t) {
                            var n = e.location && e.location.hash;
                            return n && n.slice(1) === t.id;
                        },
                        root: function(e) {
                            return e === M;
                        },
                        focus: function(e) {
                            return e === j.activeElement && (!j.hasFocus || j.hasFocus()) && !!(e.type || e.href || ~e.tabIndex);
                        },
                        // Boolean properties
                        enabled: u(!1),
                        disabled: u(!0),
                        checked: function(e) {
                            // In CSS3, :checked should return both checked and selected elements
                            // http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked
                            var t = e.nodeName.toLowerCase();
                            return "input" === t && !!e.checked || "option" === t && !!e.selected;
                        },
                        selected: function(e) {
                            // Accessing this property makes selected-by-default
                            // options in Safari work properly
                            if (e.parentNode) e.parentNode.selectedIndex;
                            return !0 === e.selected;
                        },
                        // Contents
                        empty: function(e) {
                            // http://www.w3.org/TR/selectors/#empty-pseudo
                            // :empty is negated by element (1) or content nodes (text: 3; cdata: 4; entity ref: 5),
                            //   but not by others (comment: 8; processing instruction: 7; etc.)
                            // nodeType < 6 works because attributes (2) do not appear as children
                            for (e = e.firstChild; e; e = e.nextSibling) if (e.nodeType < 6) return !1;
                            return !0;
                        },
                        parent: function(e) {
                            return !C.pseudos.empty(e);
                        },
                        // Element/input types
                        header: function(e) {
                            return ve.test(e.nodeName);
                        },
                        input: function(e) {
                            return he.test(e.nodeName);
                        },
                        button: function(e) {
                            var t = e.nodeName.toLowerCase();
                            return "input" === t && "button" === e.type || "button" === t;
                        },
                        text: function(e) {
                            var t;
                            // Support: IE<8
                            // New HTML5 attribute values (e.g., "search") appear with elem.type === "text"
                            return "input" === e.nodeName.toLowerCase() && "text" === e.type && (null == (t = e.getAttribute("type")) || "text" === t.toLowerCase());
                        },
                        // Position-in-collection
                        first: c(function() {
                            return [ 0 ];
                        }),
                        last: c(function(e, t) {
                            return [ t - 1 ];
                        }),
                        eq: c(function(e, t, n) {
                            return [ n < 0 ? n + t : n ];
                        }),
                        even: c(function(e, t) {
                            var n = 0;
                            for (;n < t; n += 2) e.push(n);
                            return e;
                        }),
                        odd: c(function(e, t) {
                            var n = 1;
                            for (;n < t; n += 2) e.push(n);
                            return e;
                        }),
                        lt: c(function(e, t, n) {
                            var i = n < 0 ? n + t : n;
                            for (;--i >= 0; ) e.push(i);
                            return e;
                        }),
                        gt: c(function(e, t, n) {
                            var i = n < 0 ? n + t : n;
                            for (;++i < t; ) e.push(i);
                            return e;
                        })
                    }
                };
                C.pseudos.nth = C.pseudos.eq;
                // Add button/input type pseudos
                for (w in {
                    radio: !0,
                    checkbox: !0,
                    file: !0,
                    password: !0,
                    image: !0
                }) C.pseudos[w] = s(w);
                for (w in {
                    submit: !0,
                    reset: !0
                }) C.pseudos[w] = l(w);
                d.prototype = C.filters = C.pseudos;
                C.setFilters = new d();
                E = t.tokenize = function(e, n) {
                    var i, r, o, a, s, l, u, c = X[e + " "];
                    if (c) return n ? 0 : c.slice(0);
                    s = e;
                    l = [];
                    u = C.preFilter;
                    for (;s; ) {
                        // Comma and first run
                        if (!i || (r = le.exec(s))) {
                            if (r) // Don't consume trailing commas as valid
                            s = s.slice(r[0].length) || s;
                            l.push(o = []);
                        }
                        i = !1;
                        // Combinators
                        if (r = ue.exec(s)) {
                            i = r.shift();
                            o.push({
                                value: i,
                                // Cast descendant combinators to space
                                type: r[0].replace(se, " ")
                            });
                            s = s.slice(i.length);
                        }
                        // Filters
                        for (a in C.filter) if ((r = pe[a].exec(s)) && (!u[a] || (r = u[a](r)))) {
                            i = r.shift();
                            o.push({
                                value: i,
                                type: a,
                                matches: r
                            });
                            s = s.slice(i.length);
                        }
                        if (!i) break;
                    }
                    // Return the length of the invalid excess
                    // if we're just parsing
                    // Otherwise, throw an error or return tokens
                    // Cache the tokens
                    return n ? s.length : s ? t.error(e) : X(e, l).slice(0);
                };
                A = t.compile = function(e, t) {
                    var n, i = [], r = [], o = B[e + " "];
                    if (!o) {
                        // Generate a function of recursive functions that can be used to check each element
                        if (!t) t = E(e);
                        n = t.length;
                        for (;n--; ) {
                            o = b(t[n]);
                            if (o[R]) i.push(o); else r.push(o);
                        }
                        // Cache the compiled function
                        o = B(e, x(r, i));
                        // Save selector and tokenization
                        o.selector = e;
                    }
                    return o;
                };
                /**
 * A low-level selection function that works with Sizzle's compiled
 *  selector functions
 * @param {String|Function} selector A selector or a pre-compiled
 *  selector function built with Sizzle.compile
 * @param {Element} context
 * @param {Array} [results]
 * @param {Array} [seed] A set of elements to match against
 */
                P = t.select = function(e, t, n, i) {
                    var r, o, a, s, l, u = "function" === typeof e && e, c = !i && E(e = u.selector || e);
                    n = n || [];
                    // Try to minimize operations if there is only one selector in the list and no seed
                    // (the latter of which guarantees us context)
                    if (1 === c.length) {
                        // Reduce context if the leading compound selector is an ID
                        o = c[0] = c[0].slice(0);
                        if (o.length > 2 && "ID" === (a = o[0]).type && 9 === t.nodeType && L && C.relative[o[1].type]) {
                            t = (C.find.ID(a.matches[0].replace(be, xe), t) || [])[0];
                            if (!t) return n; else if (u) t = t.parentNode;
                            e = e.slice(o.shift().value.length);
                        }
                        // Fetch a seed set for right-to-left matching
                        r = pe.needsContext.test(e) ? 0 : o.length;
                        for (;r--; ) {
                            a = o[r];
                            // Abort if we hit a combinator
                            if (C.relative[s = a.type]) break;
                            if (l = C.find[s]) // Search, expanding context for leading sibling combinators
                            if (i = l(a.matches[0].replace(be, xe), ye.test(o[0].type) && f(t.parentNode) || t)) {
                                // If seed is empty or no tokens remain, we can return early
                                o.splice(r, 1);
                                e = i.length && p(o);
                                if (!e) {
                                    J.apply(n, i);
                                    return n;
                                }
                                break;
                            }
                        }
                    }
                    // Compile and execute a filtering function if one is not provided
                    // Provide `match` to avoid retokenization if we modified the selector above
                    (u || A(e, c))(i, t, !L, n, !t || ye.test(e) && f(t.parentNode) || t);
                    return n;
                };
                // One-time assignments
                // Sort stability
                T.sortStable = R.split("").sort(Y).join("") === R;
                // Support: Chrome 14-35+
                // Always assume duplicates if they aren't passed to the comparison function
                T.detectDuplicates = !!N;
                // Initialize against the default document
                q();
                // Support: Webkit<537.32 - Safari 6.0.3/Chrome 25 (fixed in Chrome 27)
                // Detached nodes confoundingly follow *each other*
                T.sortDetached = r(function(e) {
                    // Should return 1, but returns 4 (following)
                    return 1 & e.compareDocumentPosition(j.createElement("fieldset"));
                });
                // Support: IE<8
                // Prevent attribute/property "interpolation"
                // https://msdn.microsoft.com/en-us/library/ms536429%28VS.85%29.aspx
                if (!r(function(e) {
                    e.innerHTML = "<a href='#'></a>";
                    return "#" === e.firstChild.getAttribute("href");
                })) o("type|href|height|width", function(e, t, n) {
                    if (!n) return e.getAttribute(t, "type" === t.toLowerCase() ? 1 : 2);
                });
                // Support: IE<9
                // Use defaultValue in place of getAttribute("value")
                if (!T.attributes || !r(function(e) {
                    e.innerHTML = "<input/>";
                    e.firstChild.setAttribute("value", "");
                    return "" === e.firstChild.getAttribute("value");
                })) o("value", function(e, t, n) {
                    if (!n && "input" === e.nodeName.toLowerCase()) return e.defaultValue;
                });
                // Support: IE<9
                // Use getAttributeNode to fetch booleans when getAttribute lies
                if (!r(function(e) {
                    return null == e.getAttribute("disabled");
                })) o(te, function(e, t, n) {
                    var i;
                    if (!n) return !0 === e[t] ? t.toLowerCase() : (i = e.getAttributeNode(t)) && i.specified ? i.value : null;
                });
                return t;
            }(n);
            be.find = ke;
            be.expr = ke.selectors;
            // Deprecated
            be.expr[":"] = be.expr.pseudos;
            be.uniqueSort = be.unique = ke.uniqueSort;
            be.text = ke.getText;
            be.isXMLDoc = ke.isXML;
            be.contains = ke.contains;
            be.escapeSelector = ke.escape;
            var Se = function(e, t, n) {
                var i = [], r = n !== undefined;
                for (;(e = e[t]) && 9 !== e.nodeType; ) if (1 === e.nodeType) {
                    if (r && be(e).is(n)) break;
                    i.push(e);
                }
                return i;
            };
            var Ee = function(e, t) {
                var n = [];
                for (;e; e = e.nextSibling) if (1 === e.nodeType && e !== t) n.push(e);
                return n;
            };
            var Ae = be.expr.match.needsContext;
            var Pe = /^<([a-z][^\/\0>:\x20\t\r\n\f]*)[\x20\t\r\n\f]*\/?>(?:<\/\1>|)$/i;
            var De = /^.[^:#\[\.,]*$/;
            be.filter = function(e, t, n) {
                var i = t[0];
                if (n) e = ":not(" + e + ")";
                if (1 === t.length && 1 === i.nodeType) return be.find.matchesSelector(i, e) ? [ i ] : [];
                return be.find.matches(e, be.grep(t, function(e) {
                    return 1 === e.nodeType;
                }));
            };
            be.fn.extend({
                find: function(e) {
                    var t, n, i = this.length, r = this;
                    if ("string" !== typeof e) return this.pushStack(be(e).filter(function() {
                        for (t = 0; t < i; t++) if (be.contains(r[t], this)) return !0;
                    }));
                    n = this.pushStack([]);
                    for (t = 0; t < i; t++) be.find(e, r[t], n);
                    return i > 1 ? be.uniqueSort(n) : n;
                },
                filter: function(e) {
                    return this.pushStack(u(this, e || [], !1));
                },
                not: function(e) {
                    return this.pushStack(u(this, e || [], !0));
                },
                is: function(e) {
                    // If this is a positional/relative selector, check membership in the returned set
                    // so $("p:first").is("p:last") won't return true for a doc with two "p".
                    return !!u(this, "string" === typeof e && Ae.test(e) ? be(e) : e || [], !1).length;
                }
            });
            // Initialize a jQuery object
            // A central reference to the root jQuery(document)
            var Oe, // A simple way to check for HTML strings
            // Prioritize #id over <tag> to avoid XSS via location.hash (#9521)
            // Strict HTML recognition (#11290: must start with <)
            // Shortcut simple #id case for speed
            Ne = /^(?:\s*(<[\w\W]+>)[^>]*|#([\w-]+))$/;
            // Give the init function the jQuery prototype for later instantiation
            (be.fn.init = function(e, t, n) {
                var i, r;
                // HANDLE: $(""), $(null), $(undefined), $(false)
                if (!e) return this;
                // Method init() accepts an alternate rootjQuery
                // so migrate can support jQuery.sub (gh-2101)
                n = n || Oe;
                // Handle HTML strings
                if ("string" === typeof e) {
                    if ("<" === e[0] && ">" === e[e.length - 1] && e.length >= 3) // Assume that strings that start and end with <> are HTML and skip the regex check
                    i = [ null, e, null ]; else i = Ne.exec(e);
                    // Match html or make sure no context is specified for #id
                    if (i && (i[1] || !t)) // HANDLE: $(html) -> $(array)
                    if (i[1]) {
                        t = t instanceof be ? t[0] : t;
                        // Option to run scripts is true for back-compat
                        // Intentionally let the error be thrown if parseHTML is not present
                        be.merge(this, be.parseHTML(i[1], t && t.nodeType ? t.ownerDocument || t : ae, !0));
                        // HANDLE: $(html, props)
                        if (Pe.test(i[1]) && be.isPlainObject(t)) for (i in t) // Properties of context are called as methods if possible
                        if (be.isFunction(this[i])) this[i](t[i]); else this.attr(i, t[i]);
                        return this;
                    } else {
                        r = ae.getElementById(i[2]);
                        if (r) {
                            // Inject the element directly into the jQuery object
                            this[0] = r;
                            this.length = 1;
                        }
                        return this;
                    } else if (!t || t.jquery) return (t || n).find(e); else return this.constructor(t).find(e);
                } else if (e.nodeType) {
                    this[0] = e;
                    this.length = 1;
                    return this;
                } else if (be.isFunction(e)) // Execute immediately if ready is not present
                return n.ready !== undefined ? n.ready(e) : e(be);
                return be.makeArray(e, this);
            }).prototype = be.fn;
            // Initialize central reference
            Oe = be(ae);
            var qe = /^(?:parents|prev(?:Until|All))/, // Methods guaranteed to produce a unique set when starting from a unique set
            je = {
                children: !0,
                contents: !0,
                next: !0,
                prev: !0
            };
            be.fn.extend({
                has: function(e) {
                    var t = be(e, this), n = t.length;
                    return this.filter(function() {
                        var e = 0;
                        for (;e < n; e++) if (be.contains(this, t[e])) return !0;
                    });
                },
                closest: function(e, t) {
                    var n, i = 0, r = this.length, o = [], a = "string" !== typeof e && be(e);
                    // Positional selectors never match, since there's no _selection_ context
                    if (!Ae.test(e)) for (;i < r; i++) for (n = this[i]; n && n !== t; n = n.parentNode) // Always skip document fragments
                    if (n.nodeType < 11 && (a ? a.index(n) > -1 : // Don't pass non-elements to Sizzle
                    1 === n.nodeType && be.find.matchesSelector(n, e))) {
                        o.push(n);
                        break;
                    }
                    return this.pushStack(o.length > 1 ? be.uniqueSort(o) : o);
                },
                // Determine the position of an element within the set
                index: function(e) {
                    // No argument, return index in parent
                    if (!e) return this[0] && this[0].parentNode ? this.first().prevAll().length : -1;
                    // Index in selector
                    if ("string" === typeof e) return fe.call(be(e), this[0]);
                    // Locate the position of the desired element
                    // If it receives a jQuery object, the first element is used
                    return fe.call(this, e.jquery ? e[0] : e);
                },
                add: function(e, t) {
                    return this.pushStack(be.uniqueSort(be.merge(this.get(), be(e, t))));
                },
                addBack: function(e) {
                    return this.add(null == e ? this.prevObject : this.prevObject.filter(e));
                }
            });
            be.each({
                parent: function(e) {
                    var t = e.parentNode;
                    return t && 11 !== t.nodeType ? t : null;
                },
                parents: function(e) {
                    return Se(e, "parentNode");
                },
                parentsUntil: function(e, t, n) {
                    return Se(e, "parentNode", n);
                },
                next: function(e) {
                    return c(e, "nextSibling");
                },
                prev: function(e) {
                    return c(e, "previousSibling");
                },
                nextAll: function(e) {
                    return Se(e, "nextSibling");
                },
                prevAll: function(e) {
                    return Se(e, "previousSibling");
                },
                nextUntil: function(e, t, n) {
                    return Se(e, "nextSibling", n);
                },
                prevUntil: function(e, t, n) {
                    return Se(e, "previousSibling", n);
                },
                siblings: function(e) {
                    return Ee((e.parentNode || {}).firstChild, e);
                },
                children: function(e) {
                    return Ee(e.firstChild);
                },
                contents: function(e) {
                    if (l(e, "iframe")) return e.contentDocument;
                    // Support: IE 9 - 11 only, iOS 7 only, Android Browser <=4.3 only
                    // Treat the template element as a regular one in browsers that
                    // don't support it.
                    if (l(e, "template")) e = e.content || e;
                    return be.merge([], e.childNodes);
                }
            }, function(e, t) {
                be.fn[e] = function(n, i) {
                    var r = be.map(this, t, n);
                    if ("Until" !== e.slice(-5)) i = n;
                    if (i && "string" === typeof i) r = be.filter(i, r);
                    if (this.length > 1) {
                        // Remove duplicates
                        if (!je[e]) be.uniqueSort(r);
                        // Reverse order for parents* and prev-derivatives
                        if (qe.test(e)) r.reverse();
                    }
                    return this.pushStack(r);
                };
            });
            var Me = /[^\x20\t\r\n\f]+/g;
            /*
 * Create a callback list using the following parameters:
 *
 *	options: an optional list of space-separated options that will change how
 *			the callback list behaves or a more traditional option object
 *
 * By default a callback list will act like an event callback list and can be
 * "fired" multiple times.
 *
 * Possible options:
 *
 *	once:			will ensure the callback list can only be fired once (like a Deferred)
 *
 *	memory:			will keep track of previous values and will call any callback added
 *					after the list has been fired right away with the latest "memorized"
 *					values (like a Deferred)
 *
 *	unique:			will ensure a callback can only be added once (no duplicate in the list)
 *
 *	stopOnFalse:	interrupt callings when a callback returns false
 *
 */
            be.Callbacks = function(e) {
                // Convert options from String-formatted to Object-formatted if needed
                // (we check in cache first)
                e = "string" === typeof e ? f(e) : be.extend({}, e);
                var // Flag to know if list is currently firing
                t, // Last fire value for non-forgettable lists
                n, // Flag to know if list was already fired
                i, // Flag to prevent firing
                r, // Actual callback list
                o = [], // Queue of execution data for repeatable lists
                a = [], // Index of currently firing callback (modified by add/remove as needed)
                s = -1, // Fire callbacks
                l = function() {
                    // Enforce single-firing
                    r = r || e.once;
                    // Execute callbacks for all pending executions,
                    // respecting firingIndex overrides and runtime changes
                    i = t = !0;
                    for (;a.length; s = -1) {
                        n = a.shift();
                        for (;++s < o.length; ) // Run callback and check for early termination
                        if (!1 === o[s].apply(n[0], n[1]) && e.stopOnFalse) {
                            // Jump to end and forget the data so .add doesn't re-fire
                            s = o.length;
                            n = !1;
                        }
                    }
                    // Forget the data if we're done with it
                    if (!e.memory) n = !1;
                    t = !1;
                    // Clean up if we're done firing for good
                    if (r) // Keep an empty list if we have data for future add calls
                    if (n) o = []; else o = "";
                }, // Actual Callbacks object
                u = {
                    // Add a callback or a collection of callbacks to the list
                    add: function() {
                        if (o) {
                            // If we have memory from a past run, we should fire after adding
                            if (n && !t) {
                                s = o.length - 1;
                                a.push(n);
                            }
                            !function i(t) {
                                be.each(t, function(t, n) {
                                    if (be.isFunction(n)) {
                                        if (!e.unique || !u.has(n)) o.push(n);
                                    } else if (n && n.length && "string" !== be.type(n)) // Inspect recursively
                                    i(n);
                                });
                            }(arguments);
                            if (n && !t) l();
                        }
                        return this;
                    },
                    // Remove a callback from the list
                    remove: function() {
                        be.each(arguments, function(e, t) {
                            var n;
                            for (;(n = be.inArray(t, o, n)) > -1; ) {
                                o.splice(n, 1);
                                // Handle firing indexes
                                if (n <= s) s--;
                            }
                        });
                        return this;
                    },
                    // Check if a given callback is in the list.
                    // If no argument is given, return whether or not list has callbacks attached.
                    has: function(e) {
                        return e ? be.inArray(e, o) > -1 : o.length > 0;
                    },
                    // Remove all callbacks from the list
                    empty: function() {
                        if (o) o = [];
                        return this;
                    },
                    // Disable .fire and .add
                    // Abort any current/pending executions
                    // Clear all callbacks and values
                    disable: function() {
                        r = a = [];
                        o = n = "";
                        return this;
                    },
                    disabled: function() {
                        return !o;
                    },
                    // Disable .fire
                    // Also disable .add unless we have memory (since it would have no effect)
                    // Abort any pending executions
                    lock: function() {
                        r = a = [];
                        if (!n && !t) o = n = "";
                        return this;
                    },
                    locked: function() {
                        return !!r;
                    },
                    // Call all callbacks with the given context and arguments
                    fireWith: function(e, n) {
                        if (!r) {
                            n = n || [];
                            n = [ e, n.slice ? n.slice() : n ];
                            a.push(n);
                            if (!t) l();
                        }
                        return this;
                    },
                    // Call all the callbacks with the given arguments
                    fire: function() {
                        u.fireWith(this, arguments);
                        return this;
                    },
                    // To know if the callbacks have already been called at least once
                    fired: function() {
                        return !!i;
                    }
                };
                return u;
            };
            be.extend({
                Deferred: function(e) {
                    var t = [ // action, add listener, callbacks,
                    // ... .then handlers, argument index, [final state]
                    [ "notify", "progress", be.Callbacks("memory"), be.Callbacks("memory"), 2 ], [ "resolve", "done", be.Callbacks("once memory"), be.Callbacks("once memory"), 0, "resolved" ], [ "reject", "fail", be.Callbacks("once memory"), be.Callbacks("once memory"), 1, "rejected" ] ], i = "pending", r = {
                        state: function() {
                            return i;
                        },
                        always: function() {
                            o.done(arguments).fail(arguments);
                            return this;
                        },
                        catch: function(e) {
                            return r.then(null, e);
                        },
                        // Keep pipe for back-compat
                        pipe: function() {
                            var e = arguments;
                            return be.Deferred(function(n) {
                                be.each(t, function(t, i) {
                                    // Map tuples (progress, done, fail) to arguments (done, fail, progress)
                                    var r = be.isFunction(e[i[4]]) && e[i[4]];
                                    // deferred.progress(function() { bind to newDefer or newDefer.notify })
                                    // deferred.done(function() { bind to newDefer or newDefer.resolve })
                                    // deferred.fail(function() { bind to newDefer or newDefer.reject })
                                    o[i[1]](function() {
                                        var e = r && r.apply(this, arguments);
                                        if (e && be.isFunction(e.promise)) e.promise().progress(n.notify).done(n.resolve).fail(n.reject); else n[i[0] + "With"](this, r ? [ e ] : arguments);
                                    });
                                });
                                e = null;
                            }).promise();
                        },
                        then: function(e, i, r) {
                            function o(e, t, i, r) {
                                return function() {
                                    var s = this, l = arguments, u = function() {
                                        var n, u;
                                        // Support: Promises/A+ section 2.3.3.3.3
                                        // https://promisesaplus.com/#point-59
                                        // Ignore double-resolution attempts
                                        if (e < a) return;
                                        n = i.apply(s, l);
                                        // Support: Promises/A+ section 2.3.1
                                        // https://promisesaplus.com/#point-48
                                        if (n === t.promise()) throw new TypeError("Thenable self-resolution");
                                        // Support: Promises/A+ sections 2.3.3.1, 3.5
                                        // https://promisesaplus.com/#point-54
                                        // https://promisesaplus.com/#point-75
                                        // Retrieve `then` only once
                                        u = n && (// Support: Promises/A+ section 2.3.4
                                        // https://promisesaplus.com/#point-64
                                        // Only check objects and functions for thenability
                                        "object" === typeof n || "function" === typeof n) && n.then;
                                        // Handle a returned thenable
                                        if (be.isFunction(u)) // Special processors (notify) just wait for resolution
                                        if (r) u.call(n, o(a, t, d, r), o(a, t, p, r)); else {
                                            // ...and disregard older resolution values
                                            a++;
                                            u.call(n, o(a, t, d, r), o(a, t, p, r), o(a, t, d, t.notifyWith));
                                        } else {
                                            // Only substitute handlers pass on context
                                            // and multiple values (non-spec behavior)
                                            if (i !== d) {
                                                s = undefined;
                                                l = [ n ];
                                            }
                                            // Process the value(s)
                                            // Default process is resolve
                                            (r || t.resolveWith)(s, l);
                                        }
                                    }, // Only normal processors (resolve) catch and reject exceptions
                                    c = r ? u : function() {
                                        try {
                                            u();
                                        } catch (n) {
                                            if (be.Deferred.exceptionHook) be.Deferred.exceptionHook(n, c.stackTrace);
                                            // Support: Promises/A+ section 2.3.3.3.4.1
                                            // https://promisesaplus.com/#point-61
                                            // Ignore post-resolution exceptions
                                            if (e + 1 >= a) {
                                                // Only substitute handlers pass on context
                                                // and multiple values (non-spec behavior)
                                                if (i !== p) {
                                                    s = undefined;
                                                    l = [ n ];
                                                }
                                                t.rejectWith(s, l);
                                            }
                                        }
                                    };
                                    // Support: Promises/A+ section 2.3.3.3.1
                                    // https://promisesaplus.com/#point-57
                                    // Re-resolve promises immediately to dodge false rejection from
                                    // subsequent errors
                                    if (e) c(); else {
                                        // Call an optional hook to record the stack, in case of exception
                                        // since it's otherwise lost when execution goes async
                                        if (be.Deferred.getStackHook) c.stackTrace = be.Deferred.getStackHook();
                                        n.setTimeout(c);
                                    }
                                };
                            }
                            var a = 0;
                            return be.Deferred(function(n) {
                                // progress_handlers.add( ... )
                                t[0][3].add(o(0, n, be.isFunction(r) ? r : d, n.notifyWith));
                                // fulfilled_handlers.add( ... )
                                t[1][3].add(o(0, n, be.isFunction(e) ? e : d));
                                // rejected_handlers.add( ... )
                                t[2][3].add(o(0, n, be.isFunction(i) ? i : p));
                            }).promise();
                        },
                        // Get a promise for this deferred
                        // If obj is provided, the promise aspect is added to the object
                        promise: function(e) {
                            return null != e ? be.extend(e, r) : r;
                        }
                    }, o = {};
                    // Add list-specific methods
                    be.each(t, function(e, n) {
                        var a = n[2], s = n[5];
                        // promise.progress = list.add
                        // promise.done = list.add
                        // promise.fail = list.add
                        r[n[1]] = a.add;
                        // Handle state
                        if (s) a.add(function() {
                            // state = "resolved" (i.e., fulfilled)
                            // state = "rejected"
                            i = s;
                        }, // rejected_callbacks.disable
                        // fulfilled_callbacks.disable
                        t[3 - e][2].disable, // progress_callbacks.lock
                        t[0][2].lock);
                        // progress_handlers.fire
                        // fulfilled_handlers.fire
                        // rejected_handlers.fire
                        a.add(n[3].fire);
                        // deferred.notify = function() { deferred.notifyWith(...) }
                        // deferred.resolve = function() { deferred.resolveWith(...) }
                        // deferred.reject = function() { deferred.rejectWith(...) }
                        o[n[0]] = function() {
                            o[n[0] + "With"](this === o ? undefined : this, arguments);
                            return this;
                        };
                        // deferred.notifyWith = list.fireWith
                        // deferred.resolveWith = list.fireWith
                        // deferred.rejectWith = list.fireWith
                        o[n[0] + "With"] = a.fireWith;
                    });
                    // Make the deferred a promise
                    r.promise(o);
                    // Call given func if any
                    if (e) e.call(o, o);
                    // All done!
                    return o;
                },
                // Deferred helper
                when: function(e) {
                    var // count of uncompleted subordinates
                    t = arguments.length, // count of unprocessed arguments
                    n = t, // subordinate fulfillment data
                    i = Array(n), r = le.call(arguments), // the master Deferred
                    o = be.Deferred(), // subordinate callback factory
                    a = function(e) {
                        return function(n) {
                            i[e] = this;
                            r[e] = arguments.length > 1 ? le.call(arguments) : n;
                            if (!--t) o.resolveWith(i, r);
                        };
                    };
                    // Single- and empty arguments are adopted like Promise.resolve
                    if (t <= 1) {
                        h(e, o.done(a(n)).resolve, o.reject, !t);
                        // Use .then() to unwrap secondary thenables (cf. gh-3000)
                        if ("pending" === o.state() || be.isFunction(r[n] && r[n].then)) return o.then();
                    }
                    // Multiple arguments are aggregated like Promise.all array elements
                    for (;n--; ) h(r[n], a(n), o.reject);
                    return o.promise();
                }
            });
            // These usually indicate a programmer mistake during development,
            // warn about them ASAP rather than swallowing them by default.
            var Le = /^(Eval|Internal|Range|Reference|Syntax|Type|URI)Error$/;
            be.Deferred.exceptionHook = function(e, t) {
                // Support: IE 8 - 9 only
                // Console exists when dev tools are open, which can happen at any time
                if (n.console && n.console.warn && e && Le.test(e.name)) n.console.warn("jQuery.Deferred exception: " + e.message, e.stack, t);
            };
            be.readyException = function(e) {
                n.setTimeout(function() {
                    throw e;
                });
            };
            // The deferred used on DOM ready
            var Ie = be.Deferred();
            be.fn.ready = function(e) {
                Ie.then(e)["catch"](function(e) {
                    be.readyException(e);
                });
                return this;
            };
            be.extend({
                // Is the DOM ready to be used? Set to true once it occurs.
                isReady: !1,
                // A counter to track how many items to wait for before
                // the ready event fires. See #6781
                readyWait: 1,
                // Handle when the DOM is ready
                ready: function(e) {
                    // Abort if there are pending holds or we're already ready
                    if (!0 === e ? --be.readyWait : be.isReady) return;
                    // Remember that the DOM is ready
                    be.isReady = !0;
                    // If a normal DOM Ready event fired, decrement, and wait if need be
                    if (!0 !== e && --be.readyWait > 0) return;
                    // If there are functions bound, to execute
                    Ie.resolveWith(ae, [ be ]);
                }
            });
            be.ready.then = Ie.then;
            // Catch cases where $(document).ready() is called
            // after the browser event has already occurred.
            // Support: IE <=9 - 10 only
            // Older IE sometimes signals "interactive" too soon
            if ("complete" === ae.readyState || "loading" !== ae.readyState && !ae.documentElement.doScroll) // Handle it asynchronously to allow scripts the opportunity to delay ready
            n.setTimeout(be.ready); else {
                // Use the handy event callback
                ae.addEventListener("DOMContentLoaded", v);
                // A fallback to window.onload, that will always work
                n.addEventListener("load", v);
            }
            // Multifunctional method to get and set values of a collection
            // The value/s can optionally be executed if it's a function
            var He = function(e, t, n, i, r, o, a) {
                var s = 0, l = e.length, u = null == n;
                // Sets many values
                if ("object" === be.type(n)) {
                    r = !0;
                    for (s in n) He(e, t, s, n[s], !0, o, a);
                } else if (i !== undefined) {
                    r = !0;
                    if (!be.isFunction(i)) a = !0;
                    if (u) // Bulk operations run against the entire set
                    if (a) {
                        t.call(e, i);
                        t = null;
                    } else {
                        u = t;
                        t = function(e, t, n) {
                            return u.call(be(e), n);
                        };
                    }
                    if (t) for (;s < l; s++) t(e[s], n, a ? i : i.call(e[s], s, t(e[s], n)));
                }
                if (r) return e;
                // Gets
                if (u) return t.call(e);
                return l ? t(e[0], n) : o;
            };
            var _e = function(e) {
                // Accepts only:
                //  - Node
                //    - Node.ELEMENT_NODE
                //    - Node.DOCUMENT_NODE
                //  - Object
                //    - Any
                return 1 === e.nodeType || 9 === e.nodeType || !+e.nodeType;
            };
            g.uid = 1;
            g.prototype = {
                cache: function(e) {
                    // Check if the owner object already has a cache
                    var t = e[this.expando];
                    // If not, create one
                    if (!t) {
                        t = {};
                        // We can accept data for non-element nodes in modern browsers,
                        // but we should not, see #8335.
                        // Always return an empty object.
                        if (_e(e)) // If it is a node unlikely to be stringify-ed or looped over
                        // use plain assignment
                        if (e.nodeType) e[this.expando] = t; else Object.defineProperty(e, this.expando, {
                            value: t,
                            configurable: !0
                        });
                    }
                    return t;
                },
                set: function(e, t, n) {
                    var i, r = this.cache(e);
                    // Handle: [ owner, key, value ] args
                    // Always use camelCase key (gh-2257)
                    if ("string" === typeof t) r[be.camelCase(t)] = n; else // Copy the properties one-by-one to the cache object
                    for (i in t) r[be.camelCase(i)] = t[i];
                    return r;
                },
                get: function(e, t) {
                    // Always use camelCase key (gh-2257)
                    return t === undefined ? this.cache(e) : e[this.expando] && e[this.expando][be.camelCase(t)];
                },
                access: function(e, t, n) {
                    // In cases where either:
                    //
                    //   1. No key was specified
                    //   2. A string key was specified, but no value provided
                    //
                    // Take the "read" path and allow the get method to determine
                    // which value to return, respectively either:
                    //
                    //   1. The entire cache object
                    //   2. The data stored at the key
                    //
                    if (t === undefined || t && "string" === typeof t && n === undefined) return this.get(e, t);
                    // When the key is not a string, or both a key and value
                    // are specified, set or extend (existing objects) with either:
                    //
                    //   1. An object of properties
                    //   2. A key and value
                    //
                    this.set(e, t, n);
                    // Since the "set" path can have two possible entry points
                    // return the expected data based on which path was taken[*]
                    return n !== undefined ? n : t;
                },
                remove: function(e, t) {
                    var n, i = e[this.expando];
                    if (i === undefined) return;
                    if (t !== undefined) {
                        // Support array or space separated string of keys
                        if (Array.isArray(t)) // If key is an array of keys...
                        // We always set camelCase keys, so remove that.
                        t = t.map(be.camelCase); else {
                            t = be.camelCase(t);
                            // If a key with the spaces exists, use it.
                            // Otherwise, create an array by matching non-whitespace
                            t = t in i ? [ t ] : t.match(Me) || [];
                        }
                        n = t.length;
                        for (;n--; ) delete i[t[n]];
                    }
                    // Remove the expando if there's no more data
                    if (t === undefined || be.isEmptyObject(i)) // Support: Chrome <=35 - 45
                    // Webkit & Blink performance suffers when deleting properties
                    // from DOM nodes, so set to undefined instead
                    // https://bugs.chromium.org/p/chromium/issues/detail?id=378607 (bug restricted)
                    if (e.nodeType) e[this.expando] = undefined; else delete e[this.expando];
                },
                hasData: function(e) {
                    var t = e[this.expando];
                    return t !== undefined && !be.isEmptyObject(t);
                }
            };
            var Fe = new g();
            var Re = new g();
            //	Implementation Summary
            //
            //	1. Enforce API surface and semantic compatibility with 1.9.x branch
            //	2. Improve the module's maintainability by reducing the storage
            //		paths to a single mechanism.
            //	3. Use the same single mechanism to support "private" and "user" data.
            //	4. _Never_ expose "private" data to user code (TODO: Drop _data, _removeData)
            //	5. Avoid exposing implementation details on user objects (eg. expando properties)
            //	6. Provide a clear path for implementation upgrade to WeakMap in 2014
            var We = /^(?:\{[\w\W]*\}|\[[\w\W]*\])$/, $e = /[A-Z]/g;
            be.extend({
                hasData: function(e) {
                    return Re.hasData(e) || Fe.hasData(e);
                },
                data: function(e, t, n) {
                    return Re.access(e, t, n);
                },
                removeData: function(e, t) {
                    Re.remove(e, t);
                },
                // TODO: Now that all calls to _data and _removeData have been replaced
                // with direct calls to dataPriv methods, these can be deprecated.
                _data: function(e, t, n) {
                    return Fe.access(e, t, n);
                },
                _removeData: function(e, t) {
                    Fe.remove(e, t);
                }
            });
            be.fn.extend({
                data: function(e, t) {
                    var n, i, r, o = this[0], a = o && o.attributes;
                    // Gets all values
                    if (e === undefined) {
                        if (this.length) {
                            r = Re.get(o);
                            if (1 === o.nodeType && !Fe.get(o, "hasDataAttrs")) {
                                n = a.length;
                                for (;n--; ) // Support: IE 11 only
                                // The attrs elements can be null (#14894)
                                if (a[n]) {
                                    i = a[n].name;
                                    if (0 === i.indexOf("data-")) {
                                        i = be.camelCase(i.slice(5));
                                        y(o, i, r[i]);
                                    }
                                }
                                Fe.set(o, "hasDataAttrs", !0);
                            }
                        }
                        return r;
                    }
                    // Sets multiple values
                    if ("object" === typeof e) return this.each(function() {
                        Re.set(this, e);
                    });
                    return He(this, function(t) {
                        var n;
                        // The calling jQuery object (element matches) is not empty
                        // (and therefore has an element appears at this[ 0 ]) and the
                        // `value` parameter was not undefined. An empty jQuery object
                        // will result in `undefined` for elem = this[ 0 ] which will
                        // throw an exception if an attempt to read a data cache is made.
                        if (o && t === undefined) {
                            // Attempt to get data from the cache
                            // The key will always be camelCased in Data
                            n = Re.get(o, e);
                            if (n !== undefined) return n;
                            // Attempt to "discover" the data in
                            // HTML5 custom data-* attrs
                            n = y(o, e);
                            if (n !== undefined) return n;
                            // We tried really hard, but the data doesn't exist.
                            return;
                        }
                        // Set the data...
                        this.each(function() {
                            // We always store the camelCased key
                            Re.set(this, e, t);
                        });
                    }, null, t, arguments.length > 1, null, !0);
                },
                removeData: function(e) {
                    return this.each(function() {
                        Re.remove(this, e);
                    });
                }
            });
            be.extend({
                queue: function(e, t, n) {
                    var i;
                    if (e) {
                        t = (t || "fx") + "queue";
                        i = Fe.get(e, t);
                        // Speed up dequeue by getting out quickly if this is just a lookup
                        if (n) if (!i || Array.isArray(n)) i = Fe.access(e, t, be.makeArray(n)); else i.push(n);
                        return i || [];
                    }
                },
                dequeue: function(e, t) {
                    t = t || "fx";
                    var n = be.queue(e, t), i = n.length, r = n.shift(), o = be._queueHooks(e, t), a = function() {
                        be.dequeue(e, t);
                    };
                    // If the fx queue is dequeued, always remove the progress sentinel
                    if ("inprogress" === r) {
                        r = n.shift();
                        i--;
                    }
                    if (r) {
                        // Add a progress sentinel to prevent the fx queue from being
                        // automatically dequeued
                        if ("fx" === t) n.unshift("inprogress");
                        // Clear up the last queue stop function
                        delete o.stop;
                        r.call(e, a, o);
                    }
                    if (!i && o) o.empty.fire();
                },
                // Not public - generate a queueHooks object, or return the current one
                _queueHooks: function(e, t) {
                    var n = t + "queueHooks";
                    return Fe.get(e, n) || Fe.access(e, n, {
                        empty: be.Callbacks("once memory").add(function() {
                            Fe.remove(e, [ t + "queue", n ]);
                        })
                    });
                }
            });
            be.fn.extend({
                queue: function(e, t) {
                    var n = 2;
                    if ("string" !== typeof e) {
                        t = e;
                        e = "fx";
                        n--;
                    }
                    if (arguments.length < n) return be.queue(this[0], e);
                    return t === undefined ? this : this.each(function() {
                        var n = be.queue(this, e, t);
                        // Ensure a hooks for this queue
                        be._queueHooks(this, e);
                        if ("fx" === e && "inprogress" !== n[0]) be.dequeue(this, e);
                    });
                },
                dequeue: function(e) {
                    return this.each(function() {
                        be.dequeue(this, e);
                    });
                },
                clearQueue: function(e) {
                    return this.queue(e || "fx", []);
                },
                // Get a promise resolved when queues of a certain type
                // are emptied (fx is the type by default)
                promise: function(e, t) {
                    var n, i = 1, r = be.Deferred(), o = this, a = this.length, s = function() {
                        if (!--i) r.resolveWith(o, [ o ]);
                    };
                    if ("string" !== typeof e) {
                        t = e;
                        e = undefined;
                    }
                    e = e || "fx";
                    for (;a--; ) {
                        n = Fe.get(o[a], e + "queueHooks");
                        if (n && n.empty) {
                            i++;
                            n.empty.add(s);
                        }
                    }
                    s();
                    return r.promise(t);
                }
            });
            var ze = /[+-]?(?:\d*\.|)\d+(?:[eE][+-]?\d+|)/.source;
            var Ve = new RegExp("^(?:([+-])=|)(" + ze + ")([a-z%]*)$", "i");
            var Xe = [ "Top", "Right", "Bottom", "Left" ];
            var Be = function(e, t) {
                // isHiddenWithinTree might be called from jQuery#filter function;
                // in that case, element will be second argument
                e = t || e;
                // Inline style trumps all
                // Otherwise, check computed style
                // Support: Firefox <=43 - 45
                // Disconnected elements can have computed display: none, so first confirm that elem is
                // in the document.
                return "none" === e.style.display || "" === e.style.display && be.contains(e.ownerDocument, e) && "none" === be.css(e, "display");
            };
            var Ye = function(e, t, n, i) {
                var r, o, a = {};
                // Remember the old values, and insert the new ones
                for (o in t) {
                    a[o] = e.style[o];
                    e.style[o] = t[o];
                }
                r = n.apply(e, i || []);
                // Revert the old values
                for (o in t) e.style[o] = a[o];
                return r;
            };
            var Qe = {};
            be.fn.extend({
                show: function() {
                    return w(this, !0);
                },
                hide: function() {
                    return w(this);
                },
                toggle: function(e) {
                    if ("boolean" === typeof e) return e ? this.show() : this.hide();
                    return this.each(function() {
                        if (Be(this)) be(this).show(); else be(this).hide();
                    });
                }
            });
            var Ue = /^(?:checkbox|radio)$/i;
            var Ge = /<([a-z][^\/\0>\x20\t\r\n\f]+)/i;
            var Ze = /^$|\/(?:java|ecma)script/i;
            // We have to close these tags to support XHTML (#13200)
            var Je = {
                // Support: IE <=9 only
                option: [ 1, "<select multiple='multiple'>", "</select>" ],
                // XHTML parsers do not magically insert elements in the
                // same way that tag soup parsers do. So we cannot shorten
                // this by omitting <tbody> or other required elements.
                thead: [ 1, "<table>", "</table>" ],
                col: [ 2, "<table><colgroup>", "</colgroup></table>" ],
                tr: [ 2, "<table><tbody>", "</tbody></table>" ],
                td: [ 3, "<table><tbody><tr>", "</tr></tbody></table>" ],
                _default: [ 0, "", "" ]
            };
            // Support: IE <=9 only
            Je.optgroup = Je.option;
            Je.tbody = Je.tfoot = Je.colgroup = Je.caption = Je.thead;
            Je.th = Je.td;
            var Ke = /<|&#?\w+;/;
            !function() {
                var e = ae.createDocumentFragment(), t = e.appendChild(ae.createElement("div")), n = ae.createElement("input");
                // Support: Android 4.0 - 4.3 only
                // Check state lost if the name is set (#11217)
                // Support: Windows Web Apps (WWA)
                // `name` and `type` must use .setAttribute for WWA (#14901)
                n.setAttribute("type", "radio");
                n.setAttribute("checked", "checked");
                n.setAttribute("name", "t");
                t.appendChild(n);
                // Support: Android <=4.1 only
                // Older WebKit doesn't clone checked state correctly in fragments
                me.checkClone = t.cloneNode(!0).cloneNode(!0).lastChild.checked;
                // Support: IE <=11 only
                // Make sure textarea (and checkbox) defaultValue is properly cloned
                t.innerHTML = "<textarea>x</textarea>";
                me.noCloneChecked = !!t.cloneNode(!0).lastChild.defaultValue;
            }();
            var et = ae.documentElement;
            var tt = /^key/, nt = /^(?:mouse|pointer|contextmenu|drag|drop)|click/, it = /^([^.]*)(?:\.(.+)|)/;
            /*
 * Helper functions for managing events -- not part of the public interface.
 * Props to Dean Edwards' addEvent library for many of the ideas.
 */
            be.event = {
                global: {},
                add: function(e, t, n, i, r) {
                    var o, a, s, l, u, c, f, d, p, h, v, g = Fe.get(e);
                    // Don't attach events to noData or text/comment nodes (but allow plain objects)
                    if (!g) return;
                    // Caller can pass in an object of custom data in lieu of the handler
                    if (n.handler) {
                        o = n;
                        n = o.handler;
                        r = o.selector;
                    }
                    // Ensure that invalid selectors throw exceptions at attach time
                    // Evaluate against documentElement in case elem is a non-element node (e.g., document)
                    if (r) be.find.matchesSelector(et, r);
                    // Make sure that the handler has a unique ID, used to find/remove it later
                    if (!n.guid) n.guid = be.guid++;
                    // Init the element's event structure and main handler, if this is the first
                    if (!(l = g.events)) l = g.events = {};
                    if (!(a = g.handle)) a = g.handle = function(t) {
                        // Discard the second event of a jQuery.event.trigger() and
                        // when an event is called after a page has unloaded
                        return "undefined" !== typeof be && be.event.triggered !== t.type ? be.event.dispatch.apply(e, arguments) : undefined;
                    };
                    // Handle multiple events separated by a space
                    t = (t || "").match(Me) || [ "" ];
                    u = t.length;
                    for (;u--; ) {
                        s = it.exec(t[u]) || [];
                        p = v = s[1];
                        h = (s[2] || "").split(".").sort();
                        // There *must* be a type, no attaching namespace-only handlers
                        if (!p) continue;
                        // If event changes its type, use the special event handlers for the changed type
                        f = be.event.special[p] || {};
                        // If selector defined, determine special event api type, otherwise given type
                        p = (r ? f.delegateType : f.bindType) || p;
                        // Update special based on newly reset type
                        f = be.event.special[p] || {};
                        // handleObj is passed to all event handlers
                        c = be.extend({
                            type: p,
                            origType: v,
                            data: i,
                            handler: n,
                            guid: n.guid,
                            selector: r,
                            needsContext: r && be.expr.match.needsContext.test(r),
                            namespace: h.join(".")
                        }, o);
                        // Init the event handler queue if we're the first
                        if (!(d = l[p])) {
                            d = l[p] = [];
                            d.delegateCount = 0;
                            // Only use addEventListener if the special events handler returns false
                            if (!f.setup || !1 === f.setup.call(e, i, h, a)) if (e.addEventListener) e.addEventListener(p, a);
                        }
                        if (f.add) {
                            f.add.call(e, c);
                            if (!c.handler.guid) c.handler.guid = n.guid;
                        }
                        // Add to the element's handler list, delegates in front
                        if (r) d.splice(d.delegateCount++, 0, c); else d.push(c);
                        // Keep track of which events have ever been used, for event optimization
                        be.event.global[p] = !0;
                    }
                },
                // Detach an event or set of events from an element
                remove: function(e, t, n, i, r) {
                    var o, a, s, l, u, c, f, d, p, h, v, g = Fe.hasData(e) && Fe.get(e);
                    if (!g || !(l = g.events)) return;
                    // Once for each type.namespace in types; type may be omitted
                    t = (t || "").match(Me) || [ "" ];
                    u = t.length;
                    for (;u--; ) {
                        s = it.exec(t[u]) || [];
                        p = v = s[1];
                        h = (s[2] || "").split(".").sort();
                        // Unbind all events (on this namespace, if provided) for the element
                        if (!p) {
                            for (p in l) be.event.remove(e, p + t[u], n, i, !0);
                            continue;
                        }
                        f = be.event.special[p] || {};
                        p = (i ? f.delegateType : f.bindType) || p;
                        d = l[p] || [];
                        s = s[2] && new RegExp("(^|\\.)" + h.join("\\.(?:.*\\.|)") + "(\\.|$)");
                        // Remove matching events
                        a = o = d.length;
                        for (;o--; ) {
                            c = d[o];
                            if ((r || v === c.origType) && (!n || n.guid === c.guid) && (!s || s.test(c.namespace)) && (!i || i === c.selector || "**" === i && c.selector)) {
                                d.splice(o, 1);
                                if (c.selector) d.delegateCount--;
                                if (f.remove) f.remove.call(e, c);
                            }
                        }
                        // Remove generic event handler if we removed something and no more handlers exist
                        // (avoids potential for endless recursion during removal of special event handlers)
                        if (a && !d.length) {
                            if (!f.teardown || !1 === f.teardown.call(e, h, g.handle)) be.removeEvent(e, p, g.handle);
                            delete l[p];
                        }
                    }
                    // Remove data and the expando if it's no longer used
                    if (be.isEmptyObject(l)) Fe.remove(e, "handle events");
                },
                dispatch: function(e) {
                    // Make a writable jQuery.Event from the native event object
                    var t = be.event.fix(e);
                    var n, i, r, o, a, s, l = new Array(arguments.length), u = (Fe.get(this, "events") || {})[t.type] || [], c = be.event.special[t.type] || {};
                    // Use the fix-ed jQuery.Event rather than the (read-only) native event
                    l[0] = t;
                    for (n = 1; n < arguments.length; n++) l[n] = arguments[n];
                    t.delegateTarget = this;
                    // Call the preDispatch hook for the mapped type, and let it bail if desired
                    if (c.preDispatch && !1 === c.preDispatch.call(this, t)) return;
                    // Determine handlers
                    s = be.event.handlers.call(this, t, u);
                    // Run delegates first; they may want to stop propagation beneath us
                    n = 0;
                    for (;(o = s[n++]) && !t.isPropagationStopped(); ) {
                        t.currentTarget = o.elem;
                        i = 0;
                        for (;(a = o.handlers[i++]) && !t.isImmediatePropagationStopped(); ) // Triggered event must either 1) have no namespace, or 2) have namespace(s)
                        // a subset or equal to those in the bound event (both can have no namespace).
                        if (!t.rnamespace || t.rnamespace.test(a.namespace)) {
                            t.handleObj = a;
                            t.data = a.data;
                            r = ((be.event.special[a.origType] || {}).handle || a.handler).apply(o.elem, l);
                            if (r !== undefined) if (!1 === (t.result = r)) {
                                t.preventDefault();
                                t.stopPropagation();
                            }
                        }
                    }
                    // Call the postDispatch hook for the mapped type
                    if (c.postDispatch) c.postDispatch.call(this, t);
                    return t.result;
                },
                handlers: function(e, t) {
                    var n, i, r, o, a, s = [], l = t.delegateCount, u = e.target;
                    // Find delegate handlers
                    if (l && // Support: IE <=9
                    // Black-hole SVG <use> instance trees (trac-13180)
                    u.nodeType && // Support: Firefox <=42
                    // Suppress spec-violating clicks indicating a non-primary pointer button (trac-3861)
                    // https://www.w3.org/TR/DOM-Level-3-Events/#event-type-click
                    // Support: IE 11 only
                    // ...but not arrow key "clicks" of radio inputs, which can have `button` -1 (gh-2343)
                    !("click" === e.type && e.button >= 1)) for (;u !== this; u = u.parentNode || this) // Don't check non-elements (#13208)
                    // Don't process clicks on disabled elements (#6911, #8165, #11382, #11764)
                    if (1 === u.nodeType && ("click" !== e.type || !0 !== u.disabled)) {
                        o = [];
                        a = {};
                        for (n = 0; n < l; n++) {
                            i = t[n];
                            // Don't conflict with Object.prototype properties (#13203)
                            r = i.selector + " ";
                            if (a[r] === undefined) a[r] = i.needsContext ? be(r, this).index(u) > -1 : be.find(r, this, null, [ u ]).length;
                            if (a[r]) o.push(i);
                        }
                        if (o.length) s.push({
                            elem: u,
                            handlers: o
                        });
                    }
                    // Add the remaining (directly-bound) handlers
                    u = this;
                    if (l < t.length) s.push({
                        elem: u,
                        handlers: t.slice(l)
                    });
                    return s;
                },
                addProp: function(e, t) {
                    Object.defineProperty(be.Event.prototype, e, {
                        enumerable: !0,
                        configurable: !0,
                        get: be.isFunction(t) ? function() {
                            if (this.originalEvent) return t(this.originalEvent);
                        } : function() {
                            if (this.originalEvent) return this.originalEvent[e];
                        },
                        set: function(t) {
                            Object.defineProperty(this, e, {
                                enumerable: !0,
                                configurable: !0,
                                writable: !0,
                                value: t
                            });
                        }
                    });
                },
                fix: function(e) {
                    return e[be.expando] ? e : new be.Event(e);
                },
                special: {
                    load: {
                        // Prevent triggered image.load events from bubbling to window.load
                        noBubble: !0
                    },
                    focus: {
                        // Fire native event if possible so blur/focus sequence is correct
                        trigger: function() {
                            if (this !== A() && this.focus) {
                                this.focus();
                                return !1;
                            }
                        },
                        delegateType: "focusin"
                    },
                    blur: {
                        trigger: function() {
                            if (this === A() && this.blur) {
                                this.blur();
                                return !1;
                            }
                        },
                        delegateType: "focusout"
                    },
                    click: {
                        // For checkbox, fire native event so checked state will be right
                        trigger: function() {
                            if ("checkbox" === this.type && this.click && l(this, "input")) {
                                this.click();
                                return !1;
                            }
                        },
                        // For cross-browser consistency, don't fire native .click() on links
                        _default: function(e) {
                            return l(e.target, "a");
                        }
                    },
                    beforeunload: {
                        postDispatch: function(e) {
                            // Support: Firefox 20+
                            // Firefox doesn't alert if the returnValue field is not set.
                            if (e.result !== undefined && e.originalEvent) e.originalEvent.returnValue = e.result;
                        }
                    }
                }
            };
            be.removeEvent = function(e, t, n) {
                // This "if" is needed for plain objects
                if (e.removeEventListener) e.removeEventListener(t, n);
            };
            be.Event = function(e, t) {
                // Allow instantiation without the 'new' keyword
                if (!(this instanceof be.Event)) return new be.Event(e, t);
                // Event object
                if (e && e.type) {
                    this.originalEvent = e;
                    this.type = e.type;
                    // Events bubbling up the document may have been marked as prevented
                    // by a handler lower down the tree; reflect the correct value.
                    this.isDefaultPrevented = e.defaultPrevented || e.defaultPrevented === undefined && // Support: Android <=2.3 only
                    !1 === e.returnValue ? S : E;
                    // Create target properties
                    // Support: Safari <=6 - 7 only
                    // Target should not be a text node (#504, #13143)
                    this.target = e.target && 3 === e.target.nodeType ? e.target.parentNode : e.target;
                    this.currentTarget = e.currentTarget;
                    this.relatedTarget = e.relatedTarget;
                } else this.type = e;
                // Put explicitly provided properties onto the event object
                if (t) be.extend(this, t);
                // Create a timestamp if incoming event doesn't have one
                this.timeStamp = e && e.timeStamp || be.now();
                // Mark it as fixed
                this[be.expando] = !0;
            };
            // jQuery.Event is based on DOM3 Events as specified by the ECMAScript Language Binding
            // https://www.w3.org/TR/2003/WD-DOM-Level-3-Events-20030331/ecma-script-binding.html
            be.Event.prototype = {
                constructor: be.Event,
                isDefaultPrevented: E,
                isPropagationStopped: E,
                isImmediatePropagationStopped: E,
                isSimulated: !1,
                preventDefault: function() {
                    var e = this.originalEvent;
                    this.isDefaultPrevented = S;
                    if (e && !this.isSimulated) e.preventDefault();
                },
                stopPropagation: function() {
                    var e = this.originalEvent;
                    this.isPropagationStopped = S;
                    if (e && !this.isSimulated) e.stopPropagation();
                },
                stopImmediatePropagation: function() {
                    var e = this.originalEvent;
                    this.isImmediatePropagationStopped = S;
                    if (e && !this.isSimulated) e.stopImmediatePropagation();
                    this.stopPropagation();
                }
            };
            // Includes all common event props including KeyEvent and MouseEvent specific props
            be.each({
                altKey: !0,
                bubbles: !0,
                cancelable: !0,
                changedTouches: !0,
                ctrlKey: !0,
                detail: !0,
                eventPhase: !0,
                metaKey: !0,
                pageX: !0,
                pageY: !0,
                shiftKey: !0,
                view: !0,
                char: !0,
                charCode: !0,
                key: !0,
                keyCode: !0,
                button: !0,
                buttons: !0,
                clientX: !0,
                clientY: !0,
                offsetX: !0,
                offsetY: !0,
                pointerId: !0,
                pointerType: !0,
                screenX: !0,
                screenY: !0,
                targetTouches: !0,
                toElement: !0,
                touches: !0,
                which: function(e) {
                    var t = e.button;
                    // Add which for key events
                    if (null == e.which && tt.test(e.type)) return null != e.charCode ? e.charCode : e.keyCode;
                    // Add which for click: 1 === left; 2 === middle; 3 === right
                    if (!e.which && t !== undefined && nt.test(e.type)) {
                        if (1 & t) return 1;
                        if (2 & t) return 3;
                        if (4 & t) return 2;
                        return 0;
                    }
                    return e.which;
                }
            }, be.event.addProp);
            // Create mouseenter/leave events using mouseover/out and event-time checks
            // so that event delegation works in jQuery.
            // Do the same for pointerenter/pointerleave and pointerover/pointerout
            //
            // Support: Safari 7 only
            // Safari sends mouseenter too often; see:
            // https://bugs.chromium.org/p/chromium/issues/detail?id=470258
            // for the description of the bug (it existed in older Chrome versions as well).
            be.each({
                mouseenter: "mouseover",
                mouseleave: "mouseout",
                pointerenter: "pointerover",
                pointerleave: "pointerout"
            }, function(e, t) {
                be.event.special[e] = {
                    delegateType: t,
                    bindType: t,
                    handle: function(e) {
                        var n, i = this, r = e.relatedTarget, o = e.handleObj;
                        // For mouseenter/leave call the handler if related is outside the target.
                        // NB: No relatedTarget if the mouse left/entered the browser window
                        if (!r || r !== i && !be.contains(i, r)) {
                            e.type = o.origType;
                            n = o.handler.apply(this, arguments);
                            e.type = t;
                        }
                        return n;
                    }
                };
            });
            be.fn.extend({
                on: function(e, t, n, i) {
                    return P(this, e, t, n, i);
                },
                one: function(e, t, n, i) {
                    return P(this, e, t, n, i, 1);
                },
                off: function(e, t, n) {
                    var i, r;
                    if (e && e.preventDefault && e.handleObj) {
                        // ( event )  dispatched jQuery.Event
                        i = e.handleObj;
                        be(e.delegateTarget).off(i.namespace ? i.origType + "." + i.namespace : i.origType, i.selector, i.handler);
                        return this;
                    }
                    if ("object" === typeof e) {
                        // ( types-object [, selector] )
                        for (r in e) this.off(r, t, e[r]);
                        return this;
                    }
                    if (!1 === t || "function" === typeof t) {
                        // ( types [, fn] )
                        n = t;
                        t = undefined;
                    }
                    if (!1 === n) n = E;
                    return this.each(function() {
                        be.event.remove(this, e, n, t);
                    });
                }
            });
            var /* eslint-disable max-len */
            // See https://github.com/eslint/eslint/issues/3229
            rt = /<(?!area|br|col|embed|hr|img|input|link|meta|param)(([a-z][^\/\0>\x20\t\r\n\f]*)[^>]*)\/>/gi, /* eslint-enable */
            // Support: IE <=10 - 11, Edge 12 - 13
            // In IE/Edge using regex groups here causes severe slowdowns.
            // See https://connect.microsoft.com/IE/feedback/details/1736512/
            ot = /<script|<style|<link/i, // checked="checked" or checked
            at = /checked\s*(?:[^=]|=\s*.checked.)/i, st = /^true\/(.*)/, lt = /^\s*<!(?:\[CDATA\[|--)|(?:\]\]|--)>\s*$/g;
            be.extend({
                htmlPrefilter: function(e) {
                    return e.replace(rt, "<$1></$2>");
                },
                clone: function(e, t, n) {
                    var i, r, o, a, s = e.cloneNode(!0), l = be.contains(e.ownerDocument, e);
                    // Fix IE cloning issues
                    if (!me.noCloneChecked && (1 === e.nodeType || 11 === e.nodeType) && !be.isXMLDoc(e)) {
                        // We eschew Sizzle here for performance reasons: https://jsperf.com/getall-vs-sizzle/2
                        a = T(s);
                        o = T(e);
                        for (i = 0, r = o.length; i < r; i++) j(o[i], a[i]);
                    }
                    // Copy the events from the original to the clone
                    if (t) if (n) {
                        o = o || T(e);
                        a = a || T(s);
                        for (i = 0, r = o.length; i < r; i++) q(o[i], a[i]);
                    } else q(e, s);
                    // Preserve script evaluation history
                    a = T(s, "script");
                    if (a.length > 0) C(a, !l && T(e, "script"));
                    // Return the cloned set
                    return s;
                },
                cleanData: function(e) {
                    var t, n, i, r = be.event.special, o = 0;
                    for (;(n = e[o]) !== undefined; o++) if (_e(n)) {
                        if (t = n[Fe.expando]) {
                            if (t.events) for (i in t.events) if (r[i]) be.event.remove(n, i); else be.removeEvent(n, i, t.handle);
                            // Support: Chrome <=35 - 45+
                            // Assign undefined instead of using delete, see Data#remove
                            n[Fe.expando] = undefined;
                        }
                        if (n[Re.expando]) // Support: Chrome <=35 - 45+
                        // Assign undefined instead of using delete, see Data#remove
                        n[Re.expando] = undefined;
                    }
                }
            });
            be.fn.extend({
                detach: function(e) {
                    return L(this, e, !0);
                },
                remove: function(e) {
                    return L(this, e);
                },
                text: function(e) {
                    return He(this, function(e) {
                        return e === undefined ? be.text(this) : this.empty().each(function() {
                            if (1 === this.nodeType || 11 === this.nodeType || 9 === this.nodeType) this.textContent = e;
                        });
                    }, null, e, arguments.length);
                },
                append: function() {
                    return M(this, arguments, function(e) {
                        if (1 === this.nodeType || 11 === this.nodeType || 9 === this.nodeType) {
                            D(this, e).appendChild(e);
                        }
                    });
                },
                prepend: function() {
                    return M(this, arguments, function(e) {
                        if (1 === this.nodeType || 11 === this.nodeType || 9 === this.nodeType) {
                            var t = D(this, e);
                            t.insertBefore(e, t.firstChild);
                        }
                    });
                },
                before: function() {
                    return M(this, arguments, function(e) {
                        if (this.parentNode) this.parentNode.insertBefore(e, this);
                    });
                },
                after: function() {
                    return M(this, arguments, function(e) {
                        if (this.parentNode) this.parentNode.insertBefore(e, this.nextSibling);
                    });
                },
                empty: function() {
                    var e, t = 0;
                    for (;null != (e = this[t]); t++) if (1 === e.nodeType) {
                        // Prevent memory leaks
                        be.cleanData(T(e, !1));
                        // Remove any remaining nodes
                        e.textContent = "";
                    }
                    return this;
                },
                clone: function(e, t) {
                    e = null == e ? !1 : e;
                    t = null == t ? e : t;
                    return this.map(function() {
                        return be.clone(this, e, t);
                    });
                },
                html: function(e) {
                    return He(this, function(e) {
                        var t = this[0] || {}, n = 0, i = this.length;
                        if (e === undefined && 1 === t.nodeType) return t.innerHTML;
                        // See if we can take a shortcut and just use innerHTML
                        if ("string" === typeof e && !ot.test(e) && !Je[(Ge.exec(e) || [ "", "" ])[1].toLowerCase()]) {
                            e = be.htmlPrefilter(e);
                            try {
                                for (;n < i; n++) {
                                    t = this[n] || {};
                                    // Remove element nodes and prevent memory leaks
                                    if (1 === t.nodeType) {
                                        be.cleanData(T(t, !1));
                                        t.innerHTML = e;
                                    }
                                }
                                t = 0;
                            } catch (r) {}
                        }
                        if (t) this.empty().append(e);
                    }, null, e, arguments.length);
                },
                replaceWith: function() {
                    var e = [];
                    // Make the changes, replacing each non-ignored context element with the new content
                    return M(this, arguments, function(t) {
                        var n = this.parentNode;
                        if (be.inArray(this, e) < 0) {
                            be.cleanData(T(this));
                            if (n) n.replaceChild(t, this);
                        }
                    }, e);
                }
            });
            be.each({
                appendTo: "append",
                prependTo: "prepend",
                insertBefore: "before",
                insertAfter: "after",
                replaceAll: "replaceWith"
            }, function(e, t) {
                be.fn[e] = function(e) {
                    var n, i = [], r = be(e), o = r.length - 1, a = 0;
                    for (;a <= o; a++) {
                        n = a === o ? this : this.clone(!0);
                        be(r[a])[t](n);
                        // Support: Android <=4.0 only, PhantomJS 1 only
                        // .get() because push.apply(_, arraylike) throws on ancient WebKit
                        ce.apply(i, n.get());
                    }
                    return this.pushStack(i);
                };
            });
            var ut = /^margin/;
            var ct = new RegExp("^(" + ze + ")(?!px)[a-z%]+$", "i");
            var ft = function(e) {
                // Support: IE <=11 only, Firefox <=30 (#15098, #14150)
                // IE throws on elements created in popups
                // FF meanwhile throws on frame elements through "defaultView.getComputedStyle"
                var t = e.ownerDocument.defaultView;
                if (!t || !t.opener) t = n;
                return t.getComputedStyle(e);
            };
            !function() {
                // Executing both pixelPosition & boxSizingReliable tests require only one layout
                // so they're executed at the same time to save the second computation.
                function e() {
                    // This is a singleton, we need to execute it only once
                    if (!s) return;
                    s.style.cssText = "box-sizing:border-box;" + "position:relative;display:block;" + "margin:auto;border:1px;padding:1px;" + "top:1%;width:50%";
                    s.innerHTML = "";
                    et.appendChild(a);
                    var e = n.getComputedStyle(s);
                    t = "1%" !== e.top;
                    // Support: Android 4.0 - 4.3 only, Firefox <=3 - 44
                    o = "2px" === e.marginLeft;
                    i = "4px" === e.width;
                    // Support: Android 4.0 - 4.3 only
                    // Some styles come back with percentage values, even though they shouldn't
                    s.style.marginRight = "50%";
                    r = "4px" === e.marginRight;
                    et.removeChild(a);
                    // Nullify the div so it wouldn't be stored in the memory and
                    // it will also be a sign that checks already performed
                    s = null;
                }
                var t, i, r, o, a = ae.createElement("div"), s = ae.createElement("div");
                // Finish early in limited (non-browser) environments
                if (!s.style) return;
                // Support: IE <=9 - 11 only
                // Style of cloned element affects source element cloned (#8908)
                s.style.backgroundClip = "content-box";
                s.cloneNode(!0).style.backgroundClip = "";
                me.clearCloneStyle = "content-box" === s.style.backgroundClip;
                a.style.cssText = "border:0;width:8px;height:0;top:0;left:-9999px;" + "padding:0;margin-top:1px;position:absolute";
                a.appendChild(s);
                be.extend(me, {
                    pixelPosition: function() {
                        e();
                        return t;
                    },
                    boxSizingReliable: function() {
                        e();
                        return i;
                    },
                    pixelMarginRight: function() {
                        e();
                        return r;
                    },
                    reliableMarginLeft: function() {
                        e();
                        return o;
                    }
                });
            }();
            var // Swappable if display is none or starts with table
            // except "table", "table-cell", or "table-caption"
            // See here for display values: https://developer.mozilla.org/en-US/docs/CSS/display
            dt = /^(none|table(?!-c[ea]).+)/, pt = /^--/, ht = {
                position: "absolute",
                visibility: "hidden",
                display: "block"
            }, vt = {
                letterSpacing: "0",
                fontWeight: "400"
            }, gt = [ "Webkit", "Moz", "ms" ], mt = ae.createElement("div").style;
            be.extend({
                // Add in style property hooks for overriding the default
                // behavior of getting and setting a style property
                cssHooks: {
                    opacity: {
                        get: function(e, t) {
                            if (t) {
                                // We should always get a number back from opacity
                                var n = I(e, "opacity");
                                return "" === n ? "1" : n;
                            }
                        }
                    }
                },
                // Don't automatically add "px" to these possibly-unitless properties
                cssNumber: {
                    animationIterationCount: !0,
                    columnCount: !0,
                    fillOpacity: !0,
                    flexGrow: !0,
                    flexShrink: !0,
                    fontWeight: !0,
                    lineHeight: !0,
                    opacity: !0,
                    order: !0,
                    orphans: !0,
                    widows: !0,
                    zIndex: !0,
                    zoom: !0
                },
                // Add in properties whose names you wish to fix before
                // setting or getting the value
                cssProps: {
                    float: "cssFloat"
                },
                // Get and set the style property on a DOM Node
                style: function(e, t, n, i) {
                    // Don't set styles on text and comment nodes
                    if (!e || 3 === e.nodeType || 8 === e.nodeType || !e.style) return;
                    // Make sure that we're working with the right name
                    var r, o, a, s = be.camelCase(t), l = pt.test(t), u = e.style;
                    // Make sure that we're working with the right name. We don't
                    // want to query the value if it is a CSS custom property
                    // since they are user-defined.
                    if (!l) t = F(s);
                    // Gets hook for the prefixed version, then unprefixed version
                    a = be.cssHooks[t] || be.cssHooks[s];
                    // Check if we're setting a value
                    if (n !== undefined) {
                        o = typeof n;
                        // Convert "+=" or "-=" to relative numbers (#7345)
                        if ("string" === o && (r = Ve.exec(n)) && r[1]) {
                            n = b(e, t, r);
                            // Fixes bug #9237
                            o = "number";
                        }
                        // Make sure that null and NaN values aren't set (#7116)
                        if (null == n || n !== n) return;
                        // If a number was passed in, add the unit (except for certain CSS properties)
                        if ("number" === o) n += r && r[3] || (be.cssNumber[s] ? "" : "px");
                        // background-* props affect original clone's values
                        if (!me.clearCloneStyle && "" === n && 0 === t.indexOf("background")) u[t] = "inherit";
                        // If a hook was provided, use that value, otherwise just set the specified value
                        if (!a || !("set" in a) || (n = a.set(e, n, i)) !== undefined) if (l) u.setProperty(t, n); else u[t] = n;
                    } else {
                        // If a hook was provided get the non-computed value from there
                        if (a && "get" in a && (r = a.get(e, !1, i)) !== undefined) return r;
                        // Otherwise just get the value from the style object
                        return u[t];
                    }
                },
                css: function(e, t, n, i) {
                    var r, o, a, s = be.camelCase(t);
                    // Make sure that we're working with the right name. We don't
                    // want to modify the value if it is a CSS custom property
                    // since they are user-defined.
                    if (!pt.test(t)) t = F(s);
                    // Try prefixed name followed by the unprefixed name
                    a = be.cssHooks[t] || be.cssHooks[s];
                    // If a hook was provided get the computed value from there
                    if (a && "get" in a) r = a.get(e, !0, n);
                    // Otherwise, if a way to get the computed value exists, use that
                    if (r === undefined) r = I(e, t, i);
                    // Convert "normal" to computed value
                    if ("normal" === r && t in vt) r = vt[t];
                    // Make numeric if forced or a qualifier was provided and val looks numeric
                    if ("" === n || n) {
                        o = parseFloat(r);
                        return !0 === n || isFinite(o) ? o || 0 : r;
                    }
                    return r;
                }
            });
            be.each([ "height", "width" ], function(e, t) {
                be.cssHooks[t] = {
                    get: function(e, n, i) {
                        if (n) // Certain elements can have dimension info if we invisibly show them
                        // but it must have a current display style that would benefit
                        // Support: Safari 8+
                        // Table columns in Safari have non-zero offsetWidth & zero
                        // getBoundingClientRect().width unless display is changed.
                        // Support: IE <=11 only
                        // Running getBoundingClientRect on a disconnected node
                        // in IE throws an error.
                        return dt.test(be.css(e, "display")) && (!e.getClientRects().length || !e.getBoundingClientRect().width) ? Ye(e, ht, function() {
                            return $(e, t, i);
                        }) : $(e, t, i);
                    },
                    set: function(e, n, i) {
                        var r, o = i && ft(e), a = i && W(e, t, i, "border-box" === be.css(e, "boxSizing", !1, o), o);
                        // Convert to pixels if value adjustment is needed
                        if (a && (r = Ve.exec(n)) && "px" !== (r[3] || "px")) {
                            e.style[t] = n;
                            n = be.css(e, t);
                        }
                        return R(e, n, a);
                    }
                };
            });
            be.cssHooks.marginLeft = H(me.reliableMarginLeft, function(e, t) {
                if (t) return (parseFloat(I(e, "marginLeft")) || e.getBoundingClientRect().left - Ye(e, {
                    marginLeft: 0
                }, function() {
                    return e.getBoundingClientRect().left;
                })) + "px";
            });
            // These hooks are used by animate to expand properties
            be.each({
                margin: "",
                padding: "",
                border: "Width"
            }, function(e, t) {
                be.cssHooks[e + t] = {
                    expand: function(n) {
                        var i = 0, r = {}, // Assumes a single number if not a string
                        o = "string" === typeof n ? n.split(" ") : [ n ];
                        for (;i < 4; i++) r[e + Xe[i] + t] = o[i] || o[i - 2] || o[0];
                        return r;
                    }
                };
                if (!ut.test(e)) be.cssHooks[e + t].set = R;
            });
            be.fn.extend({
                css: function(e, t) {
                    return He(this, function(e, t, n) {
                        var i, r, o = {}, a = 0;
                        if (Array.isArray(t)) {
                            i = ft(e);
                            r = t.length;
                            for (;a < r; a++) o[t[a]] = be.css(e, t[a], !1, i);
                            return o;
                        }
                        return n !== undefined ? be.style(e, t, n) : be.css(e, t);
                    }, e, t, arguments.length > 1);
                }
            });
            be.Tween = z;
            z.prototype = {
                constructor: z,
                init: function(e, t, n, i, r, o) {
                    this.elem = e;
                    this.prop = n;
                    this.easing = r || be.easing._default;
                    this.options = t;
                    this.start = this.now = this.cur();
                    this.end = i;
                    this.unit = o || (be.cssNumber[n] ? "" : "px");
                },
                cur: function() {
                    var e = z.propHooks[this.prop];
                    return e && e.get ? e.get(this) : z.propHooks._default.get(this);
                },
                run: function(e) {
                    var t, n = z.propHooks[this.prop];
                    if (this.options.duration) this.pos = t = be.easing[this.easing](e, this.options.duration * e, 0, 1, this.options.duration); else this.pos = t = e;
                    this.now = (this.end - this.start) * t + this.start;
                    if (this.options.step) this.options.step.call(this.elem, this.now, this);
                    if (n && n.set) n.set(this); else z.propHooks._default.set(this);
                    return this;
                }
            };
            z.prototype.init.prototype = z.prototype;
            z.propHooks = {
                _default: {
                    get: function(e) {
                        var t;
                        // Use a property on the element directly when it is not a DOM element,
                        // or when there is no matching style property that exists.
                        if (1 !== e.elem.nodeType || null != e.elem[e.prop] && null == e.elem.style[e.prop]) return e.elem[e.prop];
                        // Passing an empty string as a 3rd parameter to .css will automatically
                        // attempt a parseFloat and fallback to a string if the parse fails.
                        // Simple values such as "10px" are parsed to Float;
                        // complex values such as "rotate(1rad)" are returned as-is.
                        t = be.css(e.elem, e.prop, "");
                        // Empty strings, null, undefined and "auto" are converted to 0.
                        return !t || "auto" === t ? 0 : t;
                    },
                    set: function(e) {
                        // Use step hook for back compat.
                        // Use cssHook if its there.
                        // Use .style if available and use plain properties where available.
                        if (be.fx.step[e.prop]) be.fx.step[e.prop](e); else if (1 === e.elem.nodeType && (null != e.elem.style[be.cssProps[e.prop]] || be.cssHooks[e.prop])) be.style(e.elem, e.prop, e.now + e.unit); else e.elem[e.prop] = e.now;
                    }
                }
            };
            // Support: IE <=9 only
            // Panic based approach to setting things on disconnected nodes
            z.propHooks.scrollTop = z.propHooks.scrollLeft = {
                set: function(e) {
                    if (e.elem.nodeType && e.elem.parentNode) e.elem[e.prop] = e.now;
                }
            };
            be.easing = {
                linear: function(e) {
                    return e;
                },
                swing: function(e) {
                    return .5 - Math.cos(e * Math.PI) / 2;
                },
                _default: "swing"
            };
            be.fx = z.prototype.init;
            // Back compat <1.8 extension point
            be.fx.step = {};
            var yt, bt, xt = /^(?:toggle|show|hide)$/, wt = /queueHooks$/;
            be.Animation = be.extend(G, {
                tweeners: {
                    "*": [ function(e, t) {
                        var n = this.createTween(e, t);
                        b(n.elem, e, Ve.exec(t), n);
                        return n;
                    } ]
                },
                tweener: function(e, t) {
                    if (be.isFunction(e)) {
                        t = e;
                        e = [ "*" ];
                    } else e = e.match(Me);
                    var n, i = 0, r = e.length;
                    for (;i < r; i++) {
                        n = e[i];
                        G.tweeners[n] = G.tweeners[n] || [];
                        G.tweeners[n].unshift(t);
                    }
                },
                prefilters: [ Q ],
                prefilter: function(e, t) {
                    if (t) G.prefilters.unshift(e); else G.prefilters.push(e);
                }
            });
            be.speed = function(e, t, n) {
                var i = e && "object" === typeof e ? be.extend({}, e) : {
                    complete: n || !n && t || be.isFunction(e) && e,
                    duration: e,
                    easing: n && t || t && !be.isFunction(t) && t
                };
                // Go to the end state if fx are off
                if (be.fx.off) i.duration = 0; else if ("number" !== typeof i.duration) if (i.duration in be.fx.speeds) i.duration = be.fx.speeds[i.duration]; else i.duration = be.fx.speeds._default;
                // Normalize opt.queue - true/undefined/null -> "fx"
                if (null == i.queue || !0 === i.queue) i.queue = "fx";
                // Queueing
                i.old = i.complete;
                i.complete = function() {
                    if (be.isFunction(i.old)) i.old.call(this);
                    if (i.queue) be.dequeue(this, i.queue);
                };
                return i;
            };
            be.fn.extend({
                fadeTo: function(e, t, n, i) {
                    // Show any hidden elements after setting opacity to 0
                    return this.filter(Be).css("opacity", 0).show().end().animate({
                        opacity: t
                    }, e, n, i);
                },
                animate: function(e, t, n, i) {
                    var r = be.isEmptyObject(e), o = be.speed(t, n, i), a = function() {
                        // Operate on a copy of prop so per-property easing won't be lost
                        var t = G(this, be.extend({}, e), o);
                        // Empty animations, or finishing resolves immediately
                        if (r || Fe.get(this, "finish")) t.stop(!0);
                    };
                    a.finish = a;
                    return r || !1 === o.queue ? this.each(a) : this.queue(o.queue, a);
                },
                stop: function(e, t, n) {
                    var i = function(e) {
                        var t = e.stop;
                        delete e.stop;
                        t(n);
                    };
                    if ("string" !== typeof e) {
                        n = t;
                        t = e;
                        e = undefined;
                    }
                    if (t && !1 !== e) this.queue(e || "fx", []);
                    return this.each(function() {
                        var t = !0, r = null != e && e + "queueHooks", o = be.timers, a = Fe.get(this);
                        if (r) {
                            if (a[r] && a[r].stop) i(a[r]);
                        } else for (r in a) if (a[r] && a[r].stop && wt.test(r)) i(a[r]);
                        for (r = o.length; r--; ) if (o[r].elem === this && (null == e || o[r].queue === e)) {
                            o[r].anim.stop(n);
                            t = !1;
                            o.splice(r, 1);
                        }
                        // Start the next in the queue if the last step wasn't forced.
                        // Timers currently will call their complete callbacks, which
                        // will dequeue but only if they were gotoEnd.
                        if (t || !n) be.dequeue(this, e);
                    });
                },
                finish: function(e) {
                    if (!1 !== e) e = e || "fx";
                    return this.each(function() {
                        var t, n = Fe.get(this), i = n[e + "queue"], r = n[e + "queueHooks"], o = be.timers, a = i ? i.length : 0;
                        // Enable finishing flag on private data
                        n.finish = !0;
                        // Empty the queue first
                        be.queue(this, e, []);
                        if (r && r.stop) r.stop.call(this, !0);
                        // Look for any active animations, and finish them
                        for (t = o.length; t--; ) if (o[t].elem === this && o[t].queue === e) {
                            o[t].anim.stop(!0);
                            o.splice(t, 1);
                        }
                        // Look for any animations in the old queue and finish them
                        for (t = 0; t < a; t++) if (i[t] && i[t].finish) i[t].finish.call(this);
                        // Turn off finishing flag
                        delete n.finish;
                    });
                }
            });
            be.each([ "toggle", "show", "hide" ], function(e, t) {
                var n = be.fn[t];
                be.fn[t] = function(e, i, r) {
                    return null == e || "boolean" === typeof e ? n.apply(this, arguments) : this.animate(B(t, !0), e, i, r);
                };
            });
            // Generate shortcuts for custom animations
            be.each({
                slideDown: B("show"),
                slideUp: B("hide"),
                slideToggle: B("toggle"),
                fadeIn: {
                    opacity: "show"
                },
                fadeOut: {
                    opacity: "hide"
                },
                fadeToggle: {
                    opacity: "toggle"
                }
            }, function(e, t) {
                be.fn[e] = function(e, n, i) {
                    return this.animate(t, e, n, i);
                };
            });
            be.timers = [];
            be.fx.tick = function() {
                var e, t = 0, n = be.timers;
                yt = be.now();
                for (;t < n.length; t++) {
                    e = n[t];
                    // Run the timer and safely remove it when done (allowing for external removal)
                    if (!e() && n[t] === e) n.splice(t--, 1);
                }
                if (!n.length) be.fx.stop();
                yt = undefined;
            };
            be.fx.timer = function(e) {
                be.timers.push(e);
                be.fx.start();
            };
            be.fx.interval = 13;
            be.fx.start = function() {
                if (bt) return;
                bt = !0;
                V();
            };
            be.fx.stop = function() {
                bt = null;
            };
            be.fx.speeds = {
                slow: 600,
                fast: 200,
                // Default speed
                _default: 400
            };
            // Based off of the plugin by Clint Helfers, with permission.
            // https://web.archive.org/web/20100324014747/http://blindsignals.com/index.php/2009/07/jquery-delay/
            be.fn.delay = function(e, t) {
                e = be.fx ? be.fx.speeds[e] || e : e;
                t = t || "fx";
                return this.queue(t, function(t, i) {
                    var r = n.setTimeout(t, e);
                    i.stop = function() {
                        n.clearTimeout(r);
                    };
                });
            };
            !function() {
                var e = ae.createElement("input"), t = ae.createElement("select"), n = t.appendChild(ae.createElement("option"));
                e.type = "checkbox";
                // Support: Android <=4.3 only
                // Default value for a checkbox should be "on"
                me.checkOn = "" !== e.value;
                // Support: IE <=11 only
                // Must access selectedIndex to make default options select
                me.optSelected = n.selected;
                // Support: IE <=11 only
                // An input loses its value after becoming a radio
                e = ae.createElement("input");
                e.value = "t";
                e.type = "radio";
                me.radioValue = "t" === e.value;
            }();
            var Tt, Ct = be.expr.attrHandle;
            be.fn.extend({
                attr: function(e, t) {
                    return He(this, be.attr, e, t, arguments.length > 1);
                },
                removeAttr: function(e) {
                    return this.each(function() {
                        be.removeAttr(this, e);
                    });
                }
            });
            be.extend({
                attr: function(e, t, n) {
                    var i, r, o = e.nodeType;
                    // Don't get/set attributes on text, comment and attribute nodes
                    if (3 === o || 8 === o || 2 === o) return;
                    // Fallback to prop when attributes are not supported
                    if ("undefined" === typeof e.getAttribute) return be.prop(e, t, n);
                    // Attribute hooks are determined by the lowercase version
                    // Grab necessary hook if one is defined
                    if (1 !== o || !be.isXMLDoc(e)) r = be.attrHooks[t.toLowerCase()] || (be.expr.match.bool.test(t) ? Tt : undefined);
                    if (n !== undefined) {
                        if (null === n) {
                            be.removeAttr(e, t);
                            return;
                        }
                        if (r && "set" in r && (i = r.set(e, n, t)) !== undefined) return i;
                        e.setAttribute(t, n + "");
                        return n;
                    }
                    if (r && "get" in r && null !== (i = r.get(e, t))) return i;
                    i = be.find.attr(e, t);
                    // Non-existent attributes return null, we normalize to undefined
                    return null == i ? undefined : i;
                },
                attrHooks: {
                    type: {
                        set: function(e, t) {
                            if (!me.radioValue && "radio" === t && l(e, "input")) {
                                var n = e.value;
                                e.setAttribute("type", t);
                                if (n) e.value = n;
                                return t;
                            }
                        }
                    }
                },
                removeAttr: function(e, t) {
                    var n, i = 0, // Attribute names can contain non-HTML whitespace characters
                    // https://html.spec.whatwg.org/multipage/syntax.html#attributes-2
                    r = t && t.match(Me);
                    if (r && 1 === e.nodeType) for (;n = r[i++]; ) e.removeAttribute(n);
                }
            });
            // Hooks for boolean attributes
            Tt = {
                set: function(e, t, n) {
                    if (!1 === t) // Remove boolean attributes when set to false
                    be.removeAttr(e, n); else e.setAttribute(n, n);
                    return n;
                }
            };
            be.each(be.expr.match.bool.source.match(/\w+/g), function(e, t) {
                var n = Ct[t] || be.find.attr;
                Ct[t] = function(e, t, i) {
                    var r, o, a = t.toLowerCase();
                    if (!i) {
                        // Avoid an infinite loop by temporarily removing this function from the getter
                        o = Ct[a];
                        Ct[a] = r;
                        r = null != n(e, t, i) ? a : null;
                        Ct[a] = o;
                    }
                    return r;
                };
            });
            var kt = /^(?:input|select|textarea|button)$/i, St = /^(?:a|area)$/i;
            be.fn.extend({
                prop: function(e, t) {
                    return He(this, be.prop, e, t, arguments.length > 1);
                },
                removeProp: function(e) {
                    return this.each(function() {
                        delete this[be.propFix[e] || e];
                    });
                }
            });
            be.extend({
                prop: function(e, t, n) {
                    var i, r, o = e.nodeType;
                    // Don't get/set properties on text, comment and attribute nodes
                    if (3 === o || 8 === o || 2 === o) return;
                    if (1 !== o || !be.isXMLDoc(e)) {
                        // Fix name and attach hooks
                        t = be.propFix[t] || t;
                        r = be.propHooks[t];
                    }
                    if (n !== undefined) {
                        if (r && "set" in r && (i = r.set(e, n, t)) !== undefined) return i;
                        return e[t] = n;
                    }
                    if (r && "get" in r && null !== (i = r.get(e, t))) return i;
                    return e[t];
                },
                propHooks: {
                    tabIndex: {
                        get: function(e) {
                            // Support: IE <=9 - 11 only
                            // elem.tabIndex doesn't always return the
                            // correct value when it hasn't been explicitly set
                            // https://web.archive.org/web/20141116233347/http://fluidproject.org/blog/2008/01/09/getting-setting-and-removing-tabindex-values-with-javascript/
                            // Use proper attribute retrieval(#12072)
                            var t = be.find.attr(e, "tabindex");
                            if (t) return parseInt(t, 10);
                            if (kt.test(e.nodeName) || St.test(e.nodeName) && e.href) return 0;
                            return -1;
                        }
                    }
                },
                propFix: {
                    for: "htmlFor",
                    class: "className"
                }
            });
            // Support: IE <=11 only
            // Accessing the selectedIndex property
            // forces the browser to respect setting selected
            // on the option
            // The getter ensures a default option is selected
            // when in an optgroup
            // eslint rule "no-unused-expressions" is disabled for this code
            // since it considers such accessions noop
            if (!me.optSelected) be.propHooks.selected = {
                get: function(e) {
                    /* eslint no-unused-expressions: "off" */
                    var t = e.parentNode;
                    if (t && t.parentNode) t.parentNode.selectedIndex;
                    return null;
                },
                set: function(e) {
                    /* eslint no-unused-expressions: "off" */
                    var t = e.parentNode;
                    if (t) {
                        t.selectedIndex;
                        if (t.parentNode) t.parentNode.selectedIndex;
                    }
                }
            };
            be.each([ "tabIndex", "readOnly", "maxLength", "cellSpacing", "cellPadding", "rowSpan", "colSpan", "useMap", "frameBorder", "contentEditable" ], function() {
                be.propFix[this.toLowerCase()] = this;
            });
            be.fn.extend({
                addClass: function(e) {
                    var t, n, i, r, o, a, s, l = 0;
                    if (be.isFunction(e)) return this.each(function(t) {
                        be(this).addClass(e.call(this, t, J(this)));
                    });
                    if ("string" === typeof e && e) {
                        t = e.match(Me) || [];
                        for (;n = this[l++]; ) {
                            r = J(n);
                            i = 1 === n.nodeType && " " + Z(r) + " ";
                            if (i) {
                                a = 0;
                                for (;o = t[a++]; ) if (i.indexOf(" " + o + " ") < 0) i += o + " ";
                                // Only assign if different to avoid unneeded rendering.
                                s = Z(i);
                                if (r !== s) n.setAttribute("class", s);
                            }
                        }
                    }
                    return this;
                },
                removeClass: function(e) {
                    var t, n, i, r, o, a, s, l = 0;
                    if (be.isFunction(e)) return this.each(function(t) {
                        be(this).removeClass(e.call(this, t, J(this)));
                    });
                    if (!arguments.length) return this.attr("class", "");
                    if ("string" === typeof e && e) {
                        t = e.match(Me) || [];
                        for (;n = this[l++]; ) {
                            r = J(n);
                            // This expression is here for better compressibility (see addClass)
                            i = 1 === n.nodeType && " " + Z(r) + " ";
                            if (i) {
                                a = 0;
                                for (;o = t[a++]; ) // Remove *all* instances
                                for (;i.indexOf(" " + o + " ") > -1; ) i = i.replace(" " + o + " ", " ");
                                // Only assign if different to avoid unneeded rendering.
                                s = Z(i);
                                if (r !== s) n.setAttribute("class", s);
                            }
                        }
                    }
                    return this;
                },
                toggleClass: function(e, t) {
                    var n = typeof e;
                    if ("boolean" === typeof t && "string" === n) return t ? this.addClass(e) : this.removeClass(e);
                    if (be.isFunction(e)) return this.each(function(n) {
                        be(this).toggleClass(e.call(this, n, J(this), t), t);
                    });
                    return this.each(function() {
                        var t, i, r, o;
                        if ("string" === n) {
                            // Toggle individual class names
                            i = 0;
                            r = be(this);
                            o = e.match(Me) || [];
                            for (;t = o[i++]; ) // Check each className given, space separated list
                            if (r.hasClass(t)) r.removeClass(t); else r.addClass(t);
                        } else if (e === undefined || "boolean" === n) {
                            t = J(this);
                            if (t) // Store className if set
                            Fe.set(this, "__className__", t);
                            // If the element has a class name or if we're passed `false`,
                            // then remove the whole classname (if there was one, the above saved it).
                            // Otherwise bring back whatever was previously saved (if anything),
                            // falling back to the empty string if nothing was stored.
                            if (this.setAttribute) this.setAttribute("class", t || !1 === e ? "" : Fe.get(this, "__className__") || "");
                        }
                    });
                },
                hasClass: function(e) {
                    var t, n, i = 0;
                    t = " " + e + " ";
                    for (;n = this[i++]; ) if (1 === n.nodeType && (" " + Z(J(n)) + " ").indexOf(t) > -1) return !0;
                    return !1;
                }
            });
            var Et = /\r/g;
            be.fn.extend({
                val: function(e) {
                    var t, n, i, r = this[0];
                    if (!arguments.length) {
                        if (r) {
                            t = be.valHooks[r.type] || be.valHooks[r.nodeName.toLowerCase()];
                            if (t && "get" in t && (n = t.get(r, "value")) !== undefined) return n;
                            n = r.value;
                            // Handle most common string cases
                            if ("string" === typeof n) return n.replace(Et, "");
                            // Handle cases where value is null/undef or number
                            return null == n ? "" : n;
                        }
                        return;
                    }
                    i = be.isFunction(e);
                    return this.each(function(n) {
                        var r;
                        if (1 !== this.nodeType) return;
                        if (i) r = e.call(this, n, be(this).val()); else r = e;
                        // Treat null/undefined as ""; convert numbers to string
                        if (null == r) r = ""; else if ("number" === typeof r) r += ""; else if (Array.isArray(r)) r = be.map(r, function(e) {
                            return null == e ? "" : e + "";
                        });
                        t = be.valHooks[this.type] || be.valHooks[this.nodeName.toLowerCase()];
                        // If set returns undefined, fall back to normal setting
                        if (!t || !("set" in t) || t.set(this, r, "value") === undefined) this.value = r;
                    });
                }
            });
            be.extend({
                valHooks: {
                    option: {
                        get: function(e) {
                            var t = be.find.attr(e, "value");
                            // Support: IE <=10 - 11 only
                            // option.text throws exceptions (#14686, #14858)
                            // Strip and collapse whitespace
                            // https://html.spec.whatwg.org/#strip-and-collapse-whitespace
                            return null != t ? t : Z(be.text(e));
                        }
                    },
                    select: {
                        get: function(e) {
                            var t, n, i, r = e.options, o = e.selectedIndex, a = "select-one" === e.type, s = a ? null : [], u = a ? o + 1 : r.length;
                            if (o < 0) i = u; else i = a ? o : 0;
                            // Loop through all the selected options
                            for (;i < u; i++) {
                                n = r[i];
                                // Support: IE <=9 only
                                // IE8-9 doesn't update selected after form reset (#2551)
                                if ((n.selected || i === o) && // Don't return options that are disabled or in a disabled optgroup
                                !n.disabled && (!n.parentNode.disabled || !l(n.parentNode, "optgroup"))) {
                                    // Get the specific value for the option
                                    t = be(n).val();
                                    // We don't need an array for one selects
                                    if (a) return t;
                                    // Multi-Selects return an array
                                    s.push(t);
                                }
                            }
                            return s;
                        },
                        set: function(e, t) {
                            var n, i, r = e.options, o = be.makeArray(t), a = r.length;
                            for (;a--; ) {
                                i = r[a];
                                /* eslint-disable no-cond-assign */
                                if (i.selected = be.inArray(be.valHooks.option.get(i), o) > -1) n = !0;
                            }
                            // Force browsers to behave consistently when non-matching value is set
                            if (!n) e.selectedIndex = -1;
                            return o;
                        }
                    }
                }
            });
            // Radios and checkboxes getter/setter
            be.each([ "radio", "checkbox" ], function() {
                be.valHooks[this] = {
                    set: function(e, t) {
                        if (Array.isArray(t)) return e.checked = be.inArray(be(e).val(), t) > -1;
                    }
                };
                if (!me.checkOn) be.valHooks[this].get = function(e) {
                    return null === e.getAttribute("value") ? "on" : e.value;
                };
            });
            // Return jQuery for attributes-only inclusion
            var At = /^(?:focusinfocus|focusoutblur)$/;
            be.extend(be.event, {
                trigger: function(e, t, i, r) {
                    var o, a, s, l, u, c, f, d = [ i || ae ], p = he.call(e, "type") ? e.type : e, h = he.call(e, "namespace") ? e.namespace.split(".") : [];
                    a = s = i = i || ae;
                    // Don't do events on text and comment nodes
                    if (3 === i.nodeType || 8 === i.nodeType) return;
                    // focus/blur morphs to focusin/out; ensure we're not firing them right now
                    if (At.test(p + be.event.triggered)) return;
                    if (p.indexOf(".") > -1) {
                        // Namespaced trigger; create a regexp to match event type in handle()
                        h = p.split(".");
                        p = h.shift();
                        h.sort();
                    }
                    u = p.indexOf(":") < 0 && "on" + p;
                    // Caller can pass in a jQuery.Event object, Object, or just an event type string
                    e = e[be.expando] ? e : new be.Event(p, "object" === typeof e && e);
                    // Trigger bitmask: & 1 for native handlers; & 2 for jQuery (always true)
                    e.isTrigger = r ? 2 : 3;
                    e.namespace = h.join(".");
                    e.rnamespace = e.namespace ? new RegExp("(^|\\.)" + h.join("\\.(?:.*\\.|)") + "(\\.|$)") : null;
                    // Clean up the event in case it is being reused
                    e.result = undefined;
                    if (!e.target) e.target = i;
                    // Clone any incoming data and prepend the event, creating the handler arg list
                    t = null == t ? [ e ] : be.makeArray(t, [ e ]);
                    // Allow special events to draw outside the lines
                    f = be.event.special[p] || {};
                    if (!r && f.trigger && !1 === f.trigger.apply(i, t)) return;
                    // Determine event propagation path in advance, per W3C events spec (#9951)
                    // Bubble up to document, then to window; watch for a global ownerDocument var (#9724)
                    if (!r && !f.noBubble && !be.isWindow(i)) {
                        l = f.delegateType || p;
                        if (!At.test(l + p)) a = a.parentNode;
                        for (;a; a = a.parentNode) {
                            d.push(a);
                            s = a;
                        }
                        // Only add window if we got to document (e.g., not plain obj or detached DOM)
                        if (s === (i.ownerDocument || ae)) d.push(s.defaultView || s.parentWindow || n);
                    }
                    // Fire handlers on the event path
                    o = 0;
                    for (;(a = d[o++]) && !e.isPropagationStopped(); ) {
                        e.type = o > 1 ? l : f.bindType || p;
                        // jQuery handler
                        c = (Fe.get(a, "events") || {})[e.type] && Fe.get(a, "handle");
                        if (c) c.apply(a, t);
                        // Native handler
                        c = u && a[u];
                        if (c && c.apply && _e(a)) {
                            e.result = c.apply(a, t);
                            if (!1 === e.result) e.preventDefault();
                        }
                    }
                    e.type = p;
                    // If nobody prevented the default action, do it now
                    if (!r && !e.isDefaultPrevented()) if ((!f._default || !1 === f._default.apply(d.pop(), t)) && _e(i)) // Call a native DOM method on the target with the same name as the event.
                    // Don't do default actions on window, that's where global variables be (#6170)
                    if (u && be.isFunction(i[p]) && !be.isWindow(i)) {
                        // Don't re-trigger an onFOO event when we call its FOO() method
                        s = i[u];
                        if (s) i[u] = null;
                        // Prevent re-triggering of the same event, since we already bubbled it above
                        be.event.triggered = p;
                        i[p]();
                        be.event.triggered = undefined;
                        if (s) i[u] = s;
                    }
                    return e.result;
                },
                // Piggyback on a donor event to simulate a different one
                // Used only for `focus(in | out)` events
                simulate: function(e, t, n) {
                    var i = be.extend(new be.Event(), n, {
                        type: e,
                        isSimulated: !0
                    });
                    be.event.trigger(i, null, t);
                }
            });
            be.fn.extend({
                trigger: function(e, t) {
                    return this.each(function() {
                        be.event.trigger(e, t, this);
                    });
                },
                triggerHandler: function(e, t) {
                    var n = this[0];
                    if (n) return be.event.trigger(e, t, n, !0);
                }
            });
            be.each(("blur focus focusin focusout resize scroll click dblclick " + "mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave " + "change select submit keydown keypress keyup contextmenu").split(" "), function(e, t) {
                // Handle event binding
                be.fn[t] = function(e, n) {
                    return arguments.length > 0 ? this.on(t, null, e, n) : this.trigger(t);
                };
            });
            be.fn.extend({
                hover: function(e, t) {
                    return this.mouseenter(e).mouseleave(t || e);
                }
            });
            me.focusin = "onfocusin" in n;
            // Support: Firefox <=44
            // Firefox doesn't have focus(in | out) events
            // Related ticket - https://bugzilla.mozilla.org/show_bug.cgi?id=687787
            //
            // Support: Chrome <=48 - 49, Safari <=9.0 - 9.1
            // focus(in | out) events fire after focus & blur events,
            // which is spec violation - http://www.w3.org/TR/DOM-Level-3-Events/#events-focusevent-event-order
            // Related ticket - https://bugs.chromium.org/p/chromium/issues/detail?id=449857
            if (!me.focusin) be.each({
                focus: "focusin",
                blur: "focusout"
            }, function(e, t) {
                // Attach a single capturing handler on the document while someone wants focusin/focusout
                var n = function(e) {
                    be.event.simulate(t, e.target, be.event.fix(e));
                };
                be.event.special[t] = {
                    setup: function() {
                        var i = this.ownerDocument || this, r = Fe.access(i, t);
                        if (!r) i.addEventListener(e, n, !0);
                        Fe.access(i, t, (r || 0) + 1);
                    },
                    teardown: function() {
                        var i = this.ownerDocument || this, r = Fe.access(i, t) - 1;
                        if (!r) {
                            i.removeEventListener(e, n, !0);
                            Fe.remove(i, t);
                        } else Fe.access(i, t, r);
                    }
                };
            });
            var Pt = n.location;
            var Dt = be.now();
            var Ot = /\?/;
            // Cross-browser xml parsing
            be.parseXML = function(e) {
                var t;
                if (!e || "string" !== typeof e) return null;
                // Support: IE 9 - 11 only
                // IE throws on parseFromString with invalid input.
                try {
                    t = new n.DOMParser().parseFromString(e, "text/xml");
                } catch (i) {
                    t = undefined;
                }
                if (!t || t.getElementsByTagName("parsererror").length) be.error("Invalid XML: " + e);
                return t;
            };
            var Nt = /\[\]$/, qt = /\r?\n/g, jt = /^(?:submit|button|image|reset|file)$/i, Mt = /^(?:input|select|textarea|keygen)/i;
            // Serialize an array of form elements or a set of
            // key/values into a query string
            be.param = function(e, t) {
                var n, i = [], r = function(e, t) {
                    // If value is a function, invoke it and use its return value
                    var n = be.isFunction(t) ? t() : t;
                    i[i.length] = encodeURIComponent(e) + "=" + encodeURIComponent(null == n ? "" : n);
                };
                // If an array was passed in, assume that it is an array of form elements.
                if (Array.isArray(e) || e.jquery && !be.isPlainObject(e)) // Serialize the form elements
                be.each(e, function() {
                    r(this.name, this.value);
                }); else // If traditional, encode the "old" way (the way 1.3.2 or older
                // did it), otherwise encode params recursively.
                for (n in e) K(n, e[n], t, r);
                // Return the resulting serialization
                return i.join("&");
            };
            be.fn.extend({
                serialize: function() {
                    return be.param(this.serializeArray());
                },
                serializeArray: function() {
                    return this.map(function() {
                        // Can add propHook for "elements" to filter or add form elements
                        var e = be.prop(this, "elements");
                        return e ? be.makeArray(e) : this;
                    }).filter(function() {
                        var e = this.type;
                        // Use .is( ":disabled" ) so that fieldset[disabled] works
                        return this.name && !be(this).is(":disabled") && Mt.test(this.nodeName) && !jt.test(e) && (this.checked || !Ue.test(e));
                    }).map(function(e, t) {
                        var n = be(this).val();
                        if (null == n) return null;
                        if (Array.isArray(n)) return be.map(n, function(e) {
                            return {
                                name: t.name,
                                value: e.replace(qt, "\r\n")
                            };
                        });
                        return {
                            name: t.name,
                            value: n.replace(qt, "\r\n")
                        };
                    }).get();
                }
            });
            var Lt = /%20/g, It = /#.*$/, Ht = /([?&])_=[^&]*/, _t = /^(.*?):[ \t]*([^\r\n]*)$/gm, // #7653, #8125, #8152: local protocol detection
            Ft = /^(?:about|app|app-storage|.+-extension|file|res|widget):$/, Rt = /^(?:GET|HEAD)$/, Wt = /^\/\//, /* Prefilters
	 * 1) They are useful to introduce custom dataTypes (see ajax/jsonp.js for an example)
	 * 2) These are called:
	 *    - BEFORE asking for a transport
	 *    - AFTER param serialization (s.data is a string if s.processData is true)
	 * 3) key is the dataType
	 * 4) the catchall symbol "*" can be used
	 * 5) execution will start with transport dataType and THEN continue down to "*" if needed
	 */
            $t = {}, /* Transports bindings
	 * 1) key is the dataType
	 * 2) the catchall symbol "*" can be used
	 * 3) selection will start with transport dataType and THEN go to "*" if needed
	 */
            zt = {}, // Avoid comment-prolog char sequence (#10098); must appease lint and evade compression
            Vt = "*/".concat("*"), // Anchor tag for parsing the document origin
            Xt = ae.createElement("a");
            Xt.href = Pt.href;
            be.extend({
                // Counter for holding the number of active queries
                active: 0,
                // Last-Modified header cache for next request
                lastModified: {},
                etag: {},
                ajaxSettings: {
                    url: Pt.href,
                    type: "GET",
                    isLocal: Ft.test(Pt.protocol),
                    global: !0,
                    processData: !0,
                    async: !0,
                    contentType: "application/x-www-form-urlencoded; charset=UTF-8",
                    /*
		timeout: 0,
		data: null,
		dataType: null,
		username: null,
		password: null,
		cache: null,
		throws: false,
		traditional: false,
		headers: {},
		*/
                    accepts: {
                        "*": Vt,
                        text: "text/plain",
                        html: "text/html",
                        xml: "application/xml, text/xml",
                        json: "application/json, text/javascript"
                    },
                    contents: {
                        xml: /\bxml\b/,
                        html: /\bhtml/,
                        json: /\bjson\b/
                    },
                    responseFields: {
                        xml: "responseXML",
                        text: "responseText",
                        json: "responseJSON"
                    },
                    // Data converters
                    // Keys separate source (or catchall "*") and destination types with a single space
                    converters: {
                        // Convert anything to text
                        "* text": String,
                        // Text to html (true = no transformation)
                        "text html": !0,
                        // Evaluate text as a json expression
                        "text json": JSON.parse,
                        // Parse text as xml
                        "text xml": be.parseXML
                    },
                    // For options that shouldn't be deep extended:
                    // you can add your own custom options here if
                    // and when you create one that shouldn't be
                    // deep extended (see ajaxExtend)
                    flatOptions: {
                        url: !0,
                        context: !0
                    }
                },
                // Creates a full fledged settings object into target
                // with both ajaxSettings and settings fields.
                // If target is omitted, writes into ajaxSettings.
                ajaxSetup: function(e, t) {
                    // Building a settings object
                    // Extending ajaxSettings
                    return t ? ne(ne(e, be.ajaxSettings), t) : ne(be.ajaxSettings, e);
                },
                ajaxPrefilter: ee($t),
                ajaxTransport: ee(zt),
                // Main method
                ajax: function(e, t) {
                    // Callback for when everything is done
                    function i(e, t, i, s) {
                        var u, d, p, x, w, T = t;
                        // Ignore repeat invocations
                        if (c) return;
                        c = !0;
                        // Clear timeout if it exists
                        if (l) n.clearTimeout(l);
                        // Dereference transport for early garbage collection
                        // (no matter how long the jqXHR object will be used)
                        r = undefined;
                        // Cache response headers
                        a = s || "";
                        // Set readyState
                        C.readyState = e > 0 ? 4 : 0;
                        // Determine if successful
                        u = e >= 200 && e < 300 || 304 === e;
                        // Get response data
                        if (i) x = ie(h, C, i);
                        // Convert no matter what (that way responseXXX fields are always set)
                        x = re(h, x, C, u);
                        // If successful, handle type chaining
                        if (u) {
                            // Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.
                            if (h.ifModified) {
                                w = C.getResponseHeader("Last-Modified");
                                if (w) be.lastModified[o] = w;
                                w = C.getResponseHeader("etag");
                                if (w) be.etag[o] = w;
                            }
                            // if no content
                            if (204 === e || "HEAD" === h.type) T = "nocontent"; else if (304 === e) T = "notmodified"; else {
                                T = x.state;
                                d = x.data;
                                p = x.error;
                                u = !p;
                            }
                        } else {
                            // Extract error from statusText and normalize for non-aborts
                            p = T;
                            if (e || !T) {
                                T = "error";
                                if (e < 0) e = 0;
                            }
                        }
                        // Set data for the fake xhr object
                        C.status = e;
                        C.statusText = (t || T) + "";
                        // Success/Error
                        if (u) m.resolveWith(v, [ d, T, C ]); else m.rejectWith(v, [ C, T, p ]);
                        // Status-dependent callbacks
                        C.statusCode(b);
                        b = undefined;
                        if (f) g.trigger(u ? "ajaxSuccess" : "ajaxError", [ C, h, u ? d : p ]);
                        // Complete
                        y.fireWith(v, [ C, T ]);
                        if (f) {
                            g.trigger("ajaxComplete", [ C, h ]);
                            // Handle the global AJAX counter
                            if (!--be.active) be.event.trigger("ajaxStop");
                        }
                    }
                    // If url is an object, simulate pre-1.5 signature
                    if ("object" === typeof e) {
                        t = e;
                        e = undefined;
                    }
                    // Force options to be an object
                    t = t || {};
                    var r, // URL without anti-cache param
                    o, // Response headers
                    a, s, // timeout handle
                    l, // Url cleanup var
                    u, // Request state (becomes false upon send and true upon completion)
                    c, // To know if global events are to be dispatched
                    f, // Loop variable
                    d, // uncached part of the url
                    p, // Create the final options object
                    h = be.ajaxSetup({}, t), // Callbacks context
                    v = h.context || h, // Context for global events is callbackContext if it is a DOM node or jQuery collection
                    g = h.context && (v.nodeType || v.jquery) ? be(v) : be.event, // Deferreds
                    m = be.Deferred(), y = be.Callbacks("once memory"), // Status-dependent callbacks
                    b = h.statusCode || {}, // Headers (they are sent all at once)
                    x = {}, w = {}, // Default abort message
                    T = "canceled", // Fake xhr
                    C = {
                        readyState: 0,
                        // Builds headers hashtable if needed
                        getResponseHeader: function(e) {
                            var t;
                            if (c) {
                                if (!s) {
                                    s = {};
                                    for (;t = _t.exec(a); ) s[t[1].toLowerCase()] = t[2];
                                }
                                t = s[e.toLowerCase()];
                            }
                            return null == t ? null : t;
                        },
                        // Raw string
                        getAllResponseHeaders: function() {
                            return c ? a : null;
                        },
                        // Caches the header
                        setRequestHeader: function(e, t) {
                            if (null == c) {
                                e = w[e.toLowerCase()] = w[e.toLowerCase()] || e;
                                x[e] = t;
                            }
                            return this;
                        },
                        // Overrides response content-type header
                        overrideMimeType: function(e) {
                            if (null == c) h.mimeType = e;
                            return this;
                        },
                        // Status-dependent callbacks
                        statusCode: function(e) {
                            var t;
                            if (e) if (c) // Execute the appropriate callbacks
                            C.always(e[C.status]); else // Lazy-add the new callbacks in a way that preserves old ones
                            for (t in e) b[t] = [ b[t], e[t] ];
                            return this;
                        },
                        // Cancel the request
                        abort: function(e) {
                            var t = e || T;
                            if (r) r.abort(t);
                            i(0, t);
                            return this;
                        }
                    };
                    // Attach deferreds
                    m.promise(C);
                    // Add protocol if not provided (prefilters might expect it)
                    // Handle falsy url in the settings object (#10093: consistency with old signature)
                    // We also use the url parameter if available
                    h.url = ((e || h.url || Pt.href) + "").replace(Wt, Pt.protocol + "//");
                    // Alias method option to type as per ticket #12004
                    h.type = t.method || t.type || h.method || h.type;
                    // Extract dataTypes list
                    h.dataTypes = (h.dataType || "*").toLowerCase().match(Me) || [ "" ];
                    // A cross-domain request is in order when the origin doesn't match the current origin.
                    if (null == h.crossDomain) {
                        u = ae.createElement("a");
                        // Support: IE <=8 - 11, Edge 12 - 13
                        // IE throws exception on accessing the href property if url is malformed,
                        // e.g. http://example.com:80x/
                        try {
                            u.href = h.url;
                            // Support: IE <=8 - 11 only
                            // Anchor's host property isn't correctly set when s.url is relative
                            u.href = u.href;
                            h.crossDomain = Xt.protocol + "//" + Xt.host !== u.protocol + "//" + u.host;
                        } catch (k) {
                            // If there is an error parsing the URL, assume it is crossDomain,
                            // it can be rejected by the transport if it is invalid
                            h.crossDomain = !0;
                        }
                    }
                    // Convert data if not already a string
                    if (h.data && h.processData && "string" !== typeof h.data) h.data = be.param(h.data, h.traditional);
                    // Apply prefilters
                    te($t, h, t, C);
                    // If request was aborted inside a prefilter, stop there
                    if (c) return C;
                    // We can fire global events as of now if asked to
                    // Don't fire events if jQuery.event is undefined in an AMD-usage scenario (#15118)
                    f = be.event && h.global;
                    // Watch for a new set of requests
                    if (f && 0 === be.active++) be.event.trigger("ajaxStart");
                    // Uppercase the type
                    h.type = h.type.toUpperCase();
                    // Determine if request has content
                    h.hasContent = !Rt.test(h.type);
                    // Save the URL in case we're toying with the If-Modified-Since
                    // and/or If-None-Match header later on
                    // Remove hash to simplify url manipulation
                    o = h.url.replace(It, "");
                    // More options handling for requests with no content
                    if (!h.hasContent) {
                        // Remember the hash so we can put it back
                        p = h.url.slice(o.length);
                        // If data is available, append data to url
                        if (h.data) {
                            o += (Ot.test(o) ? "&" : "?") + h.data;
                            // #9682: remove data so that it's not used in an eventual retry
                            delete h.data;
                        }
                        // Add or update anti-cache param if needed
                        if (!1 === h.cache) {
                            o = o.replace(Ht, "$1");
                            p = (Ot.test(o) ? "&" : "?") + "_=" + Dt++ + p;
                        }
                        // Put hash and anti-cache on the URL that will be requested (gh-1732)
                        h.url = o + p;
                    } else if (h.data && h.processData && 0 === (h.contentType || "").indexOf("application/x-www-form-urlencoded")) h.data = h.data.replace(Lt, "+");
                    // Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.
                    if (h.ifModified) {
                        if (be.lastModified[o]) C.setRequestHeader("If-Modified-Since", be.lastModified[o]);
                        if (be.etag[o]) C.setRequestHeader("If-None-Match", be.etag[o]);
                    }
                    // Set the correct header, if data is being sent
                    if (h.data && h.hasContent && !1 !== h.contentType || t.contentType) C.setRequestHeader("Content-Type", h.contentType);
                    // Set the Accepts header for the server, depending on the dataType
                    C.setRequestHeader("Accept", h.dataTypes[0] && h.accepts[h.dataTypes[0]] ? h.accepts[h.dataTypes[0]] + ("*" !== h.dataTypes[0] ? ", " + Vt + "; q=0.01" : "") : h.accepts["*"]);
                    // Check for headers option
                    for (d in h.headers) C.setRequestHeader(d, h.headers[d]);
                    // Allow custom headers/mimetypes and early abort
                    if (h.beforeSend && (!1 === h.beforeSend.call(v, C, h) || c)) // Abort if not done already and return
                    return C.abort();
                    // Aborting is no longer a cancellation
                    T = "abort";
                    // Install callbacks on deferreds
                    y.add(h.complete);
                    C.done(h.success);
                    C.fail(h.error);
                    // Get transport
                    r = te(zt, h, t, C);
                    // If no transport, we auto-abort
                    if (!r) i(-1, "No Transport"); else {
                        C.readyState = 1;
                        // Send global event
                        if (f) g.trigger("ajaxSend", [ C, h ]);
                        // If request was aborted inside ajaxSend, stop there
                        if (c) return C;
                        // Timeout
                        if (h.async && h.timeout > 0) l = n.setTimeout(function() {
                            C.abort("timeout");
                        }, h.timeout);
                        try {
                            c = !1;
                            r.send(x, i);
                        } catch (k) {
                            // Rethrow post-completion exceptions
                            if (c) throw k;
                            // Propagate others as results
                            i(-1, k);
                        }
                    }
                    return C;
                },
                getJSON: function(e, t, n) {
                    return be.get(e, t, n, "json");
                },
                getScript: function(e, t) {
                    return be.get(e, undefined, t, "script");
                }
            });
            be.each([ "get", "post" ], function(e, t) {
                be[t] = function(e, n, i, r) {
                    // Shift arguments if data argument was omitted
                    if (be.isFunction(n)) {
                        r = r || i;
                        i = n;
                        n = undefined;
                    }
                    // The url can be an options object (which then must have .url)
                    return be.ajax(be.extend({
                        url: e,
                        type: t,
                        dataType: r,
                        data: n,
                        success: i
                    }, be.isPlainObject(e) && e));
                };
            });
            be._evalUrl = function(e) {
                return be.ajax({
                    url: e,
                    // Make this explicit, since user can override this through ajaxSetup (#11264)
                    type: "GET",
                    dataType: "script",
                    cache: !0,
                    async: !1,
                    global: !1,
                    throws: !0
                });
            };
            be.fn.extend({
                wrapAll: function(e) {
                    var t;
                    if (this[0]) {
                        if (be.isFunction(e)) e = e.call(this[0]);
                        // The elements to wrap the target around
                        t = be(e, this[0].ownerDocument).eq(0).clone(!0);
                        if (this[0].parentNode) t.insertBefore(this[0]);
                        t.map(function() {
                            var e = this;
                            for (;e.firstElementChild; ) e = e.firstElementChild;
                            return e;
                        }).append(this);
                    }
                    return this;
                },
                wrapInner: function(e) {
                    if (be.isFunction(e)) return this.each(function(t) {
                        be(this).wrapInner(e.call(this, t));
                    });
                    return this.each(function() {
                        var t = be(this), n = t.contents();
                        if (n.length) n.wrapAll(e); else t.append(e);
                    });
                },
                wrap: function(e) {
                    var t = be.isFunction(e);
                    return this.each(function(n) {
                        be(this).wrapAll(t ? e.call(this, n) : e);
                    });
                },
                unwrap: function(e) {
                    this.parent(e).not("body").each(function() {
                        be(this).replaceWith(this.childNodes);
                    });
                    return this;
                }
            });
            be.expr.pseudos.hidden = function(e) {
                return !be.expr.pseudos.visible(e);
            };
            be.expr.pseudos.visible = function(e) {
                return !!(e.offsetWidth || e.offsetHeight || e.getClientRects().length);
            };
            be.ajaxSettings.xhr = function() {
                try {
                    return new n.XMLHttpRequest();
                } catch (e) {}
            };
            var Bt = {
                // File protocol always yields status code 0, assume 200
                0: 200,
                // Support: IE <=9 only
                // #1450: sometimes IE returns 1223 when it should be 204
                1223: 204
            }, Yt = be.ajaxSettings.xhr();
            me.cors = !!Yt && "withCredentials" in Yt;
            me.ajax = Yt = !!Yt;
            be.ajaxTransport(function(e) {
                var t, i;
                // Cross domain only allowed if supported through XMLHttpRequest
                if (me.cors || Yt && !e.crossDomain) return {
                    send: function(r, o) {
                        var a, s = e.xhr();
                        s.open(e.type, e.url, e.async, e.username, e.password);
                        // Apply custom fields if provided
                        if (e.xhrFields) for (a in e.xhrFields) s[a] = e.xhrFields[a];
                        // Override mime type if needed
                        if (e.mimeType && s.overrideMimeType) s.overrideMimeType(e.mimeType);
                        // X-Requested-With header
                        // For cross-domain requests, seeing as conditions for a preflight are
                        // akin to a jigsaw puzzle, we simply never set it to be sure.
                        // (it can always be set on a per-request basis or even using ajaxSetup)
                        // For same-domain requests, won't change header if already provided.
                        if (!e.crossDomain && !r["X-Requested-With"]) r["X-Requested-With"] = "XMLHttpRequest";
                        // Set headers
                        for (a in r) s.setRequestHeader(a, r[a]);
                        // Callback
                        t = function(e) {
                            return function() {
                                if (t) {
                                    t = i = s.onload = s.onerror = s.onabort = s.onreadystatechange = null;
                                    if ("abort" === e) s.abort(); else if ("error" === e) // Support: IE <=9 only
                                    // On a manual native abort, IE9 throws
                                    // errors on any property access that is not readyState
                                    if ("number" !== typeof s.status) o(0, "error"); else o(// File: protocol always yields status 0; see #8605, #14207
                                    s.status, s.statusText); else o(Bt[s.status] || s.status, s.statusText, // Support: IE <=9 only
                                    // IE9 has no XHR2 but throws on binary (trac-11426)
                                    // For XHR2 non-text, let the caller handle it (gh-2498)
                                    "text" !== (s.responseType || "text") || "string" !== typeof s.responseText ? {
                                        binary: s.response
                                    } : {
                                        text: s.responseText
                                    }, s.getAllResponseHeaders());
                                }
                            };
                        };
                        // Listen to events
                        s.onload = t();
                        i = s.onerror = t("error");
                        // Support: IE 9 only
                        // Use onreadystatechange to replace onabort
                        // to handle uncaught aborts
                        if (s.onabort !== undefined) s.onabort = i; else s.onreadystatechange = function() {
                            // Check readyState before timeout as it changes
                            if (4 === s.readyState) // Allow onerror to be called first,
                            // but that will not handle a native abort
                            // Also, save errorCallback to a variable
                            // as xhr.onerror cannot be accessed
                            n.setTimeout(function() {
                                if (t) i();
                            });
                        };
                        // Create the abort callback
                        t = t("abort");
                        try {
                            // Do send the request (this may raise an exception)
                            s.send(e.hasContent && e.data || null);
                        } catch (l) {
                            // #14683: Only rethrow if this hasn't been notified as an error yet
                            if (t) throw l;
                        }
                    },
                    abort: function() {
                        if (t) t();
                    }
                };
            });
            // Prevent auto-execution of scripts when no explicit dataType was provided (See gh-2432)
            be.ajaxPrefilter(function(e) {
                if (e.crossDomain) e.contents.script = !1;
            });
            // Install script dataType
            be.ajaxSetup({
                accepts: {
                    script: "text/javascript, application/javascript, " + "application/ecmascript, application/x-ecmascript"
                },
                contents: {
                    script: /\b(?:java|ecma)script\b/
                },
                converters: {
                    "text script": function(e) {
                        be.globalEval(e);
                        return e;
                    }
                }
            });
            // Handle cache's special case and crossDomain
            be.ajaxPrefilter("script", function(e) {
                if (e.cache === undefined) e.cache = !1;
                if (e.crossDomain) e.type = "GET";
            });
            // Bind script tag hack transport
            be.ajaxTransport("script", function(e) {
                // This transport only deals with cross domain requests
                if (e.crossDomain) {
                    var t, n;
                    return {
                        send: function(i, r) {
                            t = be("<script>").prop({
                                charset: e.scriptCharset,
                                src: e.url
                            }).on("load error", n = function(e) {
                                t.remove();
                                n = null;
                                if (e) r("error" === e.type ? 404 : 200, e.type);
                            });
                            // Use native DOM manipulation to avoid our domManip AJAX trickery
                            ae.head.appendChild(t[0]);
                        },
                        abort: function() {
                            if (n) n();
                        }
                    };
                }
            });
            var Qt = [], Ut = /(=)\?(?=&|$)|\?\?/;
            // Default jsonp settings
            be.ajaxSetup({
                jsonp: "callback",
                jsonpCallback: function() {
                    var e = Qt.pop() || be.expando + "_" + Dt++;
                    this[e] = !0;
                    return e;
                }
            });
            // Detect, normalize options and install callbacks for jsonp requests
            be.ajaxPrefilter("json jsonp", function(e, t, i) {
                var r, o, a, s = !1 !== e.jsonp && (Ut.test(e.url) ? "url" : "string" === typeof e.data && 0 === (e.contentType || "").indexOf("application/x-www-form-urlencoded") && Ut.test(e.data) && "data");
                // Handle iff the expected data type is "jsonp" or we have a parameter to set
                if (s || "jsonp" === e.dataTypes[0]) {
                    // Get callback name, remembering preexisting value associated with it
                    r = e.jsonpCallback = be.isFunction(e.jsonpCallback) ? e.jsonpCallback() : e.jsonpCallback;
                    // Insert callback into url or form data
                    if (s) e[s] = e[s].replace(Ut, "$1" + r); else if (!1 !== e.jsonp) e.url += (Ot.test(e.url) ? "&" : "?") + e.jsonp + "=" + r;
                    // Use data converter to retrieve json after script execution
                    e.converters["script json"] = function() {
                        if (!a) be.error(r + " was not called");
                        return a[0];
                    };
                    // Force json dataType
                    e.dataTypes[0] = "json";
                    // Install callback
                    o = n[r];
                    n[r] = function() {
                        a = arguments;
                    };
                    // Clean-up function (fires after converters)
                    i.always(function() {
                        // If previous value didn't exist - remove it
                        if (o === undefined) be(n).removeProp(r); else n[r] = o;
                        // Save back as free
                        if (e[r]) {
                            // Make sure that re-using the options doesn't screw things around
                            e.jsonpCallback = t.jsonpCallback;
                            // Save the callback name for future use
                            Qt.push(r);
                        }
                        // Call if it was a function and we have a response
                        if (a && be.isFunction(o)) o(a[0]);
                        a = o = undefined;
                    });
                    // Delegate to script
                    return "script";
                }
            });
            // Support: Safari 8 only
            // In Safari 8 documents created via document.implementation.createHTMLDocument
            // collapse sibling forms: the second one becomes a child of the first one.
            // Because of that, this security measure has to be disabled in Safari 8.
            // https://bugs.webkit.org/show_bug.cgi?id=137337
            me.createHTMLDocument = function() {
                var e = ae.implementation.createHTMLDocument("").body;
                e.innerHTML = "<form></form><form></form>";
                return 2 === e.childNodes.length;
            }();
            // Argument "data" should be string of html
            // context (optional): If specified, the fragment will be created in this context,
            // defaults to document
            // keepScripts (optional): If true, will include scripts passed in the html string
            be.parseHTML = function(e, t, n) {
                if ("string" !== typeof e) return [];
                if ("boolean" === typeof t) {
                    n = t;
                    t = !1;
                }
                var i, r, o;
                if (!t) // Stop scripts or inline event handlers from being executed immediately
                // by using document.implementation
                if (me.createHTMLDocument) {
                    t = ae.implementation.createHTMLDocument("");
                    // Set the base href for the created document
                    // so any parsed elements with URLs
                    // are based on the document's URL (gh-2965)
                    i = t.createElement("base");
                    i.href = ae.location.href;
                    t.head.appendChild(i);
                } else t = ae;
                r = Pe.exec(e);
                o = !n && [];
                // Single tag
                if (r) return [ t.createElement(r[1]) ];
                r = k([ e ], t, o);
                if (o && o.length) be(o).remove();
                return be.merge([], r.childNodes);
            };
            /**
 * Load a url into a page
 */
            be.fn.load = function(e, t, n) {
                var i, r, o, a = this, s = e.indexOf(" ");
                if (s > -1) {
                    i = Z(e.slice(s));
                    e = e.slice(0, s);
                }
                // If it's a function
                if (be.isFunction(t)) {
                    // We assume that it's the callback
                    n = t;
                    t = undefined;
                } else if (t && "object" === typeof t) r = "POST";
                // If we have elements to modify, make the request
                if (a.length > 0) be.ajax({
                    url: e,
                    // If "type" variable is undefined, then "GET" method will be used.
                    // Make value of this field explicit since
                    // user can override it through ajaxSetup method
                    type: r || "GET",
                    dataType: "html",
                    data: t
                }).done(function(e) {
                    // Save response for use in complete callback
                    o = arguments;
                    a.html(i ? // If a selector was specified, locate the right elements in a dummy div
                    // Exclude scripts to avoid IE 'Permission Denied' errors
                    be("<div>").append(be.parseHTML(e)).find(i) : // Otherwise use the full result
                    e);
                }).always(n && function(e, t) {
                    a.each(function() {
                        n.apply(this, o || [ e.responseText, t, e ]);
                    });
                });
                return this;
            };
            // Attach a bunch of functions for handling common AJAX events
            be.each([ "ajaxStart", "ajaxStop", "ajaxComplete", "ajaxError", "ajaxSuccess", "ajaxSend" ], function(e, t) {
                be.fn[t] = function(e) {
                    return this.on(t, e);
                };
            });
            be.expr.pseudos.animated = function(e) {
                return be.grep(be.timers, function(t) {
                    return e === t.elem;
                }).length;
            };
            be.offset = {
                setOffset: function(e, t, n) {
                    var i, r, o, a, s, l, u, c = be.css(e, "position"), f = be(e), d = {};
                    // Set position first, in-case top/left are set even on static elem
                    if ("static" === c) e.style.position = "relative";
                    s = f.offset();
                    o = be.css(e, "top");
                    l = be.css(e, "left");
                    u = ("absolute" === c || "fixed" === c) && (o + l).indexOf("auto") > -1;
                    // Need to be able to calculate position if either
                    // top or left is auto and position is either absolute or fixed
                    if (u) {
                        i = f.position();
                        a = i.top;
                        r = i.left;
                    } else {
                        a = parseFloat(o) || 0;
                        r = parseFloat(l) || 0;
                    }
                    if (be.isFunction(t)) // Use jQuery.extend here to allow modification of coordinates argument (gh-1848)
                    t = t.call(e, n, be.extend({}, s));
                    if (null != t.top) d.top = t.top - s.top + a;
                    if (null != t.left) d.left = t.left - s.left + r;
                    if ("using" in t) t.using.call(e, d); else f.css(d);
                }
            };
            be.fn.extend({
                offset: function(e) {
                    // Preserve chaining for setter
                    if (arguments.length) return e === undefined ? this : this.each(function(t) {
                        be.offset.setOffset(this, e, t);
                    });
                    var t, n, i, r, o = this[0];
                    if (!o) return;
                    // Return zeros for disconnected and hidden (display: none) elements (gh-2310)
                    // Support: IE <=11 only
                    // Running getBoundingClientRect on a
                    // disconnected node in IE throws an error
                    if (!o.getClientRects().length) return {
                        top: 0,
                        left: 0
                    };
                    i = o.getBoundingClientRect();
                    t = o.ownerDocument;
                    n = t.documentElement;
                    r = t.defaultView;
                    return {
                        top: i.top + r.pageYOffset - n.clientTop,
                        left: i.left + r.pageXOffset - n.clientLeft
                    };
                },
                position: function() {
                    if (!this[0]) return;
                    var e, t, n = this[0], i = {
                        top: 0,
                        left: 0
                    };
                    // Fixed elements are offset from window (parentOffset = {top:0, left: 0},
                    // because it is its only offset parent
                    if ("fixed" === be.css(n, "position")) // Assume getBoundingClientRect is there when computed position is fixed
                    t = n.getBoundingClientRect(); else {
                        // Get *real* offsetParent
                        e = this.offsetParent();
                        // Get correct offsets
                        t = this.offset();
                        if (!l(e[0], "html")) i = e.offset();
                        // Add offsetParent borders
                        i = {
                            top: i.top + be.css(e[0], "borderTopWidth", !0),
                            left: i.left + be.css(e[0], "borderLeftWidth", !0)
                        };
                    }
                    // Subtract parent offsets and element margins
                    return {
                        top: t.top - i.top - be.css(n, "marginTop", !0),
                        left: t.left - i.left - be.css(n, "marginLeft", !0)
                    };
                },
                // This method will return documentElement in the following cases:
                // 1) For the element inside the iframe without offsetParent, this method will return
                //    documentElement of the parent window
                // 2) For the hidden or detached element
                // 3) For body or html element, i.e. in case of the html node - it will return itself
                //
                // but those exceptions were never presented as a real life use-cases
                // and might be considered as more preferable results.
                //
                // This logic, however, is not guaranteed and can change at any point in the future
                offsetParent: function() {
                    return this.map(function() {
                        var e = this.offsetParent;
                        for (;e && "static" === be.css(e, "position"); ) e = e.offsetParent;
                        return e || et;
                    });
                }
            });
            // Create scrollLeft and scrollTop methods
            be.each({
                scrollLeft: "pageXOffset",
                scrollTop: "pageYOffset"
            }, function(e, t) {
                var n = "pageYOffset" === t;
                be.fn[e] = function(i) {
                    return He(this, function(e, i, r) {
                        // Coalesce documents and windows
                        var o;
                        if (be.isWindow(e)) o = e; else if (9 === e.nodeType) o = e.defaultView;
                        if (r === undefined) return o ? o[t] : e[i];
                        if (o) o.scrollTo(!n ? r : o.pageXOffset, n ? r : o.pageYOffset); else e[i] = r;
                    }, e, i, arguments.length);
                };
            });
            // Support: Safari <=7 - 9.1, Chrome <=37 - 49
            // Add the top/left cssHooks using jQuery.fn.position
            // Webkit bug: https://bugs.webkit.org/show_bug.cgi?id=29084
            // Blink bug: https://bugs.chromium.org/p/chromium/issues/detail?id=589347
            // getComputedStyle returns percent when specified for top/left/bottom/right;
            // rather than make the css module depend on the offset module, just check for it here
            be.each([ "top", "left" ], function(e, t) {
                be.cssHooks[t] = H(me.pixelPosition, function(e, n) {
                    if (n) {
                        n = I(e, t);
                        // If curCSS returns percentage, fallback to offset
                        return ct.test(n) ? be(e).position()[t] + "px" : n;
                    }
                });
            });
            // Create innerHeight, innerWidth, height, width, outerHeight and outerWidth methods
            be.each({
                Height: "height",
                Width: "width"
            }, function(e, t) {
                be.each({
                    padding: "inner" + e,
                    content: t,
                    "": "outer" + e
                }, function(n, i) {
                    // Margin is only for outerHeight, outerWidth
                    be.fn[i] = function(r, o) {
                        var a = arguments.length && (n || "boolean" !== typeof r), s = n || (!0 === r || !0 === o ? "margin" : "border");
                        return He(this, function(t, n, r) {
                            var o;
                            if (be.isWindow(t)) // $( window ).outerWidth/Height return w/h including scrollbars (gh-1729)
                            return 0 === i.indexOf("outer") ? t["inner" + e] : t.document.documentElement["client" + e];
                            // Get document width or height
                            if (9 === t.nodeType) {
                                o = t.documentElement;
                                // Either scroll[Width/Height] or offset[Width/Height] or client[Width/Height],
                                // whichever is greatest
                                return Math.max(t.body["scroll" + e], o["scroll" + e], t.body["offset" + e], o["offset" + e], o["client" + e]);
                            }
                            // Get width or height on the element, requesting but not forcing parseFloat
                            // Set width or height on the element
                            return r === undefined ? be.css(t, n, s) : be.style(t, n, r, s);
                        }, t, a ? r : undefined, a);
                    };
                });
            });
            be.fn.extend({
                bind: function(e, t, n) {
                    return this.on(e, null, t, n);
                },
                unbind: function(e, t) {
                    return this.off(e, null, t);
                },
                delegate: function(e, t, n, i) {
                    return this.on(t, e, n, i);
                },
                undelegate: function(e, t, n) {
                    // ( namespace ) or ( selector, types [, fn] )
                    return 1 === arguments.length ? this.off(e, "**") : this.off(t, e || "**", n);
                }
            });
            be.holdReady = function(e) {
                if (e) be.readyWait++; else be.ready(!0);
            };
            be.isArray = Array.isArray;
            be.parseJSON = JSON.parse;
            be.nodeName = l;
            // Register as a named AMD module, since jQuery can be concatenated with other
            // files that may use define, but not via a proper concatenation script that
            // understands anonymous AMD modules. A named AMD is safest and most robust
            // way to register. Lowercase jquery is used because AMD module names are
            // derived from file names, and jQuery is normally delivered in a lowercase
            // file name. Do this after creating the global so that if an AMD module wants
            // to call noConflict to hide this version of jQuery, it will work.
            // Note that for maximum portability, libraries that are not jQuery should
            // declare themselves as anonymous modules, and avoid setting a global if an
            // AMD loader is present. jQuery is a special case. For more information, see
            // https://github.com/jrburke/requirejs/wiki/Updating-existing-libraries#wiki-anon
            if (!0) i = [], (r = function() {
                return be;
            }.apply(t, i)) !== undefined && (e.exports = r);
            var // Map over jQuery in case of overwrite
            Gt = n.jQuery, // Map over the $ in case of overwrite
            Zt = n.$;
            be.noConflict = function(e) {
                if (n.$ === be) n.$ = Zt;
                if (e && n.jQuery === be) n.jQuery = Gt;
                return be;
            };
            // Expose jQuery and $ identifiers, even in AMD
            // (#7102#comment:10, https://github.com/jquery/jquery/pull/557)
            // and CommonJS for browser emulators (#13566)
            if (!o) n.jQuery = n.$ = be;
            return be;
        });
    },
    /***/
    115: /***/
    function(e, t) {
        /* WEBPACK VAR INJECTION */
        (function(t) {
            /* globals __webpack_amd_options__ */
            e.exports = t;
        }).call(t, {});
    },
    /***/
    116: /***/
    function(e, t, n) {
        var i;
        /*! Hammer.JS - v2.0.7 - 2016-04-22
 * http://hammerjs.github.io/
 *
 * Copyright (c) 2016 Jorik Tangelder;
 * Licensed under the MIT license */
        !function(r, o, a, s) {
            "use strict";
            /**
 * set a timeout with a given scope
 * @param {Function} fn
 * @param {Number} timeout
 * @param {Object} context
 * @returns {number}
 */
            function l(e, t, n) {
                return setTimeout(p(e, n), t);
            }
            /**
 * if the argument is an array, we want to execute the fn on each entry
 * if it aint an array we don't want to do a thing.
 * this is used by all the methods that accept a single and array argument.
 * @param {*|Array} arg
 * @param {String} fn
 * @param {Object} [context]
 * @returns {Boolean}
 */
            function u(e, t, n) {
                if (Array.isArray(e)) {
                    c(e, n[t], n);
                    return !0;
                }
                return !1;
            }
            /**
 * walk objects and arrays
 * @param {Object} obj
 * @param {Function} iterator
 * @param {Object} context
 */
            function c(e, t, n) {
                var i;
                if (!e) return;
                if (e.forEach) e.forEach(t, n); else if (e.length !== s) {
                    i = 0;
                    for (;i < e.length; ) {
                        t.call(n, e[i], i, e);
                        i++;
                    }
                } else for (i in e) e.hasOwnProperty(i) && t.call(n, e[i], i, e);
            }
            /**
 * wrap a method with a deprecation warning and stack trace
 * @param {Function} method
 * @param {String} name
 * @param {String} message
 * @returns {Function} A new function wrapping the supplied method.
 */
            function f(e, t, n) {
                var i = "DEPRECATED METHOD: " + t + "\n" + n + " AT \n";
                return function() {
                    var t = new Error("get-stack-trace");
                    var n = t && t.stack ? t.stack.replace(/^[^\(]+?[\n$]/gm, "").replace(/^\s+at\s+/gm, "").replace(/^Object.<anonymous>\s*\(/gm, "{anonymous}()@") : "Unknown Stack Trace";
                    var o = r.console && (r.console.warn || r.console.log);
                    if (o) o.call(r.console, i, n);
                    return e.apply(this, arguments);
                };
            }
            /**
 * simple class inheritance
 * @param {Function} child
 * @param {Function} base
 * @param {Object} [properties]
 */
            function d(e, t, n) {
                var i = t.prototype, r;
                r = e.prototype = Object.create(i);
                r.constructor = e;
                r._super = i;
                if (n) we(r, n);
            }
            /**
 * simple function bind
 * @param {Function} fn
 * @param {Object} context
 * @returns {Function}
 */
            function p(e, t) {
                return function n() {
                    return e.apply(t, arguments);
                };
            }
            /**
 * let a boolean value also be a function that must return a boolean
 * this first item in args will be used as the context
 * @param {Boolean|Function} val
 * @param {Array} [args]
 * @returns {Boolean}
 */
            function h(e, t) {
                if (typeof e == me) return e.apply(t ? t[0] || s : s, t);
                return e;
            }
            /**
 * use the val2 when val1 is undefined
 * @param {*} val1
 * @param {*} val2
 * @returns {*}
 */
            function v(e, t) {
                return e === s ? t : e;
            }
            /**
 * addEventListener with multiple events at once
 * @param {EventTarget} target
 * @param {String} types
 * @param {Function} handler
 */
            function g(e, t, n) {
                c(x(t), function(t) {
                    e.addEventListener(t, n, !1);
                });
            }
            /**
 * removeEventListener with multiple events at once
 * @param {EventTarget} target
 * @param {String} types
 * @param {Function} handler
 */
            function m(e, t, n) {
                c(x(t), function(t) {
                    e.removeEventListener(t, n, !1);
                });
            }
            /**
 * find if a node is in the given parent
 * @method hasParent
 * @param {HTMLElement} node
 * @param {HTMLElement} parent
 * @return {Boolean} found
 */
            function y(e, t) {
                for (;e; ) {
                    if (e == t) return !0;
                    e = e.parentNode;
                }
                return !1;
            }
            /**
 * small indexOf wrapper
 * @param {String} str
 * @param {String} find
 * @returns {Boolean} found
 */
            function b(e, t) {
                return e.indexOf(t) > -1;
            }
            /**
 * split string on whitespace
 * @param {String} str
 * @returns {Array} words
 */
            function x(e) {
                return e.trim().split(/\s+/g);
            }
            /**
 * find if a array contains the object using indexOf or a simple polyFill
 * @param {Array} src
 * @param {String} find
 * @param {String} [findByKey]
 * @return {Boolean|Number} false when not found, or the index
 */
            function w(e, t, n) {
                if (e.indexOf && !n) return e.indexOf(t); else {
                    var i = 0;
                    for (;i < e.length; ) {
                        if (n && e[i][n] == t || !n && e[i] === t) return i;
                        i++;
                    }
                    return -1;
                }
            }
            /**
 * convert array-like objects to real arrays
 * @param {Object} obj
 * @returns {Array}
 */
            function T(e) {
                return Array.prototype.slice.call(e, 0);
            }
            /**
 * unique array with objects based on a key (like 'id') or just by the array's value
 * @param {Array} src [{id:1},{id:2},{id:1}]
 * @param {String} [key]
 * @param {Boolean} [sort=False]
 * @returns {Array} [{id:1},{id:2}]
 */
            function C(e, t, n) {
                var i = [];
                var r = [];
                var o = 0;
                for (;o < e.length; ) {
                    var a = t ? e[o][t] : e[o];
                    if (w(r, a) < 0) i.push(e[o]);
                    r[o] = a;
                    o++;
                }
                if (n) if (!t) i = i.sort(); else i = i.sort(function s(e, n) {
                    return e[t] > n[t];
                });
                return i;
            }
            /**
 * get the prefixed property
 * @param {Object} obj
 * @param {String} property
 * @returns {String|Undefined} prefixed
 */
            function k(e, t) {
                var n, i;
                var r = t[0].toUpperCase() + t.slice(1);
                var o = 0;
                for (;o < ve.length; ) {
                    n = ve[o];
                    i = n ? n + r : t;
                    if (i in e) return i;
                    o++;
                }
                return s;
            }
            function S() {
                return ke++;
            }
            /**
 * get the window object of an element
 * @param {HTMLElement} element
 * @returns {DocumentView|Window}
 */
            function E(e) {
                var t = e.ownerDocument || e;
                return t.defaultView || t.parentWindow || r;
            }
            /**
 * create new input type manager
 * @param {Manager} manager
 * @param {Function} callback
 * @returns {Input}
 * @constructor
 */
            function A(e, t) {
                var n = this;
                this.manager = e;
                this.callback = t;
                this.element = e.element;
                this.target = e.options.inputTarget;
                // smaller wrapper around the handler, for the scope and the enabled state of the manager,
                // so when disabled the input events are completely bypassed.
                this.domHandler = function(t) {
                    if (h(e.options.enable, [ e ])) n.handler(t);
                };
                this.init();
            }
            /**
 * create new input type manager
 * called by the Manager constructor
 * @param {Hammer} manager
 * @returns {Input}
 */
            function P(e) {
                var t;
                var n = e.options.inputClass;
                if (n) t = n; else if (Ae) t = $; else if (Pe) t = X; else if (!Ee) t = W; else t = Y;
                return new t(e, D);
            }
            /**
 * handle input events
 * @param {Manager} manager
 * @param {String} eventType
 * @param {Object} input
 */
            function D(e, t, n) {
                var i = n.pointers.length;
                var r = n.changedPointers.length;
                var o = t & Me && i - r === 0;
                var a = t & (Ie | He) && i - r === 0;
                n.isFirst = !!o;
                n.isFinal = !!a;
                if (o) e.session = {};
                // source event is the normalized value of the domEvents
                // like 'touchstart, mouseup, pointerdown'
                n.eventType = t;
                // compute scale, rotation etc
                O(e, n);
                // emit secret event
                e.emit("hammer.input", n);
                e.recognize(n);
                e.session.prevInput = n;
            }
            /**
 * extend the data with some usable properties like scale, rotate, velocity etc
 * @param {Object} manager
 * @param {Object} input
 */
            function O(e, t) {
                var n = e.session;
                var i = t.pointers;
                var r = i.length;
                // store the first input to calculate the distance and direction
                if (!n.firstInput) n.firstInput = j(t);
                // to compute scale and rotation we need to store the multiple touches
                if (r > 1 && !n.firstMultiple) n.firstMultiple = j(t); else if (1 === r) n.firstMultiple = !1;
                var o = n.firstInput;
                var a = n.firstMultiple;
                var s = a ? a.center : o.center;
                var l = t.center = M(i);
                t.timeStamp = xe();
                t.deltaTime = t.timeStamp - o.timeStamp;
                t.angle = _(s, l);
                t.distance = H(s, l);
                N(n, t);
                t.offsetDirection = I(t.deltaX, t.deltaY);
                var u = L(t.deltaTime, t.deltaX, t.deltaY);
                t.overallVelocityX = u.x;
                t.overallVelocityY = u.y;
                t.overallVelocity = be(u.x) > be(u.y) ? u.x : u.y;
                t.scale = a ? R(a.pointers, i) : 1;
                t.rotation = a ? F(a.pointers, i) : 0;
                t.maxPointers = !n.prevInput ? t.pointers.length : t.pointers.length > n.prevInput.maxPointers ? t.pointers.length : n.prevInput.maxPointers;
                q(n, t);
                // find the correct target
                var c = e.element;
                if (y(t.srcEvent.target, c)) c = t.srcEvent.target;
                t.target = c;
            }
            function N(e, t) {
                var n = t.center;
                var i = e.offsetDelta || {};
                var r = e.prevDelta || {};
                var o = e.prevInput || {};
                if (t.eventType === Me || o.eventType === Ie) {
                    r = e.prevDelta = {
                        x: o.deltaX || 0,
                        y: o.deltaY || 0
                    };
                    i = e.offsetDelta = {
                        x: n.x,
                        y: n.y
                    };
                }
                t.deltaX = r.x + (n.x - i.x);
                t.deltaY = r.y + (n.y - i.y);
            }
            /**
 * velocity is calculated every x ms
 * @param {Object} session
 * @param {Object} input
 */
            function q(e, t) {
                var n = e.lastInterval || t, i = t.timeStamp - n.timeStamp, r, o, a, l;
                if (t.eventType != He && (i > je || n.velocity === s)) {
                    var u = t.deltaX - n.deltaX;
                    var c = t.deltaY - n.deltaY;
                    var f = L(i, u, c);
                    o = f.x;
                    a = f.y;
                    r = be(f.x) > be(f.y) ? f.x : f.y;
                    l = I(u, c);
                    e.lastInterval = t;
                } else {
                    // use latest velocity info if it doesn't overtake a minimum period
                    r = n.velocity;
                    o = n.velocityX;
                    a = n.velocityY;
                    l = n.direction;
                }
                t.velocity = r;
                t.velocityX = o;
                t.velocityY = a;
                t.direction = l;
            }
            /**
 * create a simple clone from the input used for storage of firstInput and firstMultiple
 * @param {Object} input
 * @returns {Object} clonedInputData
 */
            function j(e) {
                // make a simple copy of the pointers because we will get a reference if we don't
                // we only need clientXY for the calculations
                var t = [];
                var n = 0;
                for (;n < e.pointers.length; ) {
                    t[n] = {
                        clientX: ye(e.pointers[n].clientX),
                        clientY: ye(e.pointers[n].clientY)
                    };
                    n++;
                }
                return {
                    timeStamp: xe(),
                    pointers: t,
                    center: M(t),
                    deltaX: e.deltaX,
                    deltaY: e.deltaY
                };
            }
            /**
 * get the center of all the pointers
 * @param {Array} pointers
 * @return {Object} center contains `x` and `y` properties
 */
            function M(e) {
                var t = e.length;
                // no need to loop when only one touch
                if (1 === t) return {
                    x: ye(e[0].clientX),
                    y: ye(e[0].clientY)
                };
                var n = 0, i = 0, r = 0;
                for (;r < t; ) {
                    n += e[r].clientX;
                    i += e[r].clientY;
                    r++;
                }
                return {
                    x: ye(n / t),
                    y: ye(i / t)
                };
            }
            /**
 * calculate the velocity between two points. unit is in px per ms.
 * @param {Number} deltaTime
 * @param {Number} x
 * @param {Number} y
 * @return {Object} velocity `x` and `y`
 */
            function L(e, t, n) {
                return {
                    x: t / e || 0,
                    y: n / e || 0
                };
            }
            /**
 * get the direction between two points
 * @param {Number} x
 * @param {Number} y
 * @return {Number} direction
 */
            function I(e, t) {
                if (e === t) return _e;
                if (be(e) >= be(t)) return e < 0 ? Fe : Re;
                return t < 0 ? We : $e;
            }
            /**
 * calculate the absolute distance between two points
 * @param {Object} p1 {x, y}
 * @param {Object} p2 {x, y}
 * @param {Array} [props] containing x and y keys
 * @return {Number} distance
 */
            function H(e, t, n) {
                if (!n) n = Be;
                var i = t[n[0]] - e[n[0]], r = t[n[1]] - e[n[1]];
                return Math.sqrt(i * i + r * r);
            }
            /**
 * calculate the angle between two coordinates
 * @param {Object} p1
 * @param {Object} p2
 * @param {Array} [props] containing x and y keys
 * @return {Number} angle
 */
            function _(e, t, n) {
                if (!n) n = Be;
                var i = t[n[0]] - e[n[0]], r = t[n[1]] - e[n[1]];
                return 180 * Math.atan2(r, i) / Math.PI;
            }
            /**
 * calculate the rotation degrees between two pointersets
 * @param {Array} start array of pointers
 * @param {Array} end array of pointers
 * @return {Number} rotation
 */
            function F(e, t) {
                return _(t[1], t[0], Ye) + _(e[1], e[0], Ye);
            }
            /**
 * calculate the scale factor between two pointersets
 * no scale is 1, and goes down to 0 when pinched together, and bigger when pinched out
 * @param {Array} start array of pointers
 * @param {Array} end array of pointers
 * @return {Number} scale
 */
            function R(e, t) {
                return H(t[0], t[1], Ye) / H(e[0], e[1], Ye);
            }
            /**
 * Mouse events input
 * @constructor
 * @extends Input
 */
            function W() {
                this.evEl = Ue;
                this.evWin = Ge;
                this.pressed = !1;
                // mousedown state
                A.apply(this, arguments);
            }
            /**
 * Pointer events input
 * @constructor
 * @extends Input
 */
            function $() {
                this.evEl = Ke;
                this.evWin = et;
                A.apply(this, arguments);
                this.store = this.manager.session.pointerEvents = [];
            }
            /**
 * Touch events input
 * @constructor
 * @extends Input
 */
            function z() {
                this.evTarget = nt;
                this.evWin = it;
                this.started = !1;
                A.apply(this, arguments);
            }
            /**
 * @this {TouchInput}
 * @param {Object} ev
 * @param {Number} type flag
 * @returns {undefined|Array} [all, changed]
 */
            function V(e, t) {
                var n = T(e.touches);
                var i = T(e.changedTouches);
                if (t & (Ie | He)) n = C(n.concat(i), "identifier", !0);
                return [ n, i ];
            }
            /**
 * Multi-user touch events input
 * @constructor
 * @extends Input
 */
            function X() {
                this.evTarget = ot;
                this.targetIds = {};
                A.apply(this, arguments);
            }
            /**
 * @this {TouchInput}
 * @param {Object} ev
 * @param {Number} type flag
 * @returns {undefined|Array} [all, changed]
 */
            function B(e, t) {
                var n = T(e.touches);
                var i = this.targetIds;
                // when there is only one touch, the process can be simplified
                if (t & (Me | Le) && 1 === n.length) {
                    i[n[0].identifier] = !0;
                    return [ n, n ];
                }
                var r, o, a = T(e.changedTouches), s = [], l = this.target;
                // get target touches from touches
                o = n.filter(function(e) {
                    return y(e.target, l);
                });
                // collect touches
                if (t === Me) {
                    r = 0;
                    for (;r < o.length; ) {
                        i[o[r].identifier] = !0;
                        r++;
                    }
                }
                // filter changed touches to only contain touches that exist in the collected target ids
                r = 0;
                for (;r < a.length; ) {
                    if (i[a[r].identifier]) s.push(a[r]);
                    // cleanup removed touches
                    if (t & (Ie | He)) delete i[a[r].identifier];
                    r++;
                }
                if (!s.length) return;
                return [ // merge targetTouches with changedTargetTouches so it contains ALL touches, including 'end' and 'cancel'
                C(o.concat(s), "identifier", !0), s ];
            }
            function Y() {
                A.apply(this, arguments);
                var e = p(this.handler, this);
                this.touch = new X(this.manager, e);
                this.mouse = new W(this.manager, e);
                this.primaryTouch = null;
                this.lastTouches = [];
            }
            function Q(e, t) {
                if (e & Me) {
                    this.primaryTouch = t.changedPointers[0].identifier;
                    U.call(this, t);
                } else if (e & (Ie | He)) U.call(this, t);
            }
            function U(e) {
                var t = e.changedPointers[0];
                if (t.identifier === this.primaryTouch) {
                    var n = {
                        x: t.clientX,
                        y: t.clientY
                    };
                    this.lastTouches.push(n);
                    var i = this.lastTouches;
                    var r = function() {
                        var e = i.indexOf(n);
                        if (e > -1) i.splice(e, 1);
                    };
                    setTimeout(r, at);
                }
            }
            function G(e) {
                var t = e.srcEvent.clientX, n = e.srcEvent.clientY;
                for (var i = 0; i < this.lastTouches.length; i++) {
                    var r = this.lastTouches[i];
                    var o = Math.abs(t - r.x), a = Math.abs(n - r.y);
                    if (o <= st && a <= st) return !0;
                }
                return !1;
            }
            /**
 * Touch Action
 * sets the touchAction property or uses the js alternative
 * @param {Manager} manager
 * @param {String} value
 * @constructor
 */
            function Z(e, t) {
                this.manager = e;
                this.set(t);
            }
            /**
 * when the touchActions are collected they are not a valid value, so we need to clean things up. *
 * @param {String} actions
 * @returns {*}
 */
            function J(e) {
                // none
                if (b(e, pt)) return pt;
                var t = b(e, ht);
                var n = b(e, vt);
                // if both pan-x and pan-y are set (different recognizers
                // for different directions, e.g. horizontal pan but vertical swipe?)
                // we need none (as otherwise with pan-x pan-y combined none of these
                // recognizers will work, since the browser would handle all panning
                if (t && n) return pt;
                // pan-x OR pan-y
                if (t || n) return t ? ht : vt;
                // manipulation
                if (b(e, dt)) return dt;
                return ft;
            }
            function K() {
                if (!ut) return !1;
                var e = {};
                var t = r.CSS && r.CSS.supports;
                [ "auto", "manipulation", "pan-y", "pan-x", "pan-x pan-y", "none" ].forEach(function(n) {
                    // If css.supports is not supported but there is native touch-action assume it supports
                    // all values. This is the case for IE 10 and 11.
                    e[n] = t ? r.CSS.supports("touch-action", n) : !0;
                });
                return e;
            }
            /**
 * Recognizer
 * Every recognizer needs to extend from this class.
 * @constructor
 * @param {Object} options
 */
            function ee(e) {
                this.options = we({}, this.defaults, e || {});
                this.id = S();
                this.manager = null;
                // default is enable true
                this.options.enable = v(this.options.enable, !0);
                this.state = mt;
                this.simultaneous = {};
                this.requireFail = [];
            }
            /**
 * get a usable string, used as event postfix
 * @param {Const} state
 * @returns {String} state
 */
            function te(e) {
                if (e & Tt) return "cancel"; else if (e & xt) return "end"; else if (e & bt) return "move"; else if (e & yt) return "start";
                return "";
            }
            /**
 * direction cons to string
 * @param {Const} direction
 * @returns {String}
 */
            function ne(e) {
                if (e == $e) return "down"; else if (e == We) return "up"; else if (e == Fe) return "left"; else if (e == Re) return "right";
                return "";
            }
            /**
 * get a recognizer by name if it is bound to a manager
 * @param {Recognizer|String} otherRecognizer
 * @param {Recognizer} recognizer
 * @returns {Recognizer}
 */
            function ie(e, t) {
                var n = t.manager;
                if (n) return n.get(e);
                return e;
            }
            /**
 * This recognizer is just used as a base for the simple attribute recognizers.
 * @constructor
 * @extends Recognizer
 */
            function re() {
                ee.apply(this, arguments);
            }
            /**
 * Pan
 * Recognized when the pointer is down and moved in the allowed direction.
 * @constructor
 * @extends AttrRecognizer
 */
            function oe() {
                re.apply(this, arguments);
                this.pX = null;
                this.pY = null;
            }
            /**
 * Pinch
 * Recognized when two or more pointers are moving toward (zoom-in) or away from each other (zoom-out).
 * @constructor
 * @extends AttrRecognizer
 */
            function ae() {
                re.apply(this, arguments);
            }
            /**
 * Press
 * Recognized when the pointer is down for x ms without any movement.
 * @constructor
 * @extends Recognizer
 */
            function se() {
                ee.apply(this, arguments);
                this._timer = null;
                this._input = null;
            }
            /**
 * Rotate
 * Recognized when two or more pointer are moving in a circular motion.
 * @constructor
 * @extends AttrRecognizer
 */
            function le() {
                re.apply(this, arguments);
            }
            /**
 * Swipe
 * Recognized when the pointer is moving fast (velocity), with enough distance in the allowed direction.
 * @constructor
 * @extends AttrRecognizer
 */
            function ue() {
                re.apply(this, arguments);
            }
            /**
 * A tap is ecognized when the pointer is doing a small tap/click. Multiple taps are recognized if they occur
 * between the given interval and position. The delay option can be used to recognize multi-taps without firing
 * a single tap.
 *
 * The eventData from the emitted event contains the property `tapCount`, which contains the amount of
 * multi-taps being recognized.
 * @constructor
 * @extends Recognizer
 */
            function ce() {
                ee.apply(this, arguments);
                // previous time and center,
                // used for tap counting
                this.pTime = !1;
                this.pCenter = !1;
                this._timer = null;
                this._input = null;
                this.count = 0;
            }
            /**
 * Simple way to create a manager with a default set of recognizers.
 * @param {HTMLElement} element
 * @param {Object} [options]
 * @constructor
 */
            function fe(e, t) {
                t = t || {};
                t.recognizers = v(t.recognizers, fe.defaults.preset);
                return new de(e, t);
            }
            /**
 * Manager
 * @param {HTMLElement} element
 * @param {Object} [options]
 * @constructor
 */
            function de(e, t) {
                this.options = we({}, fe.defaults, t || {});
                this.options.inputTarget = this.options.inputTarget || e;
                this.handlers = {};
                this.session = {};
                this.recognizers = [];
                this.oldCssProps = {};
                this.element = e;
                this.input = P(this);
                this.touchAction = new Z(this, this.options.touchAction);
                pe(this, !0);
                c(this.options.recognizers, function(e) {
                    var t = this.add(new e[0](e[1]));
                    e[2] && t.recognizeWith(e[2]);
                    e[3] && t.requireFailure(e[3]);
                }, this);
            }
            /**
 * add/remove the css properties as defined in manager.options.cssProps
 * @param {Manager} manager
 * @param {Boolean} add
 */
            function pe(e, t) {
                var n = e.element;
                if (!n.style) return;
                var i;
                c(e.options.cssProps, function(r, o) {
                    i = k(n.style, o);
                    if (t) {
                        e.oldCssProps[i] = n.style[i];
                        n.style[i] = r;
                    } else n.style[i] = e.oldCssProps[i] || "";
                });
                if (!t) e.oldCssProps = {};
            }
            /**
 * trigger dom event
 * @param {String} event
 * @param {Object} data
 */
            function he(e, t) {
                var n = o.createEvent("Event");
                n.initEvent(e, !0, !0);
                n.gesture = t;
                t.target.dispatchEvent(n);
            }
            var ve = [ "", "webkit", "Moz", "MS", "ms", "o" ];
            var ge = o.createElement("div");
            var me = "function";
            var ye = Math.round;
            var be = Math.abs;
            var xe = Date.now;
            /**
 * extend object.
 * means that properties in dest will be overwritten by the ones in src.
 * @param {Object} target
 * @param {...Object} objects_to_assign
 * @returns {Object} target
 */
            var we;
            if ("function" !== typeof Object.assign) we = function Et(e) {
                if (e === s || null === e) throw new TypeError("Cannot convert undefined or null to object");
                var t = Object(e);
                for (var n = 1; n < arguments.length; n++) {
                    var i = arguments[n];
                    if (i !== s && null !== i) for (var r in i) if (i.hasOwnProperty(r)) t[r] = i[r];
                }
                return t;
            }; else we = Object.assign;
            /**
 * extend object.
 * means that properties in dest will be overwritten by the ones in src.
 * @param {Object} dest
 * @param {Object} src
 * @param {Boolean} [merge=false]
 * @returns {Object} dest
 */
            var Te = f(function At(e, t, n) {
                var i = Object.keys(t);
                var r = 0;
                for (;r < i.length; ) {
                    if (!n || n && e[i[r]] === s) e[i[r]] = t[i[r]];
                    r++;
                }
                return e;
            }, "extend", "Use `assign`.");
            /**
 * merge the values from src in the dest.
 * means that properties that exist in dest will not be overwritten by src
 * @param {Object} dest
 * @param {Object} src
 * @returns {Object} dest
 */
            var Ce = f(function Pt(e, t) {
                return Te(e, t, !0);
            }, "merge", "Use `assign`.");
            /**
 * get a unique id
 * @returns {number} uniqueId
 */
            var ke = 1;
            var Se = /mobile|tablet|ip(ad|hone|od)|android/i;
            var Ee = "ontouchstart" in r;
            var Ae = k(r, "PointerEvent") !== s;
            var Pe = Ee && Se.test(navigator.userAgent);
            var De = "touch";
            var Oe = "pen";
            var Ne = "mouse";
            var qe = "kinect";
            var je = 25;
            var Me = 1;
            var Le = 2;
            var Ie = 4;
            var He = 8;
            var _e = 1;
            var Fe = 2;
            var Re = 4;
            var We = 8;
            var $e = 16;
            var ze = Fe | Re;
            var Ve = We | $e;
            var Xe = ze | Ve;
            var Be = [ "x", "y" ];
            var Ye = [ "clientX", "clientY" ];
            A.prototype = {
                /**
     * should handle the inputEvent data and trigger the callback
     * @virtual
     */
                handler: function() {},
                /**
     * bind the events
     */
                init: function() {
                    this.evEl && g(this.element, this.evEl, this.domHandler);
                    this.evTarget && g(this.target, this.evTarget, this.domHandler);
                    this.evWin && g(E(this.element), this.evWin, this.domHandler);
                },
                /**
     * unbind the events
     */
                destroy: function() {
                    this.evEl && m(this.element, this.evEl, this.domHandler);
                    this.evTarget && m(this.target, this.evTarget, this.domHandler);
                    this.evWin && m(E(this.element), this.evWin, this.domHandler);
                }
            };
            var Qe = {
                mousedown: Me,
                mousemove: Le,
                mouseup: Ie
            };
            var Ue = "mousedown";
            var Ge = "mousemove mouseup";
            d(W, A, {
                /**
     * handle mouse events
     * @param {Object} ev
     */
                handler: function Dt(e) {
                    var t = Qe[e.type];
                    // on start we want to have the left mouse button down
                    if (t & Me && 0 === e.button) this.pressed = !0;
                    if (t & Le && 1 !== e.which) t = Ie;
                    // mouse must be down
                    if (!this.pressed) return;
                    if (t & Ie) this.pressed = !1;
                    this.callback(this.manager, t, {
                        pointers: [ e ],
                        changedPointers: [ e ],
                        pointerType: Ne,
                        srcEvent: e
                    });
                }
            });
            var Ze = {
                pointerdown: Me,
                pointermove: Le,
                pointerup: Ie,
                pointercancel: He,
                pointerout: He
            };
            // in IE10 the pointer types is defined as an enum
            var Je = {
                2: De,
                3: Oe,
                4: Ne,
                5: qe
            };
            var Ke = "pointerdown";
            var et = "pointermove pointerup pointercancel";
            // IE10 has prefixed support, and case-sensitive
            if (r.MSPointerEvent && !r.PointerEvent) {
                Ke = "MSPointerDown";
                et = "MSPointerMove MSPointerUp MSPointerCancel";
            }
            d($, A, {
                /**
     * handle mouse events
     * @param {Object} ev
     */
                handler: function Ot(e) {
                    var t = this.store;
                    var n = !1;
                    var i = e.type.toLowerCase().replace("ms", "");
                    var r = Ze[i];
                    var o = Je[e.pointerType] || e.pointerType;
                    var a = o == De;
                    // get index of the event in the store
                    var s = w(t, e.pointerId, "pointerId");
                    // start and mouse must be down
                    if (r & Me && (0 === e.button || a)) {
                        if (s < 0) {
                            t.push(e);
                            s = t.length - 1;
                        }
                    } else if (r & (Ie | He)) n = !0;
                    // it not found, so the pointer hasn't been down (so it's probably a hover)
                    if (s < 0) return;
                    // update the event in the store
                    t[s] = e;
                    this.callback(this.manager, r, {
                        pointers: t,
                        changedPointers: [ e ],
                        pointerType: o,
                        srcEvent: e
                    });
                    if (n) // remove from the store
                    t.splice(s, 1);
                }
            });
            var tt = {
                touchstart: Me,
                touchmove: Le,
                touchend: Ie,
                touchcancel: He
            };
            var nt = "touchstart";
            var it = "touchstart touchmove touchend touchcancel";
            d(z, A, {
                handler: function Nt(e) {
                    var t = tt[e.type];
                    // should we handle the touch events?
                    if (t === Me) this.started = !0;
                    if (!this.started) return;
                    var n = V.call(this, e, t);
                    // when done, reset the started state
                    if (t & (Ie | He) && n[0].length - n[1].length === 0) this.started = !1;
                    this.callback(this.manager, t, {
                        pointers: n[0],
                        changedPointers: n[1],
                        pointerType: De,
                        srcEvent: e
                    });
                }
            });
            var rt = {
                touchstart: Me,
                touchmove: Le,
                touchend: Ie,
                touchcancel: He
            };
            var ot = "touchstart touchmove touchend touchcancel";
            d(X, A, {
                handler: function qt(e) {
                    var t = rt[e.type];
                    var n = B.call(this, e, t);
                    if (!n) return;
                    this.callback(this.manager, t, {
                        pointers: n[0],
                        changedPointers: n[1],
                        pointerType: De,
                        srcEvent: e
                    });
                }
            });
            /**
 * Combined touch and mouse input
 *
 * Touch has a higher priority then mouse, and while touching no mouse events are allowed.
 * This because touch devices also emit mouse events while doing a touch.
 *
 * @constructor
 * @extends Input
 */
            var at = 2500;
            var st = 25;
            d(Y, A, {
                /**
     * handle mouse and touch events
     * @param {Hammer} manager
     * @param {String} inputEvent
     * @param {Object} inputData
     */
                handler: function jt(e, t, n) {
                    var i = n.pointerType == De, r = n.pointerType == Ne;
                    if (r && n.sourceCapabilities && n.sourceCapabilities.firesTouchEvents) return;
                    // when we're in a touch event, record touches to  de-dupe synthetic mouse event
                    if (i) Q.call(this, t, n); else if (r && G.call(this, n)) return;
                    this.callback(e, t, n);
                },
                /**
     * remove the event listeners
     */
                destroy: function Mt() {
                    this.touch.destroy();
                    this.mouse.destroy();
                }
            });
            var lt = k(ge.style, "touchAction");
            var ut = lt !== s;
            // magical touchAction value
            var ct = "compute";
            var ft = "auto";
            var dt = "manipulation";
            // not implemented
            var pt = "none";
            var ht = "pan-x";
            var vt = "pan-y";
            var gt = K();
            Z.prototype = {
                /**
     * set the touchAction value on the element or enable the polyfill
     * @param {String} value
     */
                set: function(e) {
                    // find out the touch-action by the event handlers
                    if (e == ct) e = this.compute();
                    if (ut && this.manager.element.style && gt[e]) this.manager.element.style[lt] = e;
                    this.actions = e.toLowerCase().trim();
                },
                /**
     * just re-set the touchAction value
     */
                update: function() {
                    this.set(this.manager.options.touchAction);
                },
                /**
     * compute the value for the touchAction property based on the recognizer's settings
     * @returns {String} value
     */
                compute: function() {
                    var e = [];
                    c(this.manager.recognizers, function(t) {
                        if (h(t.options.enable, [ t ])) e = e.concat(t.getTouchAction());
                    });
                    return J(e.join(" "));
                },
                /**
     * this method is called on each input cycle and provides the preventing of the browser behavior
     * @param {Object} input
     */
                preventDefaults: function(e) {
                    var t = e.srcEvent;
                    var n = e.offsetDirection;
                    // if the touch action did prevented once this session
                    if (this.manager.session.prevented) {
                        t.preventDefault();
                        return;
                    }
                    var i = this.actions;
                    var r = b(i, pt) && !gt[pt];
                    var o = b(i, vt) && !gt[vt];
                    var a = b(i, ht) && !gt[ht];
                    if (r) {
                        //do not prevent defaults if this is a tap gesture
                        var s = 1 === e.pointers.length;
                        var l = e.distance < 2;
                        var u = e.deltaTime < 250;
                        if (s && l && u) return;
                    }
                    if (a && o) // `pan-x pan-y` means browser handles all scrolling/panning, do not prevent
                    return;
                    if (r || o && n & ze || a && n & Ve) return this.preventSrc(t);
                },
                /**
     * call preventDefault to prevent the browser's default behavior (scrolling in most cases)
     * @param {Object} srcEvent
     */
                preventSrc: function(e) {
                    this.manager.session.prevented = !0;
                    e.preventDefault();
                }
            };
            /**
 * Recognizer flow explained; *
 * All recognizers have the initial state of POSSIBLE when a input session starts.
 * The definition of a input session is from the first input until the last input, with all it's movement in it. *
 * Example session for mouse-input: mousedown -> mousemove -> mouseup
 *
 * On each recognizing cycle (see Manager.recognize) the .recognize() method is executed
 * which determines with state it should be.
 *
 * If the recognizer has the state FAILED, CANCELLED or RECOGNIZED (equals ENDED), it is reset to
 * POSSIBLE to give it another change on the next cycle.
 *
 *               Possible
 *                  |
 *            +-----+---------------+
 *            |                     |
 *      +-----+-----+               |
 *      |           |               |
 *   Failed      Cancelled          |
 *                          +-------+------+
 *                          |              |
 *                      Recognized       Began
 *                                         |
 *                                      Changed
 *                                         |
 *                                  Ended/Recognized
 */
            var mt = 1;
            var yt = 2;
            var bt = 4;
            var xt = 8;
            var wt = xt;
            var Tt = 16;
            var Ct = 32;
            ee.prototype = {
                /**
     * @virtual
     * @type {Object}
     */
                defaults: {},
                /**
     * set options
     * @param {Object} options
     * @return {Recognizer}
     */
                set: function(e) {
                    we(this.options, e);
                    // also update the touchAction, in case something changed about the directions/enabled state
                    this.manager && this.manager.touchAction.update();
                    return this;
                },
                /**
     * recognize simultaneous with an other recognizer.
     * @param {Recognizer} otherRecognizer
     * @returns {Recognizer} this
     */
                recognizeWith: function(e) {
                    if (u(e, "recognizeWith", this)) return this;
                    var t = this.simultaneous;
                    e = ie(e, this);
                    if (!t[e.id]) {
                        t[e.id] = e;
                        e.recognizeWith(this);
                    }
                    return this;
                },
                /**
     * drop the simultaneous link. it doesnt remove the link on the other recognizer.
     * @param {Recognizer} otherRecognizer
     * @returns {Recognizer} this
     */
                dropRecognizeWith: function(e) {
                    if (u(e, "dropRecognizeWith", this)) return this;
                    e = ie(e, this);
                    delete this.simultaneous[e.id];
                    return this;
                },
                /**
     * recognizer can only run when an other is failing
     * @param {Recognizer} otherRecognizer
     * @returns {Recognizer} this
     */
                requireFailure: function(e) {
                    if (u(e, "requireFailure", this)) return this;
                    var t = this.requireFail;
                    e = ie(e, this);
                    if (-1 === w(t, e)) {
                        t.push(e);
                        e.requireFailure(this);
                    }
                    return this;
                },
                /**
     * drop the requireFailure link. it does not remove the link on the other recognizer.
     * @param {Recognizer} otherRecognizer
     * @returns {Recognizer} this
     */
                dropRequireFailure: function(e) {
                    if (u(e, "dropRequireFailure", this)) return this;
                    e = ie(e, this);
                    var t = w(this.requireFail, e);
                    if (t > -1) this.requireFail.splice(t, 1);
                    return this;
                },
                /**
     * has require failures boolean
     * @returns {boolean}
     */
                hasRequireFailures: function() {
                    return this.requireFail.length > 0;
                },
                /**
     * if the recognizer can recognize simultaneous with an other recognizer
     * @param {Recognizer} otherRecognizer
     * @returns {Boolean}
     */
                canRecognizeWith: function(e) {
                    return !!this.simultaneous[e.id];
                },
                /**
     * You should use `tryEmit` instead of `emit` directly to check
     * that all the needed recognizers has failed before emitting.
     * @param {Object} input
     */
                emit: function(e) {
                    function t(t) {
                        n.manager.emit(t, e);
                    }
                    var n = this;
                    var i = this.state;
                    // 'panstart' and 'panmove'
                    if (i < xt) t(n.options.event + te(i));
                    t(n.options.event);
                    // simple 'eventName' events
                    if (e.additionalEvent) // additional event(panleft, panright, pinchin, pinchout...)
                    t(e.additionalEvent);
                    // panend and pancancel
                    if (i >= xt) t(n.options.event + te(i));
                },
                /**
     * Check that all the require failure recognizers has failed,
     * if true, it emits a gesture event,
     * otherwise, setup the state to FAILED.
     * @param {Object} input
     */
                tryEmit: function(e) {
                    if (this.canEmit()) return this.emit(e);
                    // it's failing anyway
                    this.state = Ct;
                },
                /**
     * can we emit?
     * @returns {boolean}
     */
                canEmit: function() {
                    var e = 0;
                    for (;e < this.requireFail.length; ) {
                        if (!(this.requireFail[e].state & (Ct | mt))) return !1;
                        e++;
                    }
                    return !0;
                },
                /**
     * update the recognizer
     * @param {Object} inputData
     */
                recognize: function(e) {
                    // make a new copy of the inputData
                    // so we can change the inputData without messing up the other recognizers
                    var t = we({}, e);
                    // is is enabled and allow recognizing?
                    if (!h(this.options.enable, [ this, t ])) {
                        this.reset();
                        this.state = Ct;
                        return;
                    }
                    // reset when we've reached the end
                    if (this.state & (wt | Tt | Ct)) this.state = mt;
                    this.state = this.process(t);
                    // the recognizer has recognized a gesture
                    // so trigger an event
                    if (this.state & (yt | bt | xt | Tt)) this.tryEmit(t);
                },
                /**
     * return the state of the recognizer
     * the actual recognizing happens in this method
     * @virtual
     * @param {Object} inputData
     * @returns {Const} STATE
     */
                process: function(e) {},
                // jshint ignore:line
                /**
     * return the preferred touch-action
     * @virtual
     * @returns {Array}
     */
                getTouchAction: function() {},
                /**
     * called when the gesture isn't allowed to recognize
     * like when another is being recognized or it is disabled
     * @virtual
     */
                reset: function() {}
            };
            d(re, ee, {
                /**
     * @namespace
     * @memberof AttrRecognizer
     */
                defaults: {
                    /**
         * @type {Number}
         * @default 1
         */
                    pointers: 1
                },
                /**
     * Used to check if it the recognizer receives valid input, like input.distance > 10.
     * @memberof AttrRecognizer
     * @param {Object} input
     * @returns {Boolean} recognized
     */
                attrTest: function(e) {
                    var t = this.options.pointers;
                    return 0 === t || e.pointers.length === t;
                },
                /**
     * Process the input and return the state for the recognizer
     * @memberof AttrRecognizer
     * @param {Object} input
     * @returns {*} State
     */
                process: function(e) {
                    var t = this.state;
                    var n = e.eventType;
                    var i = t & (yt | bt);
                    var r = this.attrTest(e);
                    // on cancel input and we've recognized before, return STATE_CANCELLED
                    if (i && (n & He || !r)) return t | Tt; else if (i || r) {
                        if (n & Ie) return t | xt; else if (!(t & yt)) return yt;
                        return t | bt;
                    }
                    return Ct;
                }
            });
            d(oe, re, {
                /**
     * @namespace
     * @memberof PanRecognizer
     */
                defaults: {
                    event: "pan",
                    threshold: 10,
                    pointers: 1,
                    direction: Xe
                },
                getTouchAction: function() {
                    var e = this.options.direction;
                    var t = [];
                    if (e & ze) t.push(vt);
                    if (e & Ve) t.push(ht);
                    return t;
                },
                directionTest: function(e) {
                    var t = this.options;
                    var n = !0;
                    var i = e.distance;
                    var r = e.direction;
                    var o = e.deltaX;
                    var a = e.deltaY;
                    // lock to axis?
                    if (!(r & t.direction)) if (t.direction & ze) {
                        r = 0 === o ? _e : o < 0 ? Fe : Re;
                        n = o != this.pX;
                        i = Math.abs(e.deltaX);
                    } else {
                        r = 0 === a ? _e : a < 0 ? We : $e;
                        n = a != this.pY;
                        i = Math.abs(e.deltaY);
                    }
                    e.direction = r;
                    return n && i > t.threshold && r & t.direction;
                },
                attrTest: function(e) {
                    return re.prototype.attrTest.call(this, e) && (this.state & yt || !(this.state & yt) && this.directionTest(e));
                },
                emit: function(e) {
                    this.pX = e.deltaX;
                    this.pY = e.deltaY;
                    var t = ne(e.direction);
                    if (t) e.additionalEvent = this.options.event + t;
                    this._super.emit.call(this, e);
                }
            });
            d(ae, re, {
                /**
     * @namespace
     * @memberof PinchRecognizer
     */
                defaults: {
                    event: "pinch",
                    threshold: 0,
                    pointers: 2
                },
                getTouchAction: function() {
                    return [ pt ];
                },
                attrTest: function(e) {
                    return this._super.attrTest.call(this, e) && (Math.abs(e.scale - 1) > this.options.threshold || this.state & yt);
                },
                emit: function(e) {
                    if (1 !== e.scale) {
                        var t = e.scale < 1 ? "in" : "out";
                        e.additionalEvent = this.options.event + t;
                    }
                    this._super.emit.call(this, e);
                }
            });
            d(se, ee, {
                /**
     * @namespace
     * @memberof PressRecognizer
     */
                defaults: {
                    event: "press",
                    pointers: 1,
                    time: 251,
                    // minimal time of the pointer to be pressed
                    threshold: 9
                },
                getTouchAction: function() {
                    return [ ft ];
                },
                process: function(e) {
                    var t = this.options;
                    var n = e.pointers.length === t.pointers;
                    var i = e.distance < t.threshold;
                    var r = e.deltaTime > t.time;
                    this._input = e;
                    // we only allow little movement
                    // and we've reached an end event, so a tap is possible
                    if (!i || !n || e.eventType & (Ie | He) && !r) this.reset(); else if (e.eventType & Me) {
                        this.reset();
                        this._timer = l(function() {
                            this.state = wt;
                            this.tryEmit();
                        }, t.time, this);
                    } else if (e.eventType & Ie) return wt;
                    return Ct;
                },
                reset: function() {
                    clearTimeout(this._timer);
                },
                emit: function(e) {
                    if (this.state !== wt) return;
                    if (e && e.eventType & Ie) this.manager.emit(this.options.event + "up", e); else {
                        this._input.timeStamp = xe();
                        this.manager.emit(this.options.event, this._input);
                    }
                }
            });
            d(le, re, {
                /**
     * @namespace
     * @memberof RotateRecognizer
     */
                defaults: {
                    event: "rotate",
                    threshold: 0,
                    pointers: 2
                },
                getTouchAction: function() {
                    return [ pt ];
                },
                attrTest: function(e) {
                    return this._super.attrTest.call(this, e) && (Math.abs(e.rotation) > this.options.threshold || this.state & yt);
                }
            });
            d(ue, re, {
                /**
     * @namespace
     * @memberof SwipeRecognizer
     */
                defaults: {
                    event: "swipe",
                    threshold: 10,
                    velocity: .3,
                    direction: ze | Ve,
                    pointers: 1
                },
                getTouchAction: function() {
                    return oe.prototype.getTouchAction.call(this);
                },
                attrTest: function(e) {
                    var t = this.options.direction;
                    var n;
                    if (t & (ze | Ve)) n = e.overallVelocity; else if (t & ze) n = e.overallVelocityX; else if (t & Ve) n = e.overallVelocityY;
                    return this._super.attrTest.call(this, e) && t & e.offsetDirection && e.distance > this.options.threshold && e.maxPointers == this.options.pointers && be(n) > this.options.velocity && e.eventType & Ie;
                },
                emit: function(e) {
                    var t = ne(e.offsetDirection);
                    if (t) this.manager.emit(this.options.event + t, e);
                    this.manager.emit(this.options.event, e);
                }
            });
            d(ce, ee, {
                /**
     * @namespace
     * @memberof PinchRecognizer
     */
                defaults: {
                    event: "tap",
                    pointers: 1,
                    taps: 1,
                    interval: 300,
                    // max time between the multi-tap taps
                    time: 250,
                    // max time of the pointer to be down (like finger on the screen)
                    threshold: 9,
                    // a minimal movement is ok, but keep it low
                    posThreshold: 10
                },
                getTouchAction: function() {
                    return [ dt ];
                },
                process: function(e) {
                    var t = this.options;
                    var n = e.pointers.length === t.pointers;
                    var i = e.distance < t.threshold;
                    var r = e.deltaTime < t.time;
                    this.reset();
                    if (e.eventType & Me && 0 === this.count) return this.failTimeout();
                    // we only allow little movement
                    // and we've reached an end event, so a tap is possible
                    if (i && r && n) {
                        if (e.eventType != Ie) return this.failTimeout();
                        var o = this.pTime ? e.timeStamp - this.pTime < t.interval : !0;
                        var a = !this.pCenter || H(this.pCenter, e.center) < t.posThreshold;
                        this.pTime = e.timeStamp;
                        this.pCenter = e.center;
                        if (!a || !o) this.count = 1; else this.count += 1;
                        this._input = e;
                        if (0 === this.count % t.taps) // no failing requirements, immediately trigger the tap event
                        // or wait as long as the multitap interval to trigger
                        if (!this.hasRequireFailures()) return wt; else {
                            this._timer = l(function() {
                                this.state = wt;
                                this.tryEmit();
                            }, t.interval, this);
                            return yt;
                        }
                    }
                    return Ct;
                },
                failTimeout: function() {
                    this._timer = l(function() {
                        this.state = Ct;
                    }, this.options.interval, this);
                    return Ct;
                },
                reset: function() {
                    clearTimeout(this._timer);
                },
                emit: function() {
                    if (this.state == wt) {
                        this._input.tapCount = this.count;
                        this.manager.emit(this.options.event, this._input);
                    }
                }
            });
            /**
 * @const {string}
 */
            fe.VERSION = "2.0.7";
            /**
 * default settings
 * @namespace
 */
            fe.defaults = {
                /**
     * set if DOM events are being triggered.
     * But this is slower and unused by simple implementations, so disabled by default.
     * @type {Boolean}
     * @default false
     */
                domEvents: !1,
                /**
     * The value for the touchAction property/fallback.
     * When set to `compute` it will magically set the correct value based on the added recognizers.
     * @type {String}
     * @default compute
     */
                touchAction: ct,
                /**
     * @type {Boolean}
     * @default true
     */
                enable: !0,
                /**
     * EXPERIMENTAL FEATURE -- can be removed/changed
     * Change the parent input target element.
     * If Null, then it is being set the to main element.
     * @type {Null|EventTarget}
     * @default null
     */
                inputTarget: null,
                /**
     * force an input class
     * @type {Null|Function}
     * @default null
     */
                inputClass: null,
                /**
     * Default recognizer setup when calling `Hammer()`
     * When creating a new Manager these will be skipped.
     * @type {Array}
     */
                preset: [ // RecognizerClass, options, [recognizeWith, ...], [requireFailure, ...]
                [ le, {
                    enable: !1
                } ], [ ae, {
                    enable: !1
                }, [ "rotate" ] ], [ ue, {
                    direction: ze
                } ], [ oe, {
                    direction: ze
                }, [ "swipe" ] ], [ ce ], [ ce, {
                    event: "doubletap",
                    taps: 2
                }, [ "tap" ] ], [ se ] ],
                /**
     * Some CSS properties can be used to improve the working of Hammer.
     * Add them to this method and they will be set when creating a new Manager.
     * @namespace
     */
                cssProps: {
                    /**
         * Disables text selection to improve the dragging gesture. Mainly for desktop browsers.
         * @type {String}
         * @default 'none'
         */
                    userSelect: "none",
                    /**
         * Disable the Windows Phone grippers when pressing an element.
         * @type {String}
         * @default 'none'
         */
                    touchSelect: "none",
                    /**
         * Disables the default callout shown when you touch and hold a touch target.
         * On iOS, when you touch and hold a touch target such as a link, Safari displays
         * a callout containing information about the link. This property allows you to disable that callout.
         * @type {String}
         * @default 'none'
         */
                    touchCallout: "none",
                    /**
         * Specifies whether zooming is enabled. Used by IE10>
         * @type {String}
         * @default 'none'
         */
                    contentZooming: "none",
                    /**
         * Specifies that an entire element should be draggable instead of its contents. Mainly for desktop browsers.
         * @type {String}
         * @default 'none'
         */
                    userDrag: "none",
                    /**
         * Overrides the highlight color shown when the user taps a link or a JavaScript
         * clickable element in iOS. This property obeys the alpha value, if specified.
         * @type {String}
         * @default 'rgba(0,0,0,0)'
         */
                    tapHighlightColor: "rgba(0,0,0,0)"
                }
            };
            var kt = 1;
            var St = 2;
            de.prototype = {
                /**
     * set options
     * @param {Object} options
     * @returns {Manager}
     */
                set: function(e) {
                    we(this.options, e);
                    // Options that need a little more setup
                    if (e.touchAction) this.touchAction.update();
                    if (e.inputTarget) {
                        // Clean up existing event listeners and reinitialize
                        this.input.destroy();
                        this.input.target = e.inputTarget;
                        this.input.init();
                    }
                    return this;
                },
                /**
     * stop recognizing for this session.
     * This session will be discarded, when a new [input]start event is fired.
     * When forced, the recognizer cycle is stopped immediately.
     * @param {Boolean} [force]
     */
                stop: function(e) {
                    this.session.stopped = e ? St : kt;
                },
                /**
     * run the recognizers!
     * called by the inputHandler function on every movement of the pointers (touches)
     * it walks through all the recognizers and tries to detect the gesture that is being made
     * @param {Object} inputData
     */
                recognize: function(e) {
                    var t = this.session;
                    if (t.stopped) return;
                    // run the touch-action polyfill
                    this.touchAction.preventDefaults(e);
                    var n;
                    var i = this.recognizers;
                    // this holds the recognizer that is being recognized.
                    // so the recognizer's state needs to be BEGAN, CHANGED, ENDED or RECOGNIZED
                    // if no recognizer is detecting a thing, it is set to `null`
                    var r = t.curRecognizer;
                    // reset when the last recognizer is recognized
                    // or when we're in a new session
                    if (!r || r && r.state & wt) r = t.curRecognizer = null;
                    var o = 0;
                    for (;o < i.length; ) {
                        n = i[o];
                        // find out if we are allowed try to recognize the input for this one.
                        // 1.   allow if the session is NOT forced stopped (see the .stop() method)
                        // 2.   allow if we still haven't recognized a gesture in this session, or the this recognizer is the one
                        //      that is being recognized.
                        // 3.   allow if the recognizer is allowed to run simultaneous with the current recognized recognizer.
                        //      this can be setup with the `recognizeWith()` method on the recognizer.
                        if (t.stopped !== St && (// 1
                        !r || n == r || // 2
                        n.canRecognizeWith(r))) // 3
                        n.recognize(e); else n.reset();
                        // if the recognizer has been recognizing the input as a valid gesture, we want to store this one as the
                        // current active recognizer. but only if we don't already have an active recognizer
                        if (!r && n.state & (yt | bt | xt)) r = t.curRecognizer = n;
                        o++;
                    }
                },
                /**
     * get a recognizer by its event name.
     * @param {Recognizer|String} recognizer
     * @returns {Recognizer|Null}
     */
                get: function(e) {
                    if (e instanceof ee) return e;
                    var t = this.recognizers;
                    for (var n = 0; n < t.length; n++) if (t[n].options.event == e) return t[n];
                    return null;
                },
                /**
     * add a recognizer to the manager
     * existing recognizers with the same event name will be removed
     * @param {Recognizer} recognizer
     * @returns {Recognizer|Manager}
     */
                add: function(e) {
                    if (u(e, "add", this)) return this;
                    // remove existing
                    var t = this.get(e.options.event);
                    if (t) this.remove(t);
                    this.recognizers.push(e);
                    e.manager = this;
                    this.touchAction.update();
                    return e;
                },
                /**
     * remove a recognizer by name or instance
     * @param {Recognizer|String} recognizer
     * @returns {Manager}
     */
                remove: function(e) {
                    if (u(e, "remove", this)) return this;
                    e = this.get(e);
                    // let's make sure this recognizer exists
                    if (e) {
                        var t = this.recognizers;
                        var n = w(t, e);
                        if (-1 !== n) {
                            t.splice(n, 1);
                            this.touchAction.update();
                        }
                    }
                    return this;
                },
                /**
     * bind event
     * @param {String} events
     * @param {Function} handler
     * @returns {EventEmitter} this
     */
                on: function(e, t) {
                    if (e === s) return;
                    if (t === s) return;
                    var n = this.handlers;
                    c(x(e), function(e) {
                        n[e] = n[e] || [];
                        n[e].push(t);
                    });
                    return this;
                },
                /**
     * unbind event, leave emit blank to remove all handlers
     * @param {String} events
     * @param {Function} [handler]
     * @returns {EventEmitter} this
     */
                off: function(e, t) {
                    if (e === s) return;
                    var n = this.handlers;
                    c(x(e), function(e) {
                        if (!t) delete n[e]; else n[e] && n[e].splice(w(n[e], t), 1);
                    });
                    return this;
                },
                /**
     * emit event to the listeners
     * @param {String} event
     * @param {Object} data
     */
                emit: function(e, t) {
                    // we also want to trigger dom events
                    if (this.options.domEvents) he(e, t);
                    // no handlers, so skip it all
                    var n = this.handlers[e] && this.handlers[e].slice();
                    if (!n || !n.length) return;
                    t.type = e;
                    t.preventDefault = function() {
                        t.srcEvent.preventDefault();
                    };
                    var i = 0;
                    for (;i < n.length; ) {
                        n[i](t);
                        i++;
                    }
                },
                /**
     * destroy the manager and unbinds all events
     * it doesn't unbind dom events, that is the user own responsibility
     */
                destroy: function() {
                    this.element && pe(this, !1);
                    this.handlers = {};
                    this.session = {};
                    this.input.destroy();
                    this.element = null;
                }
            };
            we(fe, {
                INPUT_START: Me,
                INPUT_MOVE: Le,
                INPUT_END: Ie,
                INPUT_CANCEL: He,
                STATE_POSSIBLE: mt,
                STATE_BEGAN: yt,
                STATE_CHANGED: bt,
                STATE_ENDED: xt,
                STATE_RECOGNIZED: wt,
                STATE_CANCELLED: Tt,
                STATE_FAILED: Ct,
                DIRECTION_NONE: _e,
                DIRECTION_LEFT: Fe,
                DIRECTION_RIGHT: Re,
                DIRECTION_UP: We,
                DIRECTION_DOWN: $e,
                DIRECTION_HORIZONTAL: ze,
                DIRECTION_VERTICAL: Ve,
                DIRECTION_ALL: Xe,
                Manager: de,
                Input: A,
                TouchAction: Z,
                TouchInput: X,
                MouseInput: W,
                PointerEventInput: $,
                TouchMouseInput: Y,
                SingleTouchInput: z,
                Recognizer: ee,
                AttrRecognizer: re,
                Tap: ce,
                Pan: oe,
                Swipe: ue,
                Pinch: ae,
                Rotate: le,
                Press: se,
                on: g,
                off: m,
                each: c,
                merge: Ce,
                extend: Te,
                assign: we,
                inherit: d,
                bindFn: p,
                prefixed: k
            });
            // jshint ignore:line
            ("undefined" !== typeof r ? r : "undefined" !== typeof self ? self : {}).Hammer = fe;
            if (!0) (i = function() {
                return fe;
            }.call(t, n, t, e)) !== s && (e.exports = i); else if ("undefined" != typeof e && e.exports) e.exports = fe; else r[a] = fe;
        }(window, document, "Hammer");
    },
    /***/
    117: /***/
    function(e, t, n) {
        var i, r;
        /*!
 * jQuery JavaScript Library v3.2.1
 * https://jquery.com/
 *
 * Includes Sizzle.js
 * https://sizzlejs.com/
 *
 * Copyright JS Foundation and other contributors
 * Released under the MIT license
 * https://jquery.org/license
 *
 * Date: 2017-03-20T18:59Z
 */
        !function(t, n) {
            "use strict";
            if ("object" === typeof e && "object" === typeof e.exports) // For CommonJS and CommonJS-like environments where a proper `window`
            // is present, execute the factory and get jQuery.
            // For environments that do not have a `window` with a `document`
            // (such as Node.js), expose a factory as module.exports.
            // This accentuates the need for the creation of a real `window`.
            // e.g. var jQuery = require("jquery")(window);
            // See ticket #14549 for more info.
            e.exports = t.document ? n(t, !0) : function(e) {
                if (!e.document) throw new Error("jQuery requires a window with a document");
                return n(e);
            }; else n(t);
        }("undefined" !== typeof window ? window : this, function(n, o) {
            // Edge <= 12 - 13+, Firefox <=18 - 45+, IE 10 - 11, Safari 5.1 - 9+, iOS 6 - 9.1
            // throw exceptions when non-strict code (e.g., ASP.NET 4.5) accesses strict mode
            // arguments.callee.caller (trac-13335). But as of jQuery 3.0 (2016), strict mode should be common
            // enough that all such attempts are guarded in a try block.
            "use strict";
            function a(e, t) {
                t = t || ae;
                var n = t.createElement("script");
                n.text = e;
                t.head.appendChild(n).parentNode.removeChild(n);
            }
            function s(e) {
                // Support: real iOS 8.2 only (not reproducible in simulator)
                // `in` check used to prevent JIT error (gh-2145)
                // hasOwn isn't used here due to false negatives
                // regarding Nodelist length in IE
                var t = !!e && "length" in e && e.length, n = be.type(e);
                if ("function" === n || be.isWindow(e)) return !1;
                return "array" === n || 0 === t || "number" === typeof t && t > 0 && t - 1 in e;
            }
            function l(e, t) {
                return e.nodeName && e.nodeName.toLowerCase() === t.toLowerCase();
            }
            // Implement the identical functionality for filter and not
            function u(e, t, n) {
                if (be.isFunction(t)) return be.grep(e, function(e, i) {
                    return !!t.call(e, i, e) !== n;
                });
                // Single element
                if (t.nodeType) return be.grep(e, function(e) {
                    return e === t !== n;
                });
                // Arraylike of elements (jQuery, arguments, Array)
                if ("string" !== typeof t) return be.grep(e, function(e) {
                    return fe.call(t, e) > -1 !== n;
                });
                // Simple selector that can be filtered directly, removing non-Elements
                if (De.test(t)) return be.filter(t, e, n);
                // Complex selector, compare the two sets, removing non-Elements
                t = be.filter(t, e);
                return be.grep(e, function(e) {
                    return fe.call(t, e) > -1 !== n && 1 === e.nodeType;
                });
            }
            function c(e, t) {
                for (;(e = e[t]) && 1 !== e.nodeType; ) ;
                return e;
            }
            // Convert String-formatted options into Object-formatted ones
            function f(e) {
                var t = {};
                be.each(e.match(Me) || [], function(e, n) {
                    t[n] = !0;
                });
                return t;
            }
            function d(e) {
                return e;
            }
            function p(e) {
                throw e;
            }
            function h(e, t, n, i) {
                var r;
                try {
                    // Check for promise aspect first to privilege synchronous behavior
                    if (e && be.isFunction(r = e.promise)) r.call(e).done(t).fail(n); else if (e && be.isFunction(r = e.then)) r.call(e, t, n); else // Control `resolve` arguments by letting Array#slice cast boolean `noValue` to integer:
                    // * false: [ value ].slice( 0 ) => resolve( value )
                    // * true: [ value ].slice( 1 ) => resolve()
                    t.apply(undefined, [ e ].slice(i));
                } catch (e) {
                    // Support: Android 4.0 only
                    // Strict mode functions invoked without .call/.apply get global-object context
                    n.apply(undefined, [ e ]);
                }
            }
            // The ready event handler and self cleanup method
            function v() {
                ae.removeEventListener("DOMContentLoaded", v);
                n.removeEventListener("load", v);
                be.ready();
            }
            function g() {
                this.expando = be.expando + g.uid++;
            }
            function m(e) {
                if ("true" === e) return !0;
                if ("false" === e) return !1;
                if ("null" === e) return null;
                // Only convert to a number if it doesn't change the string
                if (e === +e + "") return +e;
                if (We.test(e)) return JSON.parse(e);
                return e;
            }
            function y(e, t, n) {
                var i;
                // If nothing was found internally, try to fetch any
                // data from the HTML5 data-* attribute
                if (n === undefined && 1 === e.nodeType) {
                    i = "data-" + t.replace($e, "-$&").toLowerCase();
                    n = e.getAttribute(i);
                    if ("string" === typeof n) {
                        try {
                            n = m(n);
                        } catch (r) {}
                        // Make sure we set the data so it isn't changed later
                        Re.set(e, t, n);
                    } else n = undefined;
                }
                return n;
            }
            function b(e, t, n, i) {
                var r, o = 1, a = 20, s = i ? function() {
                    return i.cur();
                } : function() {
                    return be.css(e, t, "");
                }, l = s(), u = n && n[3] || (be.cssNumber[t] ? "" : "px"), // Starting value computation is required for potential unit mismatches
                c = (be.cssNumber[t] || "px" !== u && +l) && Ve.exec(be.css(e, t));
                if (c && c[3] !== u) {
                    // Trust units reported by jQuery.css
                    u = u || c[3];
                    // Make sure we update the tween properties later on
                    n = n || [];
                    // Iteratively approximate from a nonzero starting point
                    c = +l || 1;
                    do {
                        // If previous iteration zeroed out, double until we get *something*.
                        // Use string for doubling so we don't accidentally see scale as unchanged below
                        o = o || ".5";
                        // Adjust and apply
                        c /= o;
                        be.style(e, t, c + u);
                    } while (o !== (o = s() / l) && 1 !== o && --a);
                }
                if (n) {
                    c = +c || +l || 0;
                    // Apply relative offset (+=/-=) if specified
                    r = n[1] ? c + (n[1] + 1) * n[2] : +n[2];
                    if (i) {
                        i.unit = u;
                        i.start = c;
                        i.end = r;
                    }
                }
                return r;
            }
            function x(e) {
                var t, n = e.ownerDocument, i = e.nodeName, r = Qe[i];
                if (r) return r;
                t = n.body.appendChild(n.createElement(i));
                r = be.css(t, "display");
                t.parentNode.removeChild(t);
                if ("none" === r) r = "block";
                Qe[i] = r;
                return r;
            }
            function w(e, t) {
                var n, i, r = [], o = 0, a = e.length;
                // Determine new display value for elements that need to change
                for (;o < a; o++) {
                    i = e[o];
                    if (!i.style) continue;
                    n = i.style.display;
                    if (t) {
                        // Since we force visibility upon cascade-hidden elements, an immediate (and slow)
                        // check is required in this first loop unless we have a nonempty display value (either
                        // inline or about-to-be-restored)
                        if ("none" === n) {
                            r[o] = Fe.get(i, "display") || null;
                            if (!r[o]) i.style.display = "";
                        }
                        if ("" === i.style.display && Be(i)) r[o] = x(i);
                    } else if ("none" !== n) {
                        r[o] = "none";
                        // Remember what we're overwriting
                        Fe.set(i, "display", n);
                    }
                }
                // Set the display of the elements in a second loop to avoid constant reflow
                for (o = 0; o < a; o++) if (null != r[o]) e[o].style.display = r[o];
                return e;
            }
            function T(e, t) {
                // Support: IE <=9 - 11 only
                // Use typeof to avoid zero-argument method invocation on host objects (#15151)
                var n;
                if ("undefined" !== typeof e.getElementsByTagName) n = e.getElementsByTagName(t || "*"); else if ("undefined" !== typeof e.querySelectorAll) n = e.querySelectorAll(t || "*"); else n = [];
                if (t === undefined || t && l(e, t)) return be.merge([ e ], n);
                return n;
            }
            // Mark scripts as having already been evaluated
            function C(e, t) {
                var n = 0, i = e.length;
                for (;n < i; n++) Fe.set(e[n], "globalEval", !t || Fe.get(t[n], "globalEval"));
            }
            function k(e, t, n, i, r) {
                var o, a, s, l, u, c, f = t.createDocumentFragment(), d = [], p = 0, h = e.length;
                for (;p < h; p++) {
                    o = e[p];
                    if (o || 0 === o) // Add nodes directly
                    if ("object" === be.type(o)) // Support: Android <=4.0 only, PhantomJS 1 only
                    // push.apply(_, arraylike) throws on ancient WebKit
                    be.merge(d, o.nodeType ? [ o ] : o); else if (!Ke.test(o)) d.push(t.createTextNode(o)); else {
                        a = a || f.appendChild(t.createElement("div"));
                        // Deserialize a standard representation
                        s = (Ge.exec(o) || [ "", "" ])[1].toLowerCase();
                        l = Je[s] || Je._default;
                        a.innerHTML = l[1] + be.htmlPrefilter(o) + l[2];
                        // Descend through wrappers to the right content
                        c = l[0];
                        for (;c--; ) a = a.lastChild;
                        // Support: Android <=4.0 only, PhantomJS 1 only
                        // push.apply(_, arraylike) throws on ancient WebKit
                        be.merge(d, a.childNodes);
                        // Remember the top-level container
                        a = f.firstChild;
                        // Ensure the created nodes are orphaned (#12392)
                        a.textContent = "";
                    }
                }
                // Remove wrapper from fragment
                f.textContent = "";
                p = 0;
                for (;o = d[p++]; ) {
                    // Skip elements already in the context collection (trac-4087)
                    if (i && be.inArray(o, i) > -1) {
                        if (r) r.push(o);
                        continue;
                    }
                    u = be.contains(o.ownerDocument, o);
                    // Append to fragment
                    a = T(f.appendChild(o), "script");
                    // Preserve script evaluation history
                    if (u) C(a);
                    // Capture executables
                    if (n) {
                        c = 0;
                        for (;o = a[c++]; ) if (Ze.test(o.type || "")) n.push(o);
                    }
                }
                return f;
            }
            function S() {
                return !0;
            }
            function E() {
                return !1;
            }
            // Support: IE <=9 only
            // See #13393 for more info
            function A() {
                try {
                    return ae.activeElement;
                } catch (e) {}
            }
            function P(e, t, n, i, r, o) {
                var a, s;
                // Types can be a map of types/handlers
                if ("object" === typeof t) {
                    // ( types-Object, selector, data )
                    if ("string" !== typeof n) {
                        // ( types-Object, data )
                        i = i || n;
                        n = undefined;
                    }
                    for (s in t) P(e, s, n, i, t[s], o);
                    return e;
                }
                if (null == i && null == r) {
                    // ( types, fn )
                    r = n;
                    i = n = undefined;
                } else if (null == r) if ("string" === typeof n) {
                    // ( types, selector, fn )
                    r = i;
                    i = undefined;
                } else {
                    // ( types, data, fn )
                    r = i;
                    i = n;
                    n = undefined;
                }
                if (!1 === r) r = E; else if (!r) return e;
                if (1 === o) {
                    a = r;
                    r = function(e) {
                        // Can use an empty set, since event contains the info
                        be().off(e);
                        return a.apply(this, arguments);
                    };
                    // Use same guid so caller can remove using origFn
                    r.guid = a.guid || (a.guid = be.guid++);
                }
                return e.each(function() {
                    be.event.add(this, t, r, i, n);
                });
            }
            // Prefer a tbody over its parent table for containing new rows
            function D(e, t) {
                if (l(e, "table") && l(11 !== t.nodeType ? t : t.firstChild, "tr")) return be(">tbody", e)[0] || e;
                return e;
            }
            // Replace/restore the type attribute of script elements for safe DOM manipulation
            function O(e) {
                e.type = (null !== e.getAttribute("type")) + "/" + e.type;
                return e;
            }
            function N(e) {
                var t = st.exec(e.type);
                if (t) e.type = t[1]; else e.removeAttribute("type");
                return e;
            }
            function q(e, t) {
                var n, i, r, o, a, s, l, u;
                if (1 !== t.nodeType) return;
                // 1. Copy private data: events, handlers, etc.
                if (Fe.hasData(e)) {
                    o = Fe.access(e);
                    a = Fe.set(t, o);
                    u = o.events;
                    if (u) {
                        delete a.handle;
                        a.events = {};
                        for (r in u) for (n = 0, i = u[r].length; n < i; n++) be.event.add(t, r, u[r][n]);
                    }
                }
                // 2. Copy user data
                if (Re.hasData(e)) {
                    s = Re.access(e);
                    l = be.extend({}, s);
                    Re.set(t, l);
                }
            }
            // Fix IE bugs, see support tests
            function j(e, t) {
                var n = t.nodeName.toLowerCase();
                // Fails to persist the checked state of a cloned checkbox or radio button.
                if ("input" === n && Ue.test(e.type)) t.checked = e.checked; else if ("input" === n || "textarea" === n) t.defaultValue = e.defaultValue;
            }
            function M(e, t, n, i) {
                // Flatten any nested arrays
                t = ue.apply([], t);
                var r, o, s, l, u, c, f = 0, d = e.length, p = d - 1, h = t[0], v = be.isFunction(h);
                // We can't cloneNode fragments that contain checked, in WebKit
                if (v || d > 1 && "string" === typeof h && !me.checkClone && at.test(h)) return e.each(function(r) {
                    var o = e.eq(r);
                    if (v) t[0] = h.call(this, r, o.html());
                    M(o, t, n, i);
                });
                if (d) {
                    r = k(t, e[0].ownerDocument, !1, e, i);
                    o = r.firstChild;
                    if (1 === r.childNodes.length) r = o;
                    // Require either new content or an interest in ignored elements to invoke the callback
                    if (o || i) {
                        s = be.map(T(r, "script"), O);
                        l = s.length;
                        // Use the original fragment for the last item
                        // instead of the first because it can end up
                        // being emptied incorrectly in certain situations (#8070).
                        for (;f < d; f++) {
                            u = r;
                            if (f !== p) {
                                u = be.clone(u, !0, !0);
                                // Keep references to cloned scripts for later restoration
                                if (l) // Support: Android <=4.0 only, PhantomJS 1 only
                                // push.apply(_, arraylike) throws on ancient WebKit
                                be.merge(s, T(u, "script"));
                            }
                            n.call(e[f], u, f);
                        }
                        if (l) {
                            c = s[s.length - 1].ownerDocument;
                            // Reenable scripts
                            be.map(s, N);
                            // Evaluate executable scripts on first document insertion
                            for (f = 0; f < l; f++) {
                                u = s[f];
                                if (Ze.test(u.type || "") && !Fe.access(u, "globalEval") && be.contains(c, u)) if (u.src) {
                                    // Optional AJAX dependency, but won't run scripts if not present
                                    if (be._evalUrl) be._evalUrl(u.src);
                                } else a(u.textContent.replace(lt, ""), c);
                            }
                        }
                    }
                }
                return e;
            }
            function L(e, t, n) {
                var i, r = t ? be.filter(t, e) : e, o = 0;
                for (;null != (i = r[o]); o++) {
                    if (!n && 1 === i.nodeType) be.cleanData(T(i));
                    if (i.parentNode) {
                        if (n && be.contains(i.ownerDocument, i)) C(T(i, "script"));
                        i.parentNode.removeChild(i);
                    }
                }
                return e;
            }
            function I(e, t, n) {
                var i, r, o, a, // Support: Firefox 51+
                // Retrieving style before computed somehow
                // fixes an issue with getting wrong values
                // on detached elements
                s = e.style;
                n = n || ft(e);
                // getPropertyValue is needed for:
                //   .css('filter') (IE 9 only, #12537)
                //   .css('--customProperty) (#3144)
                if (n) {
                    a = n.getPropertyValue(t) || n[t];
                    if ("" === a && !be.contains(e.ownerDocument, e)) a = be.style(e, t);
                    // A tribute to the "awesome hack by Dean Edwards"
                    // Android Browser returns percentage for some values,
                    // but width seems to be reliably pixels.
                    // This is against the CSSOM draft spec:
                    // https://drafts.csswg.org/cssom/#resolved-values
                    if (!me.pixelMarginRight() && ct.test(a) && ut.test(t)) {
                        // Remember the original values
                        i = s.width;
                        r = s.minWidth;
                        o = s.maxWidth;
                        // Put in the new values to get a computed value out
                        s.minWidth = s.maxWidth = s.width = a;
                        a = n.width;
                        // Revert the changed values
                        s.width = i;
                        s.minWidth = r;
                        s.maxWidth = o;
                    }
                }
                // Support: IE <=9 - 11 only
                // IE returns zIndex value as an integer.
                return a !== undefined ? a + "" : a;
            }
            function H(e, t) {
                // Define the hook, we'll check on the first run if it's really needed.
                return {
                    get: function() {
                        if (e()) {
                            // Hook not needed (or it's not possible to use it due
                            // to missing dependency), remove it.
                            delete this.get;
                            return;
                        }
                        // Hook needed; redefine it so that the support test is not executed again.
                        return (this.get = t).apply(this, arguments);
                    }
                };
            }
            // Return a css property mapped to a potentially vendor prefixed property
            function _(e) {
                // Shortcut for names that are not vendor prefixed
                if (e in mt) return e;
                // Check for vendor prefixed names
                var t = e[0].toUpperCase() + e.slice(1), n = gt.length;
                for (;n--; ) {
                    e = gt[n] + t;
                    if (e in mt) return e;
                }
            }
            // Return a property mapped along what jQuery.cssProps suggests or to
            // a vendor prefixed property.
            function F(e) {
                var t = be.cssProps[e];
                if (!t) t = be.cssProps[e] = _(e) || e;
                return t;
            }
            function R(e, t, n) {
                // Any relative (+/-) values have already been
                // normalized at this point
                var i = Ve.exec(t);
                // Guard against undefined "subtract", e.g., when used as in cssHooks
                return i ? Math.max(0, i[2] - (n || 0)) + (i[3] || "px") : t;
            }
            function W(e, t, n, i, r) {
                var o, a = 0;
                // If we already have the right measurement, avoid augmentation
                if (n === (i ? "border" : "content")) o = 4; else o = "width" === t ? 1 : 0;
                for (;o < 4; o += 2) {
                    // Both box models exclude margin, so add it if we want it
                    if ("margin" === n) a += be.css(e, n + Xe[o], !0, r);
                    if (i) {
                        // border-box includes padding, so remove it if we want content
                        if ("content" === n) a -= be.css(e, "padding" + Xe[o], !0, r);
                        // At this point, extra isn't border nor margin, so remove border
                        if ("margin" !== n) a -= be.css(e, "border" + Xe[o] + "Width", !0, r);
                    } else {
                        // At this point, extra isn't content, so add padding
                        a += be.css(e, "padding" + Xe[o], !0, r);
                        // At this point, extra isn't content nor padding, so add border
                        if ("padding" !== n) a += be.css(e, "border" + Xe[o] + "Width", !0, r);
                    }
                }
                return a;
            }
            function $(e, t, n) {
                // Start with computed style
                var i, r = ft(e), o = I(e, t, r), a = "border-box" === be.css(e, "boxSizing", !1, r);
                // Computed unit is not pixels. Stop here and return.
                if (ct.test(o)) return o;
                // Check for style in case a browser which returns unreliable values
                // for getComputedStyle silently falls back to the reliable elem.style
                i = a && (me.boxSizingReliable() || o === e.style[t]);
                // Fall back to offsetWidth/Height when value is "auto"
                // This happens for inline elements with no explicit setting (gh-3571)
                if ("auto" === o) o = e["offset" + t[0].toUpperCase() + t.slice(1)];
                // Normalize "", auto, and prepare for extra
                o = parseFloat(o) || 0;
                // Use the active box-sizing model to add/subtract irrelevant styles
                return o + W(e, t, n || (a ? "border" : "content"), i, r) + "px";
            }
            function z(e, t, n, i, r) {
                return new z.prototype.init(e, t, n, i, r);
            }
            function V() {
                if (bt) {
                    if (!1 === ae.hidden && n.requestAnimationFrame) n.requestAnimationFrame(V); else n.setTimeout(V, be.fx.interval);
                    be.fx.tick();
                }
            }
            // Animations created synchronously will run synchronously
            function X() {
                n.setTimeout(function() {
                    yt = undefined;
                });
                return yt = be.now();
            }
            // Generate parameters to create a standard animation
            function B(e, t) {
                var n, i = 0, r = {
                    height: e
                };
                // If we include width, step value is 1 to do all cssExpand values,
                // otherwise step value is 2 to skip over Left and Right
                t = t ? 1 : 0;
                for (;i < 4; i += 2 - t) {
                    n = Xe[i];
                    r["margin" + n] = r["padding" + n] = e;
                }
                if (t) r.opacity = r.width = e;
                return r;
            }
            function Y(e, t, n) {
                var i, r = (G.tweeners[t] || []).concat(G.tweeners["*"]), o = 0, a = r.length;
                for (;o < a; o++) if (i = r[o].call(n, t, e)) // We're done with this property
                return i;
            }
            function Q(e, t, n) {
                var i, r, o, a, s, l, u, c, f = "width" in t || "height" in t, d = this, p = {}, h = e.style, v = e.nodeType && Be(e), g = Fe.get(e, "fxshow");
                // Queue-skipping animations hijack the fx hooks
                if (!n.queue) {
                    a = be._queueHooks(e, "fx");
                    if (null == a.unqueued) {
                        a.unqueued = 0;
                        s = a.empty.fire;
                        a.empty.fire = function() {
                            if (!a.unqueued) s();
                        };
                    }
                    a.unqueued++;
                    d.always(function() {
                        // Ensure the complete handler is called before this completes
                        d.always(function() {
                            a.unqueued--;
                            if (!be.queue(e, "fx").length) a.empty.fire();
                        });
                    });
                }
                // Detect show/hide animations
                for (i in t) {
                    r = t[i];
                    if (xt.test(r)) {
                        delete t[i];
                        o = o || "toggle" === r;
                        if (r === (v ? "hide" : "show")) // Pretend to be hidden if this is a "show" and
                        // there is still data from a stopped show/hide
                        if ("show" === r && g && g[i] !== undefined) v = !0; else continue;
                        p[i] = g && g[i] || be.style(e, i);
                    }
                }
                // Bail out if this is a no-op like .hide().hide()
                l = !be.isEmptyObject(t);
                if (!l && be.isEmptyObject(p)) return;
                // Restrict "overflow" and "display" styles during box animations
                if (f && 1 === e.nodeType) {
                    // Support: IE <=9 - 11, Edge 12 - 13
                    // Record all 3 overflow attributes because IE does not infer the shorthand
                    // from identically-valued overflowX and overflowY
                    n.overflow = [ h.overflow, h.overflowX, h.overflowY ];
                    // Identify a display type, preferring old show/hide data over the CSS cascade
                    u = g && g.display;
                    if (null == u) u = Fe.get(e, "display");
                    c = be.css(e, "display");
                    if ("none" === c) if (u) c = u; else {
                        // Get nonempty value(s) by temporarily forcing visibility
                        w([ e ], !0);
                        u = e.style.display || u;
                        c = be.css(e, "display");
                        w([ e ]);
                    }
                    // Animate inline elements as inline-block
                    if ("inline" === c || "inline-block" === c && null != u) if ("none" === be.css(e, "float")) {
                        // Restore the original display value at the end of pure show/hide animations
                        if (!l) {
                            d.done(function() {
                                h.display = u;
                            });
                            if (null == u) {
                                c = h.display;
                                u = "none" === c ? "" : c;
                            }
                        }
                        h.display = "inline-block";
                    }
                }
                if (n.overflow) {
                    h.overflow = "hidden";
                    d.always(function() {
                        h.overflow = n.overflow[0];
                        h.overflowX = n.overflow[1];
                        h.overflowY = n.overflow[2];
                    });
                }
                // Implement show/hide animations
                l = !1;
                for (i in p) {
                    // General show/hide setup for this element animation
                    if (!l) {
                        if (g) {
                            if ("hidden" in g) v = g.hidden;
                        } else g = Fe.access(e, "fxshow", {
                            display: u
                        });
                        // Store hidden/visible for toggle so `.stop().toggle()` "reverses"
                        if (o) g.hidden = !v;
                        // Show elements before animating them
                        if (v) w([ e ], !0);
                        /* eslint-disable no-loop-func */
                        d.done(function() {
                            /* eslint-enable no-loop-func */
                            // The final step of a "hide" animation is actually hiding the element
                            if (!v) w([ e ]);
                            Fe.remove(e, "fxshow");
                            for (i in p) be.style(e, i, p[i]);
                        });
                    }
                    // Per-property setup
                    l = Y(v ? g[i] : 0, i, d);
                    if (!(i in g)) {
                        g[i] = l.start;
                        if (v) {
                            l.end = l.start;
                            l.start = 0;
                        }
                    }
                }
            }
            function U(e, t) {
                var n, i, r, o, a;
                // camelCase, specialEasing and expand cssHook pass
                for (n in e) {
                    i = be.camelCase(n);
                    r = t[i];
                    o = e[n];
                    if (Array.isArray(o)) {
                        r = o[1];
                        o = e[n] = o[0];
                    }
                    if (n !== i) {
                        e[i] = o;
                        delete e[n];
                    }
                    a = be.cssHooks[i];
                    if (a && "expand" in a) {
                        o = a.expand(o);
                        delete e[i];
                        // Not quite $.extend, this won't overwrite existing keys.
                        // Reusing 'index' because we have the correct "name"
                        for (n in o) if (!(n in e)) {
                            e[n] = o[n];
                            t[n] = r;
                        }
                    } else t[i] = r;
                }
            }
            function G(e, t, n) {
                var i, r, o = 0, a = G.prefilters.length, s = be.Deferred().always(function() {
                    // Don't match elem in the :animated selector
                    delete l.elem;
                }), l = function() {
                    if (r) return !1;
                    var t = yt || X(), n = Math.max(0, u.startTime + u.duration - t), // Support: Android 2.3 only
                    // Archaic crash bug won't allow us to use `1 - ( 0.5 || 0 )` (#12497)
                    i = n / u.duration || 0, o = 1 - i, a = 0, l = u.tweens.length;
                    for (;a < l; a++) u.tweens[a].run(o);
                    s.notifyWith(e, [ u, o, n ]);
                    // If there's more to do, yield
                    if (o < 1 && l) return n;
                    // If this was an empty animation, synthesize a final progress notification
                    if (!l) s.notifyWith(e, [ u, 1, 0 ]);
                    // Resolve the animation and report its conclusion
                    s.resolveWith(e, [ u ]);
                    return !1;
                }, u = s.promise({
                    elem: e,
                    props: be.extend({}, t),
                    opts: be.extend(!0, {
                        specialEasing: {},
                        easing: be.easing._default
                    }, n),
                    originalProperties: t,
                    originalOptions: n,
                    startTime: yt || X(),
                    duration: n.duration,
                    tweens: [],
                    createTween: function(t, n) {
                        var i = be.Tween(e, u.opts, t, n, u.opts.specialEasing[t] || u.opts.easing);
                        u.tweens.push(i);
                        return i;
                    },
                    stop: function(t) {
                        var n = 0, // If we are going to the end, we want to run all the tweens
                        // otherwise we skip this part
                        i = t ? u.tweens.length : 0;
                        if (r) return this;
                        r = !0;
                        for (;n < i; n++) u.tweens[n].run(1);
                        // Resolve when we played the last frame; otherwise, reject
                        if (t) {
                            s.notifyWith(e, [ u, 1, 0 ]);
                            s.resolveWith(e, [ u, t ]);
                        } else s.rejectWith(e, [ u, t ]);
                        return this;
                    }
                }), c = u.props;
                U(c, u.opts.specialEasing);
                for (;o < a; o++) {
                    i = G.prefilters[o].call(u, e, c, u.opts);
                    if (i) {
                        if (be.isFunction(i.stop)) be._queueHooks(u.elem, u.opts.queue).stop = be.proxy(i.stop, i);
                        return i;
                    }
                }
                be.map(c, Y, u);
                if (be.isFunction(u.opts.start)) u.opts.start.call(e, u);
                // Attach callbacks from options
                u.progress(u.opts.progress).done(u.opts.done, u.opts.complete).fail(u.opts.fail).always(u.opts.always);
                be.fx.timer(be.extend(l, {
                    elem: e,
                    anim: u,
                    queue: u.opts.queue
                }));
                return u;
            }
            // Strip and collapse whitespace according to HTML spec
            // https://html.spec.whatwg.org/multipage/infrastructure.html#strip-and-collapse-whitespace
            function Z(e) {
                return (e.match(Me) || []).join(" ");
            }
            function J(e) {
                return e.getAttribute && e.getAttribute("class") || "";
            }
            function K(e, t, n, i) {
                var r;
                if (Array.isArray(t)) // Serialize array item.
                be.each(t, function(t, r) {
                    if (n || Nt.test(e)) // Treat each array item as a scalar.
                    i(e, r); else // Item is non-scalar (array or object), encode its numeric index.
                    K(e + "[" + ("object" === typeof r && null != r ? t : "") + "]", r, n, i);
                }); else if (!n && "object" === be.type(t)) // Serialize object item.
                for (r in t) K(e + "[" + r + "]", t[r], n, i); else // Serialize scalar item.
                i(e, t);
            }
            // Base "constructor" for jQuery.ajaxPrefilter and jQuery.ajaxTransport
            function ee(e) {
                // dataTypeExpression is optional and defaults to "*"
                return function(t, n) {
                    if ("string" !== typeof t) {
                        n = t;
                        t = "*";
                    }
                    var i, r = 0, o = t.toLowerCase().match(Me) || [];
                    if (be.isFunction(n)) // For each dataType in the dataTypeExpression
                    for (;i = o[r++]; ) // Prepend if requested
                    if ("+" === i[0]) {
                        i = i.slice(1) || "*";
                        (e[i] = e[i] || []).unshift(n);
                    } else (e[i] = e[i] || []).push(n);
                };
            }
            // Base inspection function for prefilters and transports
            function te(e, t, n, i) {
                function r(s) {
                    var l;
                    o[s] = !0;
                    be.each(e[s] || [], function(e, s) {
                        var u = s(t, n, i);
                        if ("string" === typeof u && !a && !o[u]) {
                            t.dataTypes.unshift(u);
                            r(u);
                            return !1;
                        } else if (a) return !(l = u);
                    });
                    return l;
                }
                var o = {}, a = e === zt;
                return r(t.dataTypes[0]) || !o["*"] && r("*");
            }
            // A special extend for ajax options
            // that takes "flat" options (not to be deep extended)
            // Fixes #9887
            function ne(e, t) {
                var n, i, r = be.ajaxSettings.flatOptions || {};
                for (n in t) if (t[n] !== undefined) (r[n] ? e : i || (i = {}))[n] = t[n];
                if (i) be.extend(!0, e, i);
                return e;
            }
            /* Handles responses to an ajax request:
 * - finds the right dataType (mediates between content-type and expected dataType)
 * - returns the corresponding response
 */
            function ie(e, t, n) {
                var i, r, o, a, s = e.contents, l = e.dataTypes;
                // Remove auto dataType and get content-type in the process
                for (;"*" === l[0]; ) {
                    l.shift();
                    if (i === undefined) i = e.mimeType || t.getResponseHeader("Content-Type");
                }
                // Check if we're dealing with a known content-type
                if (i) for (r in s) if (s[r] && s[r].test(i)) {
                    l.unshift(r);
                    break;
                }
                // Check to see if we have a response for the expected dataType
                if (l[0] in n) o = l[0]; else {
                    // Try convertible dataTypes
                    for (r in n) {
                        if (!l[0] || e.converters[r + " " + l[0]]) {
                            o = r;
                            break;
                        }
                        if (!a) a = r;
                    }
                    // Or just use first one
                    o = o || a;
                }
                // If we found a dataType
                // We add the dataType to the list if needed
                // and return the corresponding response
                if (o) {
                    if (o !== l[0]) l.unshift(o);
                    return n[o];
                }
            }
            /* Chain conversions given the request and the original response
 * Also sets the responseXXX fields on the jqXHR instance
 */
            function re(e, t, n, i) {
                var r, o, a, s, l, u = {}, // Work with a copy of dataTypes in case we need to modify it for conversion
                c = e.dataTypes.slice();
                // Create converters map with lowercased keys
                if (c[1]) for (a in e.converters) u[a.toLowerCase()] = e.converters[a];
                o = c.shift();
                // Convert to each sequential dataType
                for (;o; ) {
                    if (e.responseFields[o]) n[e.responseFields[o]] = t;
                    // Apply the dataFilter if provided
                    if (!l && i && e.dataFilter) t = e.dataFilter(t, e.dataType);
                    l = o;
                    o = c.shift();
                    if (o) // There's only work to do if current dataType is non-auto
                    if ("*" === o) o = l; else if ("*" !== l && l !== o) {
                        // Seek a direct converter
                        a = u[l + " " + o] || u["* " + o];
                        // If none found, seek a pair
                        if (!a) for (r in u) {
                            // If conv2 outputs current
                            s = r.split(" ");
                            if (s[1] === o) {
                                // If prev can be converted to accepted input
                                a = u[l + " " + s[0]] || u["* " + s[0]];
                                if (a) {
                                    // Condense equivalence converters
                                    if (!0 === a) a = u[r]; else if (!0 !== u[r]) {
                                        o = s[0];
                                        c.unshift(s[1]);
                                    }
                                    break;
                                }
                            }
                        }
                        // Apply converter (if not an equivalence)
                        if (!0 !== a) // Unless errors are allowed to bubble, catch and return them
                        if (a && e["throws"]) t = a(t); else try {
                            t = a(t);
                        } catch (f) {
                            return {
                                state: "parsererror",
                                error: a ? f : "No conversion from " + l + " to " + o
                            };
                        }
                    }
                }
                return {
                    state: "success",
                    data: t
                };
            }
            var oe = [];
            var ae = n.document;
            var se = Object.getPrototypeOf;
            var le = oe.slice;
            var ue = oe.concat;
            var ce = oe.push;
            var fe = oe.indexOf;
            var de = {};
            var pe = de.toString;
            var he = de.hasOwnProperty;
            var ve = he.toString;
            var ge = ve.call(Object);
            var me = {};
            /* global Symbol */
            // Defining this global in .eslintrc.json would create a danger of using the global
            // unguarded in another place, it seems safer to define global only for this module
            var ye = "3.2.1", // Define a local copy of jQuery
            be = function(e, t) {
                // The jQuery object is actually just the init constructor 'enhanced'
                // Need init if jQuery is called (just allow error to be thrown if not included)
                return new be.fn.init(e, t);
            }, // Support: Android <=4.0 only
            // Make sure we trim BOM and NBSP
            xe = /^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, // Matches dashed string for camelizing
            we = /^-ms-/, Te = /-([a-z])/g, // Used by jQuery.camelCase as callback to replace()
            Ce = function(e, t) {
                return t.toUpperCase();
            };
            be.fn = be.prototype = {
                // The current version of jQuery being used
                jquery: ye,
                constructor: be,
                // The default length of a jQuery object is 0
                length: 0,
                toArray: function() {
                    return le.call(this);
                },
                // Get the Nth element in the matched element set OR
                // Get the whole matched element set as a clean array
                get: function(e) {
                    // Return all the elements in a clean array
                    if (null == e) return le.call(this);
                    // Return just the one element from the set
                    return e < 0 ? this[e + this.length] : this[e];
                },
                // Take an array of elements and push it onto the stack
                // (returning the new matched element set)
                pushStack: function(e) {
                    // Build a new jQuery matched element set
                    var t = be.merge(this.constructor(), e);
                    // Add the old object onto the stack (as a reference)
                    t.prevObject = this;
                    // Return the newly-formed element set
                    return t;
                },
                // Execute a callback for every element in the matched set.
                each: function(e) {
                    return be.each(this, e);
                },
                map: function(e) {
                    return this.pushStack(be.map(this, function(t, n) {
                        return e.call(t, n, t);
                    }));
                },
                slice: function() {
                    return this.pushStack(le.apply(this, arguments));
                },
                first: function() {
                    return this.eq(0);
                },
                last: function() {
                    return this.eq(-1);
                },
                eq: function(e) {
                    var t = this.length, n = +e + (e < 0 ? t : 0);
                    return this.pushStack(n >= 0 && n < t ? [ this[n] ] : []);
                },
                end: function() {
                    return this.prevObject || this.constructor();
                },
                // For internal use only.
                // Behaves like an Array's method, not like a jQuery method.
                push: ce,
                sort: oe.sort,
                splice: oe.splice
            };
            be.extend = be.fn.extend = function() {
                var e, t, n, i, r, o, a = arguments[0] || {}, s = 1, l = arguments.length, u = !1;
                // Handle a deep copy situation
                if ("boolean" === typeof a) {
                    u = a;
                    // Skip the boolean and the target
                    a = arguments[s] || {};
                    s++;
                }
                // Handle case when target is a string or something (possible in deep copy)
                if ("object" !== typeof a && !be.isFunction(a)) a = {};
                // Extend jQuery itself if only one argument is passed
                if (s === l) {
                    a = this;
                    s--;
                }
                for (;s < l; s++) // Only deal with non-null/undefined values
                if (null != (e = arguments[s])) // Extend the base object
                for (t in e) {
                    n = a[t];
                    i = e[t];
                    // Prevent never-ending loop
                    if (a === i) continue;
                    // Recurse if we're merging plain objects or arrays
                    if (u && i && (be.isPlainObject(i) || (r = Array.isArray(i)))) {
                        if (r) {
                            r = !1;
                            o = n && Array.isArray(n) ? n : [];
                        } else o = n && be.isPlainObject(n) ? n : {};
                        // Never move original objects, clone them
                        a[t] = be.extend(u, o, i);
                    } else if (i !== undefined) a[t] = i;
                }
                // Return the modified object
                return a;
            };
            be.extend({
                // Unique for each copy of jQuery on the page
                expando: "jQuery" + (ye + Math.random()).replace(/\D/g, ""),
                // Assume jQuery is ready without the ready module
                isReady: !0,
                error: function(e) {
                    throw new Error(e);
                },
                noop: function() {},
                isFunction: function(e) {
                    return "function" === be.type(e);
                },
                isWindow: function(e) {
                    return null != e && e === e.window;
                },
                isNumeric: function(e) {
                    // As of jQuery 3.0, isNumeric is limited to
                    // strings and numbers (primitives or objects)
                    // that can be coerced to finite numbers (gh-2662)
                    var t = be.type(e);
                    // parseFloat NaNs numeric-cast false positives ("")
                    // ...but misinterprets leading-number strings, particularly hex literals ("0x...")
                    // subtraction forces infinities to NaN
                    return ("number" === t || "string" === t) && !isNaN(e - parseFloat(e));
                },
                isPlainObject: function(e) {
                    var t, n;
                    // Detect obvious negatives
                    // Use toString instead of jQuery.type to catch host objects
                    if (!e || "[object Object]" !== pe.call(e)) return !1;
                    t = se(e);
                    // Objects with no prototype (e.g., `Object.create( null )`) are plain
                    if (!t) return !0;
                    // Objects with prototype are plain iff they were constructed by a global Object function
                    n = he.call(t, "constructor") && t.constructor;
                    return "function" === typeof n && ve.call(n) === ge;
                },
                isEmptyObject: function(e) {
                    /* eslint-disable no-unused-vars */
                    // See https://github.com/eslint/eslint/issues/6125
                    var t;
                    for (t in e) return !1;
                    return !0;
                },
                type: function(e) {
                    if (null == e) return e + "";
                    // Support: Android <=2.3 only (functionish RegExp)
                    return "object" === typeof e || "function" === typeof e ? de[pe.call(e)] || "object" : typeof e;
                },
                // Evaluates a script in a global context
                globalEval: function(e) {
                    a(e);
                },
                // Convert dashed to camelCase; used by the css and data modules
                // Support: IE <=9 - 11, Edge 12 - 13
                // Microsoft forgot to hump their vendor prefix (#9572)
                camelCase: function(e) {
                    return e.replace(we, "ms-").replace(Te, Ce);
                },
                each: function(e, t) {
                    var n, i = 0;
                    if (s(e)) {
                        n = e.length;
                        for (;i < n && !1 !== t.call(e[i], i, e[i]); i++) ;
                    } else for (i in e) if (!1 === t.call(e[i], i, e[i])) break;
                    return e;
                },
                // Support: Android <=4.0 only
                trim: function(e) {
                    return null == e ? "" : (e + "").replace(xe, "");
                },
                // results is for internal usage only
                makeArray: function(e, t) {
                    var n = t || [];
                    if (null != e) if (s(Object(e))) be.merge(n, "string" === typeof e ? [ e ] : e); else ce.call(n, e);
                    return n;
                },
                inArray: function(e, t, n) {
                    return null == t ? -1 : fe.call(t, e, n);
                },
                // Support: Android <=4.0 only, PhantomJS 1 only
                // push.apply(_, arraylike) throws on ancient WebKit
                merge: function(e, t) {
                    var n = +t.length, i = 0, r = e.length;
                    for (;i < n; i++) e[r++] = t[i];
                    e.length = r;
                    return e;
                },
                grep: function(e, t, n) {
                    var i, r = [], o = 0, a = e.length, s = !n;
                    // Go through the array, only saving the items
                    // that pass the validator function
                    for (;o < a; o++) {
                        i = !t(e[o], o);
                        if (i !== s) r.push(e[o]);
                    }
                    return r;
                },
                // arg is for internal usage only
                map: function(e, t, n) {
                    var i, r, o = 0, a = [];
                    // Go through the array, translating each of the items to their new values
                    if (s(e)) {
                        i = e.length;
                        for (;o < i; o++) {
                            r = t(e[o], o, n);
                            if (null != r) a.push(r);
                        }
                    } else for (o in e) {
                        r = t(e[o], o, n);
                        if (null != r) a.push(r);
                    }
                    // Flatten any nested arrays
                    return ue.apply([], a);
                },
                // A global GUID counter for objects
                guid: 1,
                // Bind a function to a context, optionally partially applying any
                // arguments.
                proxy: function(e, t) {
                    var n, i, r;
                    if ("string" === typeof t) {
                        n = e[t];
                        t = e;
                        e = n;
                    }
                    // Quick check to determine if target is callable, in the spec
                    // this throws a TypeError, but we will just return undefined.
                    if (!be.isFunction(e)) return undefined;
                    // Simulated bind
                    i = le.call(arguments, 2);
                    r = function() {
                        return e.apply(t || this, i.concat(le.call(arguments)));
                    };
                    // Set the guid of unique handler to the same of original handler, so it can be removed
                    r.guid = e.guid = e.guid || be.guid++;
                    return r;
                },
                now: Date.now,
                // jQuery.support is not used in Core but other projects attach their
                // properties to it so it needs to exist.
                support: me
            });
            if ("function" === typeof Symbol) be.fn[Symbol.iterator] = oe[Symbol.iterator];
            // Populate the class2type map
            be.each("Boolean Number String Function Array Date RegExp Object Error Symbol".split(" "), function(e, t) {
                de["[object " + t + "]"] = t.toLowerCase();
            });
            var ke = /*!
 * Sizzle CSS Selector Engine v2.3.3
 * https://sizzlejs.com/
 *
 * Copyright jQuery Foundation and other contributors
 * Released under the MIT license
 * http://jquery.org/license
 *
 * Date: 2016-08-08
 */
            function(e) {
                function t(e, t, n, i) {
                    var r, o, a, s, l, u, c, d = t && t.ownerDocument, // nodeType defaults to 9, since context defaults to document
                    h = t ? t.nodeType : 9;
                    n = n || [];
                    // Return early from calls with invalid selector or context
                    if ("string" !== typeof e || !e || 1 !== h && 9 !== h && 11 !== h) return n;
                    // Try to shortcut find operations (as opposed to filters) in HTML documents
                    if (!i) {
                        if ((t ? t.ownerDocument || t : W) !== j) q(t);
                        t = t || j;
                        if (L) {
                            // If the selector is sufficiently simple, try using a "get*By*" DOM method
                            // (excepting DocumentFragment context, where the methods don't exist)
                            if (11 !== h && (l = me.exec(e))) // ID selector
                            if (r = l[1]) {
                                // Document context
                                if (9 === h) if (a = t.getElementById(r)) {
                                    // Support: IE, Opera, Webkit
                                    // TODO: identify versions
                                    // getElementById can match elements by name instead of ID
                                    if (a.id === r) {
                                        n.push(a);
                                        return n;
                                    }
                                } else return n; else // Support: IE, Opera, Webkit
                                // TODO: identify versions
                                // getElementById can match elements by name instead of ID
                                if (d && (a = d.getElementById(r)) && F(t, a) && a.id === r) {
                                    n.push(a);
                                    return n;
                                }
                            } else if (l[2]) {
                                J.apply(n, t.getElementsByTagName(e));
                                return n;
                            } else if ((r = l[3]) && T.getElementsByClassName && t.getElementsByClassName) {
                                J.apply(n, t.getElementsByClassName(r));
                                return n;
                            }
                            // Take advantage of querySelectorAll
                            if (T.qsa && !B[e + " "] && (!I || !I.test(e))) {
                                if (1 !== h) {
                                    d = t;
                                    c = e;
                                } else if ("object" !== t.nodeName.toLowerCase()) {
                                    // Capture the context ID, setting it first if necessary
                                    if (s = t.getAttribute("id")) s = s.replace(we, Te); else t.setAttribute("id", s = R);
                                    // Prefix every selector in the list
                                    u = E(e);
                                    o = u.length;
                                    for (;o--; ) u[o] = "#" + s + " " + p(u[o]);
                                    c = u.join(",");
                                    // Expand context for sibling selectors
                                    d = ye.test(e) && f(t.parentNode) || t;
                                }
                                if (c) try {
                                    J.apply(n, d.querySelectorAll(c));
                                    return n;
                                } catch (v) {} finally {
                                    if (s === R) t.removeAttribute("id");
                                }
                            }
                        }
                    }
                    // All others
                    return P(e.replace(se, "$1"), t, n, i);
                }
                /**
 * Create key-value caches of limited size
 * @returns {function(string, object)} Returns the Object data after storing it on itself with
 *	property name the (space-suffixed) string and (if the cache is larger than Expr.cacheLength)
 *	deleting the oldest entry
 */
                function n() {
                    function e(n, i) {
                        // Use (key + " ") to avoid collision with native prototype properties (see Issue #157)
                        if (t.push(n + " ") > C.cacheLength) // Only keep the most recent entries
                        delete e[t.shift()];
                        return e[n + " "] = i;
                    }
                    var t = [];
                    return e;
                }
                /**
 * Mark a function for special use by Sizzle
 * @param {Function} fn The function to mark
 */
                function i(e) {
                    e[R] = !0;
                    return e;
                }
                /**
 * Support testing using an element
 * @param {Function} fn Passed the created element and returns a boolean result
 */
                function r(e) {
                    var t = j.createElement("fieldset");
                    try {
                        return !!e(t);
                    } catch (n) {
                        return !1;
                    } finally {
                        // Remove from its parent by default
                        if (t.parentNode) t.parentNode.removeChild(t);
                        // release memory in IE
                        t = null;
                    }
                }
                /**
 * Adds the same handler for all of the specified attrs
 * @param {String} attrs Pipe-separated list of attributes
 * @param {Function} handler The method that will be applied
 */
                function o(e, t) {
                    var n = e.split("|"), i = n.length;
                    for (;i--; ) C.attrHandle[n[i]] = t;
                }
                /**
 * Checks document order of two siblings
 * @param {Element} a
 * @param {Element} b
 * @returns {Number} Returns less than 0 if a precedes b, greater than 0 if a follows b
 */
                function a(e, t) {
                    var n = t && e, i = n && 1 === e.nodeType && 1 === t.nodeType && e.sourceIndex - t.sourceIndex;
                    // Use IE sourceIndex if available on both nodes
                    if (i) return i;
                    // Check if b follows a
                    if (n) for (;n = n.nextSibling; ) if (n === t) return -1;
                    return e ? 1 : -1;
                }
                /**
 * Returns a function to use in pseudos for input types
 * @param {String} type
 */
                function s(e) {
                    return function(t) {
                        return "input" === t.nodeName.toLowerCase() && t.type === e;
                    };
                }
                /**
 * Returns a function to use in pseudos for buttons
 * @param {String} type
 */
                function l(e) {
                    return function(t) {
                        var n = t.nodeName.toLowerCase();
                        return ("input" === n || "button" === n) && t.type === e;
                    };
                }
                /**
 * Returns a function to use in pseudos for :enabled/:disabled
 * @param {Boolean} disabled true for :disabled; false for :enabled
 */
                function u(e) {
                    // Known :disabled false positives: fieldset[disabled] > legend:nth-of-type(n+2) :can-disable
                    return function(t) {
                        // Only certain elements can match :enabled or :disabled
                        // https://html.spec.whatwg.org/multipage/scripting.html#selector-enabled
                        // https://html.spec.whatwg.org/multipage/scripting.html#selector-disabled
                        if ("form" in t) {
                            // Check for inherited disabledness on relevant non-disabled elements:
                            // * listed form-associated elements in a disabled fieldset
                            //   https://html.spec.whatwg.org/multipage/forms.html#category-listed
                            //   https://html.spec.whatwg.org/multipage/forms.html#concept-fe-disabled
                            // * option elements in a disabled optgroup
                            //   https://html.spec.whatwg.org/multipage/forms.html#concept-option-disabled
                            // All such elements have a "form" property.
                            if (t.parentNode && !1 === t.disabled) {
                                // Option elements defer to a parent optgroup if present
                                if ("label" in t) if ("label" in t.parentNode) return t.parentNode.disabled === e; else return t.disabled === e;
                                // Support: IE 6 - 11
                                // Use the isDisabled shortcut property to check for disabled fieldset ancestors
                                // Where there is no isDisabled, check manually
                                /* jshint -W018 */
                                return t.isDisabled === e || t.isDisabled !== !e && ke(t) === e;
                            }
                            return t.disabled === e;
                        } else if ("label" in t) return t.disabled === e;
                        // Remaining elements are neither :enabled nor :disabled
                        return !1;
                    };
                }
                /**
 * Returns a function to use in pseudos for positionals
 * @param {Function} fn
 */
                function c(e) {
                    return i(function(t) {
                        t = +t;
                        return i(function(n, i) {
                            var r, o = e([], n.length, t), a = o.length;
                            // Match elements found at the specified indexes
                            for (;a--; ) if (n[r = o[a]]) n[r] = !(i[r] = n[r]);
                        });
                    });
                }
                /**
 * Checks a node for validity as a Sizzle context
 * @param {Element|Object=} context
 * @returns {Element|Object|Boolean} The input node if acceptable, otherwise a falsy value
 */
                function f(e) {
                    return e && "undefined" !== typeof e.getElementsByTagName && e;
                }
                // Easy API for creating new setFilters
                function d() {}
                function p(e) {
                    var t = 0, n = e.length, i = "";
                    for (;t < n; t++) i += e[t].value;
                    return i;
                }
                function h(e, t, n) {
                    var i = t.dir, r = t.next, o = r || i, a = n && "parentNode" === o, s = z++;
                    // Check against closest ancestor/preceding element
                    // Check against all ancestor/preceding elements
                    return t.first ? function(t, n, r) {
                        for (;t = t[i]; ) if (1 === t.nodeType || a) return e(t, n, r);
                        return !1;
                    } : function(t, n, l) {
                        var u, c, f, d = [ $, s ];
                        // We can't set arbitrary data on XML nodes, so they don't benefit from combinator caching
                        if (l) {
                            for (;t = t[i]; ) if (1 === t.nodeType || a) if (e(t, n, l)) return !0;
                        } else for (;t = t[i]; ) if (1 === t.nodeType || a) {
                            f = t[R] || (t[R] = {});
                            // Support: IE <9 only
                            // Defend against cloned attroperties (jQuery gh-1709)
                            c = f[t.uniqueID] || (f[t.uniqueID] = {});
                            if (r && r === t.nodeName.toLowerCase()) t = t[i] || t; else if ((u = c[o]) && u[0] === $ && u[1] === s) // Assign to newCache so results back-propagate to previous elements
                            return d[2] = u[2]; else {
                                // Reuse newcache so results back-propagate to previous elements
                                c[o] = d;
                                // A match means we're done; a fail means we have to keep checking
                                if (d[2] = e(t, n, l)) return !0;
                            }
                        }
                        return !1;
                    };
                }
                function v(e) {
                    return e.length > 1 ? function(t, n, i) {
                        var r = e.length;
                        for (;r--; ) if (!e[r](t, n, i)) return !1;
                        return !0;
                    } : e[0];
                }
                function g(e, n, i) {
                    var r = 0, o = n.length;
                    for (;r < o; r++) t(e, n[r], i);
                    return i;
                }
                function m(e, t, n, i, r) {
                    var o, a = [], s = 0, l = e.length, u = null != t;
                    for (;s < l; s++) if (o = e[s]) if (!n || n(o, i, r)) {
                        a.push(o);
                        if (u) t.push(s);
                    }
                    return a;
                }
                function y(e, t, n, r, o, a) {
                    if (r && !r[R]) r = y(r);
                    if (o && !o[R]) o = y(o, a);
                    return i(function(i, a, s, l) {
                        var u, c, f, d = [], p = [], h = a.length, // Get initial elements from seed or context
                        v = i || g(t || "*", s.nodeType ? [ s ] : s, []), // Prefilter to get matcher input, preserving a map for seed-results synchronization
                        y = e && (i || !t) ? m(v, d, e, s, l) : v, b = n ? // If we have a postFinder, or filtered seed, or non-seed postFilter or preexisting results,
                        o || (i ? e : h || r) ? // ...intermediate processing is necessary
                        [] : // ...otherwise use results directly
                        a : y;
                        // Find primary matches
                        if (n) n(y, b, s, l);
                        // Apply postFilter
                        if (r) {
                            u = m(b, p);
                            r(u, [], s, l);
                            // Un-match failing elements by moving them back to matcherIn
                            c = u.length;
                            for (;c--; ) if (f = u[c]) b[p[c]] = !(y[p[c]] = f);
                        }
                        if (i) {
                            if (o || e) {
                                if (o) {
                                    // Get the final matcherOut by condensing this intermediate into postFinder contexts
                                    u = [];
                                    c = b.length;
                                    for (;c--; ) if (f = b[c]) // Restore matcherIn since elem is not yet a final match
                                    u.push(y[c] = f);
                                    o(null, b = [], u, l);
                                }
                                // Move matched elements from seed to results to keep them synchronized
                                c = b.length;
                                for (;c--; ) if ((f = b[c]) && (u = o ? ee(i, f) : d[c]) > -1) i[u] = !(a[u] = f);
                            }
                        } else {
                            b = m(b === a ? b.splice(h, b.length) : b);
                            if (o) o(null, a, b, l); else J.apply(a, b);
                        }
                    });
                }
                function b(e) {
                    var t, n, i, r = e.length, o = C.relative[e[0].type], a = o || C.relative[" "], s = o ? 1 : 0, // The foundational matcher ensures that elements are reachable from top-level context(s)
                    l = h(function(e) {
                        return e === t;
                    }, a, !0), u = h(function(e) {
                        return ee(t, e) > -1;
                    }, a, !0), c = [ function(e, n, i) {
                        var r = !o && (i || n !== D) || ((t = n).nodeType ? l(e, n, i) : u(e, n, i));
                        // Avoid hanging onto element (issue #299)
                        t = null;
                        return r;
                    } ];
                    for (;s < r; s++) if (n = C.relative[e[s].type]) c = [ h(v(c), n) ]; else {
                        n = C.filter[e[s].type].apply(null, e[s].matches);
                        // Return special upon seeing a positional matcher
                        if (n[R]) {
                            // Find the next relative operator (if any) for proper handling
                            i = ++s;
                            for (;i < r && !C.relative[e[i].type]; i++) ;
                            // If the preceding token was a descendant combinator, insert an implicit any-element `*`
                            return y(s > 1 && v(c), s > 1 && p(e.slice(0, s - 1).concat({
                                value: " " === e[s - 2].type ? "*" : ""
                            })).replace(se, "$1"), n, s < i && b(e.slice(s, i)), i < r && b(e = e.slice(i)), i < r && p(e));
                        }
                        c.push(n);
                    }
                    return v(c);
                }
                function x(e, n) {
                    var r = n.length > 0, o = e.length > 0, a = function(i, a, s, l, u) {
                        var c, f, d, p = 0, h = "0", v = i && [], g = [], y = D, // We must always have either seed elements or outermost context
                        b = i || o && C.find.TAG("*", u), // Use integer dirruns iff this is the outermost matcher
                        x = $ += null == y ? 1 : Math.random() || .1, w = b.length;
                        if (u) D = a === j || a || u;
                        // Add elements passing elementMatchers directly to results
                        // Support: IE<9, Safari
                        // Tolerate NodeList properties (IE: "length"; Safari: <number>) matching elements by id
                        for (;h !== w && null != (c = b[h]); h++) {
                            if (o && c) {
                                f = 0;
                                if (!a && c.ownerDocument !== j) {
                                    q(c);
                                    s = !L;
                                }
                                for (;d = e[f++]; ) if (d(c, a || j, s)) {
                                    l.push(c);
                                    break;
                                }
                                if (u) $ = x;
                            }
                            // Track unmatched elements for set filters
                            if (r) {
                                // They will have gone through all possible matchers
                                if (c = !d && c) p--;
                                // Lengthen the array for every element, matched or not
                                if (i) v.push(c);
                            }
                        }
                        // `i` is now the count of elements visited above, and adding it to `matchedCount`
                        // makes the latter nonnegative.
                        p += h;
                        // Apply set filters to unmatched elements
                        // NOTE: This can be skipped if there are no unmatched elements (i.e., `matchedCount`
                        // equals `i`), unless we didn't visit _any_ elements in the above loop because we have
                        // no element matchers and no seed.
                        // Incrementing an initially-string "0" `i` allows `i` to remain a string only in that
                        // case, which will result in a "00" `matchedCount` that differs from `i` but is also
                        // numerically zero.
                        if (r && h !== p) {
                            f = 0;
                            for (;d = n[f++]; ) d(v, g, a, s);
                            if (i) {
                                // Reintegrate element matches to eliminate the need for sorting
                                if (p > 0) for (;h--; ) if (!v[h] && !g[h]) g[h] = G.call(l);
                                // Discard index placeholder values to get only actual matches
                                g = m(g);
                            }
                            // Add matches to results
                            J.apply(l, g);
                            // Seedless set matches succeeding multiple successful matchers stipulate sorting
                            if (u && !i && g.length > 0 && p + n.length > 1) t.uniqueSort(l);
                        }
                        // Override manipulation of globals by nested matchers
                        if (u) {
                            $ = x;
                            D = y;
                        }
                        return v;
                    };
                    return r ? i(a) : a;
                }
                var w, T, C, k, S, E, A, P, D, O, N, // Local document vars
                q, j, M, L, I, H, _, F, // Instance-specific data
                R = "sizzle" + 1 * new Date(), W = e.document, $ = 0, z = 0, V = n(), X = n(), B = n(), Y = function(e, t) {
                    if (e === t) N = !0;
                    return 0;
                }, // Instance methods
                Q = {}.hasOwnProperty, U = [], G = U.pop, Z = U.push, J = U.push, K = U.slice, // Use a stripped-down indexOf as it's faster than native
                // https://jsperf.com/thor-indexof-vs-for/5
                ee = function(e, t) {
                    var n = 0, i = e.length;
                    for (;n < i; n++) if (e[n] === t) return n;
                    return -1;
                }, te = "checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped", // Regular expressions
                // http://www.w3.org/TR/css3-selectors/#whitespace
                ne = "[\\x20\\t\\r\\n\\f]", // http://www.w3.org/TR/CSS21/syndata.html#value-def-identifier
                ie = "(?:\\\\.|[\\w-]|[^\0-\\xa0])+", // Attribute selectors: http://www.w3.org/TR/selectors/#attribute-selectors
                re = "\\[" + ne + "*(" + ie + ")(?:" + ne + // Operator (capture 2)
                "*([*^$|!~]?=)" + ne + // "Attribute values must be CSS identifiers [capture 5] or strings [capture 3 or capture 4]"
                "*(?:'((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\"|(" + ie + "))|)" + ne + "*\\]", oe = ":(" + ie + ")(?:\\((" + // To reduce the number of selectors needing tokenize in the preFilter, prefer arguments:
                // 1. quoted (capture 3; capture 4 or capture 5)
                "('((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\")|" + // 2. simple (capture 6)
                "((?:\\\\.|[^\\\\()[\\]]|" + re + ")*)|" + // 3. anything else (capture 2)
                ".*" + ")\\)|)", // Leading and non-escaped trailing whitespace, capturing some non-whitespace characters preceding the latter
                ae = new RegExp(ne + "+", "g"), se = new RegExp("^" + ne + "+|((?:^|[^\\\\])(?:\\\\.)*)" + ne + "+$", "g"), le = new RegExp("^" + ne + "*," + ne + "*"), ue = new RegExp("^" + ne + "*([>+~]|" + ne + ")" + ne + "*"), ce = new RegExp("=" + ne + "*([^\\]'\"]*?)" + ne + "*\\]", "g"), fe = new RegExp(oe), de = new RegExp("^" + ie + "$"), pe = {
                    ID: new RegExp("^#(" + ie + ")"),
                    CLASS: new RegExp("^\\.(" + ie + ")"),
                    TAG: new RegExp("^(" + ie + "|[*])"),
                    ATTR: new RegExp("^" + re),
                    PSEUDO: new RegExp("^" + oe),
                    CHILD: new RegExp("^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\(" + ne + "*(even|odd|(([+-]|)(\\d*)n|)" + ne + "*(?:([+-]|)" + ne + "*(\\d+)|))" + ne + "*\\)|)", "i"),
                    bool: new RegExp("^(?:" + te + ")$", "i"),
                    // For use in libraries implementing .is()
                    // We use this for POS matching in `select`
                    needsContext: new RegExp("^" + ne + "*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\(" + ne + "*((?:-\\d)?\\d*)" + ne + "*\\)|)(?=[^-]|$)", "i")
                }, he = /^(?:input|select|textarea|button)$/i, ve = /^h\d$/i, ge = /^[^{]+\{\s*\[native \w/, // Easily-parseable/retrievable ID or TAG or CLASS selectors
                me = /^(?:#([\w-]+)|(\w+)|\.([\w-]+))$/, ye = /[+~]/, // CSS escapes
                // http://www.w3.org/TR/CSS21/syndata.html#escaped-characters
                be = new RegExp("\\\\([\\da-f]{1,6}" + ne + "?|(" + ne + ")|.)", "ig"), xe = function(e, t, n) {
                    var i = "0x" + t - 65536;
                    // NaN means non-codepoint
                    // Support: Firefox<24
                    // Workaround erroneous numeric interpretation of +"0x"
                    // BMP codepoint
                    // Supplemental Plane codepoint (surrogate pair)
                    return i !== i || n ? t : i < 0 ? String.fromCharCode(i + 65536) : String.fromCharCode(i >> 10 | 55296, 1023 & i | 56320);
                }, // CSS string/identifier serialization
                // https://drafts.csswg.org/cssom/#common-serializing-idioms
                we = /([\0-\x1f\x7f]|^-?\d)|^-$|[^\0-\x1f\x7f-\uFFFF\w-]/g, Te = function(e, t) {
                    if (t) {
                        // U+0000 NULL becomes U+FFFD REPLACEMENT CHARACTER
                        if ("\0" === e) return "ï¿½";
                        // Control characters and (dependent upon position) numbers get escaped as code points
                        return e.slice(0, -1) + "\\" + e.charCodeAt(e.length - 1).toString(16) + " ";
                    }
                    // Other potentially-special ASCII characters get backslash-escaped
                    return "\\" + e;
                }, // Used for iframes
                // See setDocument()
                // Removing the function wrapper causes a "Permission Denied"
                // error in IE
                Ce = function() {
                    q();
                }, ke = h(function(e) {
                    return !0 === e.disabled && ("form" in e || "label" in e);
                }, {
                    dir: "parentNode",
                    next: "legend"
                });
                // Optimize for push.apply( _, NodeList )
                try {
                    J.apply(U = K.call(W.childNodes), W.childNodes);
                    // Support: Android<4.0
                    // Detect silently failing push.apply
                    U[W.childNodes.length].nodeType;
                } catch (Se) {
                    J = {
                        apply: U.length ? // Leverage slice if possible
                        function(e, t) {
                            Z.apply(e, K.call(t));
                        } : // Support: IE<9
                        // Otherwise append directly
                        function(e, t) {
                            var n = e.length, i = 0;
                            // Can't trust NodeList.length
                            for (;e[n++] = t[i++]; ) ;
                            e.length = n - 1;
                        }
                    };
                }
                // Expose support vars for convenience
                T = t.support = {};
                /**
 * Detects XML nodes
 * @param {Element|Object} elem An element or a document
 * @returns {Boolean} True iff elem is a non-HTML XML node
 */
                S = t.isXML = function(e) {
                    // documentElement is verified for cases where it doesn't yet exist
                    // (such as loading iframes in IE - #4833)
                    var t = e && (e.ownerDocument || e).documentElement;
                    return t ? "HTML" !== t.nodeName : !1;
                };
                /**
 * Sets document-related variables once based on the current document
 * @param {Element|Object} [doc] An element or document object to use to set the document
 * @returns {Object} Returns the current document
 */
                q = t.setDocument = function(e) {
                    var t, n, i = e ? e.ownerDocument || e : W;
                    // Return early if doc is invalid or already selected
                    if (i === j || 9 !== i.nodeType || !i.documentElement) return j;
                    // Update global variables
                    j = i;
                    M = j.documentElement;
                    L = !S(j);
                    // Support: IE 9-11, Edge
                    // Accessing iframe documents after unload throws "permission denied" errors (jQuery #13936)
                    if (W !== j && (n = j.defaultView) && n.top !== n) // Support: IE 11, Edge
                    if (n.addEventListener) n.addEventListener("unload", Ce, !1); else if (n.attachEvent) n.attachEvent("onunload", Ce);
                    /* Attributes
	---------------------------------------------------------------------- */
                    // Support: IE<8
                    // Verify that getAttribute really returns attributes and not properties
                    // (excepting IE8 booleans)
                    T.attributes = r(function(e) {
                        e.className = "i";
                        return !e.getAttribute("className");
                    });
                    /* getElement(s)By*
	---------------------------------------------------------------------- */
                    // Check if getElementsByTagName("*") returns only elements
                    T.getElementsByTagName = r(function(e) {
                        e.appendChild(j.createComment(""));
                        return !e.getElementsByTagName("*").length;
                    });
                    // Support: IE<9
                    T.getElementsByClassName = ge.test(j.getElementsByClassName);
                    // Support: IE<10
                    // Check if getElementById returns elements by name
                    // The broken getElementById methods don't pick up programmatically-set names,
                    // so use a roundabout getElementsByName test
                    T.getById = r(function(e) {
                        M.appendChild(e).id = R;
                        return !j.getElementsByName || !j.getElementsByName(R).length;
                    });
                    // ID filter and find
                    if (T.getById) {
                        C.filter.ID = function(e) {
                            var t = e.replace(be, xe);
                            return function(e) {
                                return e.getAttribute("id") === t;
                            };
                        };
                        C.find.ID = function(e, t) {
                            if ("undefined" !== typeof t.getElementById && L) {
                                var n = t.getElementById(e);
                                return n ? [ n ] : [];
                            }
                        };
                    } else {
                        C.filter.ID = function(e) {
                            var t = e.replace(be, xe);
                            return function(e) {
                                var n = "undefined" !== typeof e.getAttributeNode && e.getAttributeNode("id");
                                return n && n.value === t;
                            };
                        };
                        // Support: IE 6 - 7 only
                        // getElementById is not reliable as a find shortcut
                        C.find.ID = function(e, t) {
                            if ("undefined" !== typeof t.getElementById && L) {
                                var n, i, r, o = t.getElementById(e);
                                if (o) {
                                    // Verify the id attribute
                                    n = o.getAttributeNode("id");
                                    if (n && n.value === e) return [ o ];
                                    // Fall back on getElementsByName
                                    r = t.getElementsByName(e);
                                    i = 0;
                                    for (;o = r[i++]; ) {
                                        n = o.getAttributeNode("id");
                                        if (n && n.value === e) return [ o ];
                                    }
                                }
                                return [];
                            }
                        };
                    }
                    // Tag
                    C.find.TAG = T.getElementsByTagName ? function(e, t) {
                        if ("undefined" !== typeof t.getElementsByTagName) return t.getElementsByTagName(e); else if (T.qsa) return t.querySelectorAll(e);
                    } : function(e, t) {
                        var n, i = [], r = 0, // By happy coincidence, a (broken) gEBTN appears on DocumentFragment nodes too
                        o = t.getElementsByTagName(e);
                        // Filter out possible comments
                        if ("*" === e) {
                            for (;n = o[r++]; ) if (1 === n.nodeType) i.push(n);
                            return i;
                        }
                        return o;
                    };
                    // Class
                    C.find.CLASS = T.getElementsByClassName && function(e, t) {
                        if ("undefined" !== typeof t.getElementsByClassName && L) return t.getElementsByClassName(e);
                    };
                    /* QSA/matchesSelector
	---------------------------------------------------------------------- */
                    // QSA and matchesSelector support
                    // matchesSelector(:active) reports false when true (IE9/Opera 11.5)
                    H = [];
                    // qSa(:focus) reports false when true (Chrome 21)
                    // We allow this because of a bug in IE8/9 that throws an error
                    // whenever `document.activeElement` is accessed on an iframe
                    // So, we allow :focus to pass through QSA all the time to avoid the IE error
                    // See https://bugs.jquery.com/ticket/13378
                    I = [];
                    if (T.qsa = ge.test(j.querySelectorAll)) {
                        // Build QSA regex
                        // Regex strategy adopted from Diego Perini
                        r(function(e) {
                            // Select is set to empty string on purpose
                            // This is to test IE's treatment of not explicitly
                            // setting a boolean content attribute,
                            // since its presence should be enough
                            // https://bugs.jquery.com/ticket/12359
                            M.appendChild(e).innerHTML = "<a id='" + R + "'></a>" + "<select id='" + R + "-\r\\' msallowcapture=''>" + "<option selected=''></option></select>";
                            // Support: IE8, Opera 11-12.16
                            // Nothing should be selected when empty strings follow ^= or $= or *=
                            // The test attribute must be unknown in Opera but "safe" for WinRT
                            // https://msdn.microsoft.com/en-us/library/ie/hh465388.aspx#attribute_section
                            if (e.querySelectorAll("[msallowcapture^='']").length) I.push("[*^$]=" + ne + "*(?:''|\"\")");
                            // Support: IE8
                            // Boolean attributes and "value" are not treated correctly
                            if (!e.querySelectorAll("[selected]").length) I.push("\\[" + ne + "*(?:value|" + te + ")");
                            // Support: Chrome<29, Android<4.4, Safari<7.0+, iOS<7.0+, PhantomJS<1.9.8+
                            if (!e.querySelectorAll("[id~=" + R + "-]").length) I.push("~=");
                            // Webkit/Opera - :checked should return selected option elements
                            // http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked
                            // IE8 throws error here and will not see later tests
                            if (!e.querySelectorAll(":checked").length) I.push(":checked");
                            // Support: Safari 8+, iOS 8+
                            // https://bugs.webkit.org/show_bug.cgi?id=136851
                            // In-page `selector#id sibling-combinator selector` fails
                            if (!e.querySelectorAll("a#" + R + "+*").length) I.push(".#.+[+~]");
                        });
                        r(function(e) {
                            e.innerHTML = "<a href='' disabled='disabled'></a>" + "<select disabled='disabled'><option/></select>";
                            // Support: Windows 8 Native Apps
                            // The type and name attributes are restricted during .innerHTML assignment
                            var t = j.createElement("input");
                            t.setAttribute("type", "hidden");
                            e.appendChild(t).setAttribute("name", "D");
                            // Support: IE8
                            // Enforce case-sensitivity of name attribute
                            if (e.querySelectorAll("[name=d]").length) I.push("name" + ne + "*[*^$|!~]?=");
                            // FF 3.5 - :enabled/:disabled and hidden elements (hidden elements are still enabled)
                            // IE8 throws error here and will not see later tests
                            if (2 !== e.querySelectorAll(":enabled").length) I.push(":enabled", ":disabled");
                            // Support: IE9-11+
                            // IE's :disabled selector does not pick up the children of disabled fieldsets
                            M.appendChild(e).disabled = !0;
                            if (2 !== e.querySelectorAll(":disabled").length) I.push(":enabled", ":disabled");
                            // Opera 10-11 does not throw on post-comma invalid pseudos
                            e.querySelectorAll("*,:x");
                            I.push(",.*:");
                        });
                    }
                    if (T.matchesSelector = ge.test(_ = M.matches || M.webkitMatchesSelector || M.mozMatchesSelector || M.oMatchesSelector || M.msMatchesSelector)) r(function(e) {
                        // Check to see if it's possible to do matchesSelector
                        // on a disconnected node (IE 9)
                        T.disconnectedMatch = _.call(e, "*");
                        // This should fail with an exception
                        // Gecko does not error, returns false instead
                        _.call(e, "[s!='']:x");
                        H.push("!=", oe);
                    });
                    I = I.length && new RegExp(I.join("|"));
                    H = H.length && new RegExp(H.join("|"));
                    /* Contains
	---------------------------------------------------------------------- */
                    t = ge.test(M.compareDocumentPosition);
                    // Element contains another
                    // Purposefully self-exclusive
                    // As in, an element does not contain itself
                    F = t || ge.test(M.contains) ? function(e, t) {
                        var n = 9 === e.nodeType ? e.documentElement : e, i = t && t.parentNode;
                        return e === i || !(!i || 1 !== i.nodeType || !(n.contains ? n.contains(i) : e.compareDocumentPosition && 16 & e.compareDocumentPosition(i)));
                    } : function(e, t) {
                        if (t) for (;t = t.parentNode; ) if (t === e) return !0;
                        return !1;
                    };
                    /* Sorting
	---------------------------------------------------------------------- */
                    // Document order sorting
                    Y = t ? function(e, t) {
                        // Flag for duplicate removal
                        if (e === t) {
                            N = !0;
                            return 0;
                        }
                        // Sort on method existence if only one input has compareDocumentPosition
                        var n = !e.compareDocumentPosition - !t.compareDocumentPosition;
                        if (n) return n;
                        // Calculate position if both inputs belong to the same document
                        n = (e.ownerDocument || e) === (t.ownerDocument || t) ? e.compareDocumentPosition(t) : // Otherwise we know they are disconnected
                        1;
                        // Disconnected nodes
                        if (1 & n || !T.sortDetached && t.compareDocumentPosition(e) === n) {
                            // Choose the first element that is related to our preferred document
                            if (e === j || e.ownerDocument === W && F(W, e)) return -1;
                            if (t === j || t.ownerDocument === W && F(W, t)) return 1;
                            // Maintain original order
                            return O ? ee(O, e) - ee(O, t) : 0;
                        }
                        return 4 & n ? -1 : 1;
                    } : function(e, t) {
                        // Exit early if the nodes are identical
                        if (e === t) {
                            N = !0;
                            return 0;
                        }
                        var n, i = 0, r = e.parentNode, o = t.parentNode, s = [ e ], l = [ t ];
                        // Parentless nodes are either documents or disconnected
                        if (!r || !o) return e === j ? -1 : t === j ? 1 : r ? -1 : o ? 1 : O ? ee(O, e) - ee(O, t) : 0; else if (r === o) return a(e, t);
                        // Otherwise we need full lists of their ancestors for comparison
                        n = e;
                        for (;n = n.parentNode; ) s.unshift(n);
                        n = t;
                        for (;n = n.parentNode; ) l.unshift(n);
                        // Walk down the tree looking for a discrepancy
                        for (;s[i] === l[i]; ) i++;
                        // Do a sibling check if the nodes have a common ancestor
                        // Otherwise nodes in our document sort first
                        return i ? a(s[i], l[i]) : s[i] === W ? -1 : l[i] === W ? 1 : 0;
                    };
                    return j;
                };
                t.matches = function(e, n) {
                    return t(e, null, null, n);
                };
                t.matchesSelector = function(e, n) {
                    // Set document vars if needed
                    if ((e.ownerDocument || e) !== j) q(e);
                    // Make sure that attribute selectors are quoted
                    n = n.replace(ce, "='$1']");
                    if (T.matchesSelector && L && !B[n + " "] && (!H || !H.test(n)) && (!I || !I.test(n))) try {
                        var i = _.call(e, n);
                        // IE 9's matchesSelector returns false on disconnected nodes
                        if (i || T.disconnectedMatch || // As well, disconnected nodes are said to be in a document
                        // fragment in IE 9
                        e.document && 11 !== e.document.nodeType) return i;
                    } catch (Se) {}
                    return t(n, j, null, [ e ]).length > 0;
                };
                t.contains = function(e, t) {
                    // Set document vars if needed
                    if ((e.ownerDocument || e) !== j) q(e);
                    return F(e, t);
                };
                t.attr = function(e, t) {
                    // Set document vars if needed
                    if ((e.ownerDocument || e) !== j) q(e);
                    var n = C.attrHandle[t.toLowerCase()], // Don't get fooled by Object.prototype properties (jQuery #13807)
                    i = n && Q.call(C.attrHandle, t.toLowerCase()) ? n(e, t, !L) : undefined;
                    return i !== undefined ? i : T.attributes || !L ? e.getAttribute(t) : (i = e.getAttributeNode(t)) && i.specified ? i.value : null;
                };
                t.escape = function(e) {
                    return (e + "").replace(we, Te);
                };
                t.error = function(e) {
                    throw new Error("Syntax error, unrecognized expression: " + e);
                };
                /**
 * Document sorting and removing duplicates
 * @param {ArrayLike} results
 */
                t.uniqueSort = function(e) {
                    var t, n = [], i = 0, r = 0;
                    // Unless we *know* we can detect duplicates, assume their presence
                    N = !T.detectDuplicates;
                    O = !T.sortStable && e.slice(0);
                    e.sort(Y);
                    if (N) {
                        for (;t = e[r++]; ) if (t === e[r]) i = n.push(r);
                        for (;i--; ) e.splice(n[i], 1);
                    }
                    // Clear input after sorting to release objects
                    // See https://github.com/jquery/sizzle/pull/225
                    O = null;
                    return e;
                };
                /**
 * Utility function for retrieving the text value of an array of DOM nodes
 * @param {Array|Element} elem
 */
                k = t.getText = function(e) {
                    var t, n = "", i = 0, r = e.nodeType;
                    if (!r) // If no nodeType, this is expected to be an array
                    for (;t = e[i++]; ) // Do not traverse comment nodes
                    n += k(t); else if (1 === r || 9 === r || 11 === r) // Use textContent for elements
                    // innerText usage removed for consistency of new lines (jQuery #11153)
                    if ("string" === typeof e.textContent) return e.textContent; else // Traverse its children
                    for (e = e.firstChild; e; e = e.nextSibling) n += k(e); else if (3 === r || 4 === r) return e.nodeValue;
                    // Do not include comment or processing instruction nodes
                    return n;
                };
                C = t.selectors = {
                    // Can be adjusted by the user
                    cacheLength: 50,
                    createPseudo: i,
                    match: pe,
                    attrHandle: {},
                    find: {},
                    relative: {
                        ">": {
                            dir: "parentNode",
                            first: !0
                        },
                        " ": {
                            dir: "parentNode"
                        },
                        "+": {
                            dir: "previousSibling",
                            first: !0
                        },
                        "~": {
                            dir: "previousSibling"
                        }
                    },
                    preFilter: {
                        ATTR: function(e) {
                            e[1] = e[1].replace(be, xe);
                            // Move the given value to match[3] whether quoted or unquoted
                            e[3] = (e[3] || e[4] || e[5] || "").replace(be, xe);
                            if ("~=" === e[2]) e[3] = " " + e[3] + " ";
                            return e.slice(0, 4);
                        },
                        CHILD: function(e) {
                            /* matches from matchExpr["CHILD"]
				1 type (only|nth|...)
				2 what (child|of-type)
				3 argument (even|odd|\d*|\d*n([+-]\d+)?|...)
				4 xn-component of xn+y argument ([+-]?\d*n|)
				5 sign of xn-component
				6 x of xn-component
				7 sign of y-component
				8 y of y-component
			*/
                            e[1] = e[1].toLowerCase();
                            if ("nth" === e[1].slice(0, 3)) {
                                // nth-* requires argument
                                if (!e[3]) t.error(e[0]);
                                // numeric x and y parameters for Expr.filter.CHILD
                                // remember that false/true cast respectively to 0/1
                                e[4] = +(e[4] ? e[5] + (e[6] || 1) : 2 * ("even" === e[3] || "odd" === e[3]));
                                e[5] = +(e[7] + e[8] || "odd" === e[3]);
                            } else if (e[3]) t.error(e[0]);
                            return e;
                        },
                        PSEUDO: function(e) {
                            var t, n = !e[6] && e[2];
                            if (pe.CHILD.test(e[0])) return null;
                            // Accept quoted arguments as-is
                            if (e[3]) e[2] = e[4] || e[5] || ""; else if (n && fe.test(n) && (// Get excess from tokenize (recursively)
                            t = E(n, !0)) && (// advance to the next closing parenthesis
                            t = n.indexOf(")", n.length - t) - n.length)) {
                                // excess is a negative index
                                e[0] = e[0].slice(0, t);
                                e[2] = n.slice(0, t);
                            }
                            // Return only captures needed by the pseudo filter method (type and argument)
                            return e.slice(0, 3);
                        }
                    },
                    filter: {
                        TAG: function(e) {
                            var t = e.replace(be, xe).toLowerCase();
                            return "*" === e ? function() {
                                return !0;
                            } : function(e) {
                                return e.nodeName && e.nodeName.toLowerCase() === t;
                            };
                        },
                        CLASS: function(e) {
                            var t = V[e + " "];
                            return t || (t = new RegExp("(^|" + ne + ")" + e + "(" + ne + "|$)")) && V(e, function(e) {
                                return t.test("string" === typeof e.className && e.className || "undefined" !== typeof e.getAttribute && e.getAttribute("class") || "");
                            });
                        },
                        ATTR: function(e, n, i) {
                            return function(r) {
                                var o = t.attr(r, e);
                                if (null == o) return "!=" === n;
                                if (!n) return !0;
                                o += "";
                                return "=" === n ? o === i : "!=" === n ? o !== i : "^=" === n ? i && 0 === o.indexOf(i) : "*=" === n ? i && o.indexOf(i) > -1 : "$=" === n ? i && o.slice(-i.length) === i : "~=" === n ? (" " + o.replace(ae, " ") + " ").indexOf(i) > -1 : "|=" === n ? o === i || o.slice(0, i.length + 1) === i + "-" : !1;
                            };
                        },
                        CHILD: function(e, t, n, i, r) {
                            var o = "nth" !== e.slice(0, 3), a = "last" !== e.slice(-4), s = "of-type" === t;
                            // Shortcut for :nth-*(n)
                            return 1 === i && 0 === r ? function(e) {
                                return !!e.parentNode;
                            } : function(t, n, l) {
                                var u, c, f, d, p, h, v = o !== a ? "nextSibling" : "previousSibling", g = t.parentNode, m = s && t.nodeName.toLowerCase(), y = !l && !s, b = !1;
                                if (g) {
                                    // :(first|last|only)-(child|of-type)
                                    if (o) {
                                        for (;v; ) {
                                            d = t;
                                            for (;d = d[v]; ) if (s ? d.nodeName.toLowerCase() === m : 1 === d.nodeType) return !1;
                                            // Reverse direction for :only-* (if we haven't yet done so)
                                            h = v = "only" === e && !h && "nextSibling";
                                        }
                                        return !0;
                                    }
                                    h = [ a ? g.firstChild : g.lastChild ];
                                    // non-xml :nth-child(...) stores cache data on `parent`
                                    if (a && y) {
                                        // Seek `elem` from a previously-cached index
                                        // ...in a gzip-friendly way
                                        d = g;
                                        f = d[R] || (d[R] = {});
                                        // Support: IE <9 only
                                        // Defend against cloned attroperties (jQuery gh-1709)
                                        c = f[d.uniqueID] || (f[d.uniqueID] = {});
                                        u = c[e] || [];
                                        p = u[0] === $ && u[1];
                                        b = p && u[2];
                                        d = p && g.childNodes[p];
                                        for (;d = ++p && d && d[v] || (// Fallback to seeking `elem` from the start
                                        b = p = 0) || h.pop(); ) // When found, cache indexes on `parent` and break
                                        if (1 === d.nodeType && ++b && d === t) {
                                            c[e] = [ $, p, b ];
                                            break;
                                        }
                                    } else {
                                        // Use previously-cached element index if available
                                        if (y) {
                                            // ...in a gzip-friendly way
                                            d = t;
                                            f = d[R] || (d[R] = {});
                                            // Support: IE <9 only
                                            // Defend against cloned attroperties (jQuery gh-1709)
                                            c = f[d.uniqueID] || (f[d.uniqueID] = {});
                                            u = c[e] || [];
                                            p = u[0] === $ && u[1];
                                            b = p;
                                        }
                                        // xml :nth-child(...)
                                        // or :nth-last-child(...) or :nth(-last)?-of-type(...)
                                        if (!1 === b) // Use the same loop as above to seek `elem` from the start
                                        for (;d = ++p && d && d[v] || (b = p = 0) || h.pop(); ) if ((s ? d.nodeName.toLowerCase() === m : 1 === d.nodeType) && ++b) {
                                            // Cache the index of each encountered element
                                            if (y) {
                                                f = d[R] || (d[R] = {});
                                                // Support: IE <9 only
                                                // Defend against cloned attroperties (jQuery gh-1709)
                                                c = f[d.uniqueID] || (f[d.uniqueID] = {});
                                                c[e] = [ $, b ];
                                            }
                                            if (d === t) break;
                                        }
                                    }
                                    // Incorporate the offset, then check against cycle size
                                    b -= r;
                                    return b === i || b % i === 0 && b / i >= 0;
                                }
                            };
                        },
                        PSEUDO: function(e, n) {
                            // pseudo-class names are case-insensitive
                            // http://www.w3.org/TR/selectors/#pseudo-classes
                            // Prioritize by case sensitivity in case custom pseudos are added with uppercase letters
                            // Remember that setFilters inherits from pseudos
                            var r, o = C.pseudos[e] || C.setFilters[e.toLowerCase()] || t.error("unsupported pseudo: " + e);
                            // The user may use createPseudo to indicate that
                            // arguments are needed to create the filter function
                            // just as Sizzle does
                            if (o[R]) return o(n);
                            // But maintain support for old signatures
                            if (o.length > 1) {
                                r = [ e, e, "", n ];
                                return C.setFilters.hasOwnProperty(e.toLowerCase()) ? i(function(e, t) {
                                    var i, r = o(e, n), a = r.length;
                                    for (;a--; ) {
                                        i = ee(e, r[a]);
                                        e[i] = !(t[i] = r[a]);
                                    }
                                }) : function(e) {
                                    return o(e, 0, r);
                                };
                            }
                            return o;
                        }
                    },
                    pseudos: {
                        // Potentially complex pseudos
                        not: i(function(e) {
                            // Trim the selector passed to compile
                            // to avoid treating leading and trailing
                            // spaces as combinators
                            var t = [], n = [], r = A(e.replace(se, "$1"));
                            return r[R] ? i(function(e, t, n, i) {
                                var o, a = r(e, null, i, []), s = e.length;
                                // Match elements unmatched by `matcher`
                                for (;s--; ) if (o = a[s]) e[s] = !(t[s] = o);
                            }) : function(e, i, o) {
                                t[0] = e;
                                r(t, null, o, n);
                                // Don't keep the element (issue #299)
                                t[0] = null;
                                return !n.pop();
                            };
                        }),
                        has: i(function(e) {
                            return function(n) {
                                return t(e, n).length > 0;
                            };
                        }),
                        contains: i(function(e) {
                            e = e.replace(be, xe);
                            return function(t) {
                                return (t.textContent || t.innerText || k(t)).indexOf(e) > -1;
                            };
                        }),
                        // "Whether an element is represented by a :lang() selector
                        // is based solely on the element's language value
                        // being equal to the identifier C,
                        // or beginning with the identifier C immediately followed by "-".
                        // The matching of C against the element's language value is performed case-insensitively.
                        // The identifier C does not have to be a valid language name."
                        // http://www.w3.org/TR/selectors/#lang-pseudo
                        lang: i(function(e) {
                            // lang value must be a valid identifier
                            if (!de.test(e || "")) t.error("unsupported lang: " + e);
                            e = e.replace(be, xe).toLowerCase();
                            return function(t) {
                                var n;
                                do {
                                    if (n = L ? t.lang : t.getAttribute("xml:lang") || t.getAttribute("lang")) {
                                        n = n.toLowerCase();
                                        return n === e || 0 === n.indexOf(e + "-");
                                    }
                                } while ((t = t.parentNode) && 1 === t.nodeType);
                                return !1;
                            };
                        }),
                        // Miscellaneous
                        target: function(t) {
                            var n = e.location && e.location.hash;
                            return n && n.slice(1) === t.id;
                        },
                        root: function(e) {
                            return e === M;
                        },
                        focus: function(e) {
                            return e === j.activeElement && (!j.hasFocus || j.hasFocus()) && !!(e.type || e.href || ~e.tabIndex);
                        },
                        // Boolean properties
                        enabled: u(!1),
                        disabled: u(!0),
                        checked: function(e) {
                            // In CSS3, :checked should return both checked and selected elements
                            // http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked
                            var t = e.nodeName.toLowerCase();
                            return "input" === t && !!e.checked || "option" === t && !!e.selected;
                        },
                        selected: function(e) {
                            // Accessing this property makes selected-by-default
                            // options in Safari work properly
                            if (e.parentNode) e.parentNode.selectedIndex;
                            return !0 === e.selected;
                        },
                        // Contents
                        empty: function(e) {
                            // http://www.w3.org/TR/selectors/#empty-pseudo
                            // :empty is negated by element (1) or content nodes (text: 3; cdata: 4; entity ref: 5),
                            //   but not by others (comment: 8; processing instruction: 7; etc.)
                            // nodeType < 6 works because attributes (2) do not appear as children
                            for (e = e.firstChild; e; e = e.nextSibling) if (e.nodeType < 6) return !1;
                            return !0;
                        },
                        parent: function(e) {
                            return !C.pseudos.empty(e);
                        },
                        // Element/input types
                        header: function(e) {
                            return ve.test(e.nodeName);
                        },
                        input: function(e) {
                            return he.test(e.nodeName);
                        },
                        button: function(e) {
                            var t = e.nodeName.toLowerCase();
                            return "input" === t && "button" === e.type || "button" === t;
                        },
                        text: function(e) {
                            var t;
                            // Support: IE<8
                            // New HTML5 attribute values (e.g., "search") appear with elem.type === "text"
                            return "input" === e.nodeName.toLowerCase() && "text" === e.type && (null == (t = e.getAttribute("type")) || "text" === t.toLowerCase());
                        },
                        // Position-in-collection
                        first: c(function() {
                            return [ 0 ];
                        }),
                        last: c(function(e, t) {
                            return [ t - 1 ];
                        }),
                        eq: c(function(e, t, n) {
                            return [ n < 0 ? n + t : n ];
                        }),
                        even: c(function(e, t) {
                            var n = 0;
                            for (;n < t; n += 2) e.push(n);
                            return e;
                        }),
                        odd: c(function(e, t) {
                            var n = 1;
                            for (;n < t; n += 2) e.push(n);
                            return e;
                        }),
                        lt: c(function(e, t, n) {
                            var i = n < 0 ? n + t : n;
                            for (;--i >= 0; ) e.push(i);
                            return e;
                        }),
                        gt: c(function(e, t, n) {
                            var i = n < 0 ? n + t : n;
                            for (;++i < t; ) e.push(i);
                            return e;
                        })
                    }
                };
                C.pseudos.nth = C.pseudos.eq;
                // Add button/input type pseudos
                for (w in {
                    radio: !0,
                    checkbox: !0,
                    file: !0,
                    password: !0,
                    image: !0
                }) C.pseudos[w] = s(w);
                for (w in {
                    submit: !0,
                    reset: !0
                }) C.pseudos[w] = l(w);
                d.prototype = C.filters = C.pseudos;
                C.setFilters = new d();
                E = t.tokenize = function(e, n) {
                    var i, r, o, a, s, l, u, c = X[e + " "];
                    if (c) return n ? 0 : c.slice(0);
                    s = e;
                    l = [];
                    u = C.preFilter;
                    for (;s; ) {
                        // Comma and first run
                        if (!i || (r = le.exec(s))) {
                            if (r) // Don't consume trailing commas as valid
                            s = s.slice(r[0].length) || s;
                            l.push(o = []);
                        }
                        i = !1;
                        // Combinators
                        if (r = ue.exec(s)) {
                            i = r.shift();
                            o.push({
                                value: i,
                                // Cast descendant combinators to space
                                type: r[0].replace(se, " ")
                            });
                            s = s.slice(i.length);
                        }
                        // Filters
                        for (a in C.filter) if ((r = pe[a].exec(s)) && (!u[a] || (r = u[a](r)))) {
                            i = r.shift();
                            o.push({
                                value: i,
                                type: a,
                                matches: r
                            });
                            s = s.slice(i.length);
                        }
                        if (!i) break;
                    }
                    // Return the length of the invalid excess
                    // if we're just parsing
                    // Otherwise, throw an error or return tokens
                    // Cache the tokens
                    return n ? s.length : s ? t.error(e) : X(e, l).slice(0);
                };
                A = t.compile = function(e, t) {
                    var n, i = [], r = [], o = B[e + " "];
                    if (!o) {
                        // Generate a function of recursive functions that can be used to check each element
                        if (!t) t = E(e);
                        n = t.length;
                        for (;n--; ) {
                            o = b(t[n]);
                            if (o[R]) i.push(o); else r.push(o);
                        }
                        // Cache the compiled function
                        o = B(e, x(r, i));
                        // Save selector and tokenization
                        o.selector = e;
                    }
                    return o;
                };
                /**
 * A low-level selection function that works with Sizzle's compiled
 *  selector functions
 * @param {String|Function} selector A selector or a pre-compiled
 *  selector function built with Sizzle.compile
 * @param {Element} context
 * @param {Array} [results]
 * @param {Array} [seed] A set of elements to match against
 */
                P = t.select = function(e, t, n, i) {
                    var r, o, a, s, l, u = "function" === typeof e && e, c = !i && E(e = u.selector || e);
                    n = n || [];
                    // Try to minimize operations if there is only one selector in the list and no seed
                    // (the latter of which guarantees us context)
                    if (1 === c.length) {
                        // Reduce context if the leading compound selector is an ID
                        o = c[0] = c[0].slice(0);
                        if (o.length > 2 && "ID" === (a = o[0]).type && 9 === t.nodeType && L && C.relative[o[1].type]) {
                            t = (C.find.ID(a.matches[0].replace(be, xe), t) || [])[0];
                            if (!t) return n; else if (u) t = t.parentNode;
                            e = e.slice(o.shift().value.length);
                        }
                        // Fetch a seed set for right-to-left matching
                        r = pe.needsContext.test(e) ? 0 : o.length;
                        for (;r--; ) {
                            a = o[r];
                            // Abort if we hit a combinator
                            if (C.relative[s = a.type]) break;
                            if (l = C.find[s]) // Search, expanding context for leading sibling combinators
                            if (i = l(a.matches[0].replace(be, xe), ye.test(o[0].type) && f(t.parentNode) || t)) {
                                // If seed is empty or no tokens remain, we can return early
                                o.splice(r, 1);
                                e = i.length && p(o);
                                if (!e) {
                                    J.apply(n, i);
                                    return n;
                                }
                                break;
                            }
                        }
                    }
                    // Compile and execute a filtering function if one is not provided
                    // Provide `match` to avoid retokenization if we modified the selector above
                    (u || A(e, c))(i, t, !L, n, !t || ye.test(e) && f(t.parentNode) || t);
                    return n;
                };
                // One-time assignments
                // Sort stability
                T.sortStable = R.split("").sort(Y).join("") === R;
                // Support: Chrome 14-35+
                // Always assume duplicates if they aren't passed to the comparison function
                T.detectDuplicates = !!N;
                // Initialize against the default document
                q();
                // Support: Webkit<537.32 - Safari 6.0.3/Chrome 25 (fixed in Chrome 27)
                // Detached nodes confoundingly follow *each other*
                T.sortDetached = r(function(e) {
                    // Should return 1, but returns 4 (following)
                    return 1 & e.compareDocumentPosition(j.createElement("fieldset"));
                });
                // Support: IE<8
                // Prevent attribute/property "interpolation"
                // https://msdn.microsoft.com/en-us/library/ms536429%28VS.85%29.aspx
                if (!r(function(e) {
                    e.innerHTML = "<a href='#'></a>";
                    return "#" === e.firstChild.getAttribute("href");
                })) o("type|href|height|width", function(e, t, n) {
                    if (!n) return e.getAttribute(t, "type" === t.toLowerCase() ? 1 : 2);
                });
                // Support: IE<9
                // Use defaultValue in place of getAttribute("value")
                if (!T.attributes || !r(function(e) {
                    e.innerHTML = "<input/>";
                    e.firstChild.setAttribute("value", "");
                    return "" === e.firstChild.getAttribute("value");
                })) o("value", function(e, t, n) {
                    if (!n && "input" === e.nodeName.toLowerCase()) return e.defaultValue;
                });
                // Support: IE<9
                // Use getAttributeNode to fetch booleans when getAttribute lies
                if (!r(function(e) {
                    return null == e.getAttribute("disabled");
                })) o(te, function(e, t, n) {
                    var i;
                    if (!n) return !0 === e[t] ? t.toLowerCase() : (i = e.getAttributeNode(t)) && i.specified ? i.value : null;
                });
                return t;
            }(n);
            be.find = ke;
            be.expr = ke.selectors;
            // Deprecated
            be.expr[":"] = be.expr.pseudos;
            be.uniqueSort = be.unique = ke.uniqueSort;
            be.text = ke.getText;
            be.isXMLDoc = ke.isXML;
            be.contains = ke.contains;
            be.escapeSelector = ke.escape;
            var Se = function(e, t, n) {
                var i = [], r = n !== undefined;
                for (;(e = e[t]) && 9 !== e.nodeType; ) if (1 === e.nodeType) {
                    if (r && be(e).is(n)) break;
                    i.push(e);
                }
                return i;
            };
            var Ee = function(e, t) {
                var n = [];
                for (;e; e = e.nextSibling) if (1 === e.nodeType && e !== t) n.push(e);
                return n;
            };
            var Ae = be.expr.match.needsContext;
            var Pe = /^<([a-z][^\/\0>:\x20\t\r\n\f]*)[\x20\t\r\n\f]*\/?>(?:<\/\1>|)$/i;
            var De = /^.[^:#\[\.,]*$/;
            be.filter = function(e, t, n) {
                var i = t[0];
                if (n) e = ":not(" + e + ")";
                if (1 === t.length && 1 === i.nodeType) return be.find.matchesSelector(i, e) ? [ i ] : [];
                return be.find.matches(e, be.grep(t, function(e) {
                    return 1 === e.nodeType;
                }));
            };
            be.fn.extend({
                find: function(e) {
                    var t, n, i = this.length, r = this;
                    if ("string" !== typeof e) return this.pushStack(be(e).filter(function() {
                        for (t = 0; t < i; t++) if (be.contains(r[t], this)) return !0;
                    }));
                    n = this.pushStack([]);
                    for (t = 0; t < i; t++) be.find(e, r[t], n);
                    return i > 1 ? be.uniqueSort(n) : n;
                },
                filter: function(e) {
                    return this.pushStack(u(this, e || [], !1));
                },
                not: function(e) {
                    return this.pushStack(u(this, e || [], !0));
                },
                is: function(e) {
                    // If this is a positional/relative selector, check membership in the returned set
                    // so $("p:first").is("p:last") won't return true for a doc with two "p".
                    return !!u(this, "string" === typeof e && Ae.test(e) ? be(e) : e || [], !1).length;
                }
            });
            // Initialize a jQuery object
            // A central reference to the root jQuery(document)
            var Oe, // A simple way to check for HTML strings
            // Prioritize #id over <tag> to avoid XSS via location.hash (#9521)
            // Strict HTML recognition (#11290: must start with <)
            // Shortcut simple #id case for speed
            Ne = /^(?:\s*(<[\w\W]+>)[^>]*|#([\w-]+))$/;
            // Give the init function the jQuery prototype for later instantiation
            (be.fn.init = function(e, t, n) {
                var i, r;
                // HANDLE: $(""), $(null), $(undefined), $(false)
                if (!e) return this;
                // Method init() accepts an alternate rootjQuery
                // so migrate can support jQuery.sub (gh-2101)
                n = n || Oe;
                // Handle HTML strings
                if ("string" === typeof e) {
                    if ("<" === e[0] && ">" === e[e.length - 1] && e.length >= 3) // Assume that strings that start and end with <> are HTML and skip the regex check
                    i = [ null, e, null ]; else i = Ne.exec(e);
                    // Match html or make sure no context is specified for #id
                    if (i && (i[1] || !t)) // HANDLE: $(html) -> $(array)
                    if (i[1]) {
                        t = t instanceof be ? t[0] : t;
                        // Option to run scripts is true for back-compat
                        // Intentionally let the error be thrown if parseHTML is not present
                        be.merge(this, be.parseHTML(i[1], t && t.nodeType ? t.ownerDocument || t : ae, !0));
                        // HANDLE: $(html, props)
                        if (Pe.test(i[1]) && be.isPlainObject(t)) for (i in t) // Properties of context are called as methods if possible
                        if (be.isFunction(this[i])) this[i](t[i]); else this.attr(i, t[i]);
                        return this;
                    } else {
                        r = ae.getElementById(i[2]);
                        if (r) {
                            // Inject the element directly into the jQuery object
                            this[0] = r;
                            this.length = 1;
                        }
                        return this;
                    } else if (!t || t.jquery) return (t || n).find(e); else return this.constructor(t).find(e);
                } else if (e.nodeType) {
                    this[0] = e;
                    this.length = 1;
                    return this;
                } else if (be.isFunction(e)) // Execute immediately if ready is not present
                return n.ready !== undefined ? n.ready(e) : e(be);
                return be.makeArray(e, this);
            }).prototype = be.fn;
            // Initialize central reference
            Oe = be(ae);
            var qe = /^(?:parents|prev(?:Until|All))/, // Methods guaranteed to produce a unique set when starting from a unique set
            je = {
                children: !0,
                contents: !0,
                next: !0,
                prev: !0
            };
            be.fn.extend({
                has: function(e) {
                    var t = be(e, this), n = t.length;
                    return this.filter(function() {
                        var e = 0;
                        for (;e < n; e++) if (be.contains(this, t[e])) return !0;
                    });
                },
                closest: function(e, t) {
                    var n, i = 0, r = this.length, o = [], a = "string" !== typeof e && be(e);
                    // Positional selectors never match, since there's no _selection_ context
                    if (!Ae.test(e)) for (;i < r; i++) for (n = this[i]; n && n !== t; n = n.parentNode) // Always skip document fragments
                    if (n.nodeType < 11 && (a ? a.index(n) > -1 : // Don't pass non-elements to Sizzle
                    1 === n.nodeType && be.find.matchesSelector(n, e))) {
                        o.push(n);
                        break;
                    }
                    return this.pushStack(o.length > 1 ? be.uniqueSort(o) : o);
                },
                // Determine the position of an element within the set
                index: function(e) {
                    // No argument, return index in parent
                    if (!e) return this[0] && this[0].parentNode ? this.first().prevAll().length : -1;
                    // Index in selector
                    if ("string" === typeof e) return fe.call(be(e), this[0]);
                    // Locate the position of the desired element
                    // If it receives a jQuery object, the first element is used
                    return fe.call(this, e.jquery ? e[0] : e);
                },
                add: function(e, t) {
                    return this.pushStack(be.uniqueSort(be.merge(this.get(), be(e, t))));
                },
                addBack: function(e) {
                    return this.add(null == e ? this.prevObject : this.prevObject.filter(e));
                }
            });
            be.each({
                parent: function(e) {
                    var t = e.parentNode;
                    return t && 11 !== t.nodeType ? t : null;
                },
                parents: function(e) {
                    return Se(e, "parentNode");
                },
                parentsUntil: function(e, t, n) {
                    return Se(e, "parentNode", n);
                },
                next: function(e) {
                    return c(e, "nextSibling");
                },
                prev: function(e) {
                    return c(e, "previousSibling");
                },
                nextAll: function(e) {
                    return Se(e, "nextSibling");
                },
                prevAll: function(e) {
                    return Se(e, "previousSibling");
                },
                nextUntil: function(e, t, n) {
                    return Se(e, "nextSibling", n);
                },
                prevUntil: function(e, t, n) {
                    return Se(e, "previousSibling", n);
                },
                siblings: function(e) {
                    return Ee((e.parentNode || {}).firstChild, e);
                },
                children: function(e) {
                    return Ee(e.firstChild);
                },
                contents: function(e) {
                    if (l(e, "iframe")) return e.contentDocument;
                    // Support: IE 9 - 11 only, iOS 7 only, Android Browser <=4.3 only
                    // Treat the template element as a regular one in browsers that
                    // don't support it.
                    if (l(e, "template")) e = e.content || e;
                    return be.merge([], e.childNodes);
                }
            }, function(e, t) {
                be.fn[e] = function(n, i) {
                    var r = be.map(this, t, n);
                    if ("Until" !== e.slice(-5)) i = n;
                    if (i && "string" === typeof i) r = be.filter(i, r);
                    if (this.length > 1) {
                        // Remove duplicates
                        if (!je[e]) be.uniqueSort(r);
                        // Reverse order for parents* and prev-derivatives
                        if (qe.test(e)) r.reverse();
                    }
                    return this.pushStack(r);
                };
            });
            var Me = /[^\x20\t\r\n\f]+/g;
            /*
 * Create a callback list using the following parameters:
 *
 *	options: an optional list of space-separated options that will change how
 *			the callback list behaves or a more traditional option object
 *
 * By default a callback list will act like an event callback list and can be
 * "fired" multiple times.
 *
 * Possible options:
 *
 *	once:			will ensure the callback list can only be fired once (like a Deferred)
 *
 *	memory:			will keep track of previous values and will call any callback added
 *					after the list has been fired right away with the latest "memorized"
 *					values (like a Deferred)
 *
 *	unique:			will ensure a callback can only be added once (no duplicate in the list)
 *
 *	stopOnFalse:	interrupt callings when a callback returns false
 *
 */
            be.Callbacks = function(e) {
                // Convert options from String-formatted to Object-formatted if needed
                // (we check in cache first)
                e = "string" === typeof e ? f(e) : be.extend({}, e);
                var // Flag to know if list is currently firing
                t, // Last fire value for non-forgettable lists
                n, // Flag to know if list was already fired
                i, // Flag to prevent firing
                r, // Actual callback list
                o = [], // Queue of execution data for repeatable lists
                a = [], // Index of currently firing callback (modified by add/remove as needed)
                s = -1, // Fire callbacks
                l = function() {
                    // Enforce single-firing
                    r = r || e.once;
                    // Execute callbacks for all pending executions,
                    // respecting firingIndex overrides and runtime changes
                    i = t = !0;
                    for (;a.length; s = -1) {
                        n = a.shift();
                        for (;++s < o.length; ) // Run callback and check for early termination
                        if (!1 === o[s].apply(n[0], n[1]) && e.stopOnFalse) {
                            // Jump to end and forget the data so .add doesn't re-fire
                            s = o.length;
                            n = !1;
                        }
                    }
                    // Forget the data if we're done with it
                    if (!e.memory) n = !1;
                    t = !1;
                    // Clean up if we're done firing for good
                    if (r) // Keep an empty list if we have data for future add calls
                    if (n) o = []; else o = "";
                }, // Actual Callbacks object
                u = {
                    // Add a callback or a collection of callbacks to the list
                    add: function() {
                        if (o) {
                            // If we have memory from a past run, we should fire after adding
                            if (n && !t) {
                                s = o.length - 1;
                                a.push(n);
                            }
                            !function i(t) {
                                be.each(t, function(t, n) {
                                    if (be.isFunction(n)) {
                                        if (!e.unique || !u.has(n)) o.push(n);
                                    } else if (n && n.length && "string" !== be.type(n)) // Inspect recursively
                                    i(n);
                                });
                            }(arguments);
                            if (n && !t) l();
                        }
                        return this;
                    },
                    // Remove a callback from the list
                    remove: function() {
                        be.each(arguments, function(e, t) {
                            var n;
                            for (;(n = be.inArray(t, o, n)) > -1; ) {
                                o.splice(n, 1);
                                // Handle firing indexes
                                if (n <= s) s--;
                            }
                        });
                        return this;
                    },
                    // Check if a given callback is in the list.
                    // If no argument is given, return whether or not list has callbacks attached.
                    has: function(e) {
                        return e ? be.inArray(e, o) > -1 : o.length > 0;
                    },
                    // Remove all callbacks from the list
                    empty: function() {
                        if (o) o = [];
                        return this;
                    },
                    // Disable .fire and .add
                    // Abort any current/pending executions
                    // Clear all callbacks and values
                    disable: function() {
                        r = a = [];
                        o = n = "";
                        return this;
                    },
                    disabled: function() {
                        return !o;
                    },
                    // Disable .fire
                    // Also disable .add unless we have memory (since it would have no effect)
                    // Abort any pending executions
                    lock: function() {
                        r = a = [];
                        if (!n && !t) o = n = "";
                        return this;
                    },
                    locked: function() {
                        return !!r;
                    },
                    // Call all callbacks with the given context and arguments
                    fireWith: function(e, n) {
                        if (!r) {
                            n = n || [];
                            n = [ e, n.slice ? n.slice() : n ];
                            a.push(n);
                            if (!t) l();
                        }
                        return this;
                    },
                    // Call all the callbacks with the given arguments
                    fire: function() {
                        u.fireWith(this, arguments);
                        return this;
                    },
                    // To know if the callbacks have already been called at least once
                    fired: function() {
                        return !!i;
                    }
                };
                return u;
            };
            be.extend({
                Deferred: function(e) {
                    var t = [ // action, add listener, callbacks,
                    // ... .then handlers, argument index, [final state]
                    [ "notify", "progress", be.Callbacks("memory"), be.Callbacks("memory"), 2 ], [ "resolve", "done", be.Callbacks("once memory"), be.Callbacks("once memory"), 0, "resolved" ], [ "reject", "fail", be.Callbacks("once memory"), be.Callbacks("once memory"), 1, "rejected" ] ], i = "pending", r = {
                        state: function() {
                            return i;
                        },
                        always: function() {
                            o.done(arguments).fail(arguments);
                            return this;
                        },
                        catch: function(e) {
                            return r.then(null, e);
                        },
                        // Keep pipe for back-compat
                        pipe: function() {
                            var e = arguments;
                            return be.Deferred(function(n) {
                                be.each(t, function(t, i) {
                                    // Map tuples (progress, done, fail) to arguments (done, fail, progress)
                                    var r = be.isFunction(e[i[4]]) && e[i[4]];
                                    // deferred.progress(function() { bind to newDefer or newDefer.notify })
                                    // deferred.done(function() { bind to newDefer or newDefer.resolve })
                                    // deferred.fail(function() { bind to newDefer or newDefer.reject })
                                    o[i[1]](function() {
                                        var e = r && r.apply(this, arguments);
                                        if (e && be.isFunction(e.promise)) e.promise().progress(n.notify).done(n.resolve).fail(n.reject); else n[i[0] + "With"](this, r ? [ e ] : arguments);
                                    });
                                });
                                e = null;
                            }).promise();
                        },
                        then: function(e, i, r) {
                            function o(e, t, i, r) {
                                return function() {
                                    var s = this, l = arguments, u = function() {
                                        var n, u;
                                        // Support: Promises/A+ section 2.3.3.3.3
                                        // https://promisesaplus.com/#point-59
                                        // Ignore double-resolution attempts
                                        if (e < a) return;
                                        n = i.apply(s, l);
                                        // Support: Promises/A+ section 2.3.1
                                        // https://promisesaplus.com/#point-48
                                        if (n === t.promise()) throw new TypeError("Thenable self-resolution");
                                        // Support: Promises/A+ sections 2.3.3.1, 3.5
                                        // https://promisesaplus.com/#point-54
                                        // https://promisesaplus.com/#point-75
                                        // Retrieve `then` only once
                                        u = n && (// Support: Promises/A+ section 2.3.4
                                        // https://promisesaplus.com/#point-64
                                        // Only check objects and functions for thenability
                                        "object" === typeof n || "function" === typeof n) && n.then;
                                        // Handle a returned thenable
                                        if (be.isFunction(u)) // Special processors (notify) just wait for resolution
                                        if (r) u.call(n, o(a, t, d, r), o(a, t, p, r)); else {
                                            // ...and disregard older resolution values
                                            a++;
                                            u.call(n, o(a, t, d, r), o(a, t, p, r), o(a, t, d, t.notifyWith));
                                        } else {
                                            // Only substitute handlers pass on context
                                            // and multiple values (non-spec behavior)
                                            if (i !== d) {
                                                s = undefined;
                                                l = [ n ];
                                            }
                                            // Process the value(s)
                                            // Default process is resolve
                                            (r || t.resolveWith)(s, l);
                                        }
                                    }, // Only normal processors (resolve) catch and reject exceptions
                                    c = r ? u : function() {
                                        try {
                                            u();
                                        } catch (n) {
                                            if (be.Deferred.exceptionHook) be.Deferred.exceptionHook(n, c.stackTrace);
                                            // Support: Promises/A+ section 2.3.3.3.4.1
                                            // https://promisesaplus.com/#point-61
                                            // Ignore post-resolution exceptions
                                            if (e + 1 >= a) {
                                                // Only substitute handlers pass on context
                                                // and multiple values (non-spec behavior)
                                                if (i !== p) {
                                                    s = undefined;
                                                    l = [ n ];
                                                }
                                                t.rejectWith(s, l);
                                            }
                                        }
                                    };
                                    // Support: Promises/A+ section 2.3.3.3.1
                                    // https://promisesaplus.com/#point-57
                                    // Re-resolve promises immediately to dodge false rejection from
                                    // subsequent errors
                                    if (e) c(); else {
                                        // Call an optional hook to record the stack, in case of exception
                                        // since it's otherwise lost when execution goes async
                                        if (be.Deferred.getStackHook) c.stackTrace = be.Deferred.getStackHook();
                                        n.setTimeout(c);
                                    }
                                };
                            }
                            var a = 0;
                            return be.Deferred(function(n) {
                                // progress_handlers.add( ... )
                                t[0][3].add(o(0, n, be.isFunction(r) ? r : d, n.notifyWith));
                                // fulfilled_handlers.add( ... )
                                t[1][3].add(o(0, n, be.isFunction(e) ? e : d));
                                // rejected_handlers.add( ... )
                                t[2][3].add(o(0, n, be.isFunction(i) ? i : p));
                            }).promise();
                        },
                        // Get a promise for this deferred
                        // If obj is provided, the promise aspect is added to the object
                        promise: function(e) {
                            return null != e ? be.extend(e, r) : r;
                        }
                    }, o = {};
                    // Add list-specific methods
                    be.each(t, function(e, n) {
                        var a = n[2], s = n[5];
                        // promise.progress = list.add
                        // promise.done = list.add
                        // promise.fail = list.add
                        r[n[1]] = a.add;
                        // Handle state
                        if (s) a.add(function() {
                            // state = "resolved" (i.e., fulfilled)
                            // state = "rejected"
                            i = s;
                        }, // rejected_callbacks.disable
                        // fulfilled_callbacks.disable
                        t[3 - e][2].disable, // progress_callbacks.lock
                        t[0][2].lock);
                        // progress_handlers.fire
                        // fulfilled_handlers.fire
                        // rejected_handlers.fire
                        a.add(n[3].fire);
                        // deferred.notify = function() { deferred.notifyWith(...) }
                        // deferred.resolve = function() { deferred.resolveWith(...) }
                        // deferred.reject = function() { deferred.rejectWith(...) }
                        o[n[0]] = function() {
                            o[n[0] + "With"](this === o ? undefined : this, arguments);
                            return this;
                        };
                        // deferred.notifyWith = list.fireWith
                        // deferred.resolveWith = list.fireWith
                        // deferred.rejectWith = list.fireWith
                        o[n[0] + "With"] = a.fireWith;
                    });
                    // Make the deferred a promise
                    r.promise(o);
                    // Call given func if any
                    if (e) e.call(o, o);
                    // All done!
                    return o;
                },
                // Deferred helper
                when: function(e) {
                    var // count of uncompleted subordinates
                    t = arguments.length, // count of unprocessed arguments
                    n = t, // subordinate fulfillment data
                    i = Array(n), r = le.call(arguments), // the master Deferred
                    o = be.Deferred(), // subordinate callback factory
                    a = function(e) {
                        return function(n) {
                            i[e] = this;
                            r[e] = arguments.length > 1 ? le.call(arguments) : n;
                            if (!--t) o.resolveWith(i, r);
                        };
                    };
                    // Single- and empty arguments are adopted like Promise.resolve
                    if (t <= 1) {
                        h(e, o.done(a(n)).resolve, o.reject, !t);
                        // Use .then() to unwrap secondary thenables (cf. gh-3000)
                        if ("pending" === o.state() || be.isFunction(r[n] && r[n].then)) return o.then();
                    }
                    // Multiple arguments are aggregated like Promise.all array elements
                    for (;n--; ) h(r[n], a(n), o.reject);
                    return o.promise();
                }
            });
            // These usually indicate a programmer mistake during development,
            // warn about them ASAP rather than swallowing them by default.
            var Le = /^(Eval|Internal|Range|Reference|Syntax|Type|URI)Error$/;
            be.Deferred.exceptionHook = function(e, t) {
                // Support: IE 8 - 9 only
                // Console exists when dev tools are open, which can happen at any time
                if (n.console && n.console.warn && e && Le.test(e.name)) n.console.warn("jQuery.Deferred exception: " + e.message, e.stack, t);
            };
            be.readyException = function(e) {
                n.setTimeout(function() {
                    throw e;
                });
            };
            // The deferred used on DOM ready
            var Ie = be.Deferred();
            be.fn.ready = function(e) {
                Ie.then(e)["catch"](function(e) {
                    be.readyException(e);
                });
                return this;
            };
            be.extend({
                // Is the DOM ready to be used? Set to true once it occurs.
                isReady: !1,
                // A counter to track how many items to wait for before
                // the ready event fires. See #6781
                readyWait: 1,
                // Handle when the DOM is ready
                ready: function(e) {
                    // Abort if there are pending holds or we're already ready
                    if (!0 === e ? --be.readyWait : be.isReady) return;
                    // Remember that the DOM is ready
                    be.isReady = !0;
                    // If a normal DOM Ready event fired, decrement, and wait if need be
                    if (!0 !== e && --be.readyWait > 0) return;
                    // If there are functions bound, to execute
                    Ie.resolveWith(ae, [ be ]);
                }
            });
            be.ready.then = Ie.then;
            // Catch cases where $(document).ready() is called
            // after the browser event has already occurred.
            // Support: IE <=9 - 10 only
            // Older IE sometimes signals "interactive" too soon
            if ("complete" === ae.readyState || "loading" !== ae.readyState && !ae.documentElement.doScroll) // Handle it asynchronously to allow scripts the opportunity to delay ready
            n.setTimeout(be.ready); else {
                // Use the handy event callback
                ae.addEventListener("DOMContentLoaded", v);
                // A fallback to window.onload, that will always work
                n.addEventListener("load", v);
            }
            // Multifunctional method to get and set values of a collection
            // The value/s can optionally be executed if it's a function
            var He = function(e, t, n, i, r, o, a) {
                var s = 0, l = e.length, u = null == n;
                // Sets many values
                if ("object" === be.type(n)) {
                    r = !0;
                    for (s in n) He(e, t, s, n[s], !0, o, a);
                } else if (i !== undefined) {
                    r = !0;
                    if (!be.isFunction(i)) a = !0;
                    if (u) // Bulk operations run against the entire set
                    if (a) {
                        t.call(e, i);
                        t = null;
                    } else {
                        u = t;
                        t = function(e, t, n) {
                            return u.call(be(e), n);
                        };
                    }
                    if (t) for (;s < l; s++) t(e[s], n, a ? i : i.call(e[s], s, t(e[s], n)));
                }
                if (r) return e;
                // Gets
                if (u) return t.call(e);
                return l ? t(e[0], n) : o;
            };
            var _e = function(e) {
                // Accepts only:
                //  - Node
                //    - Node.ELEMENT_NODE
                //    - Node.DOCUMENT_NODE
                //  - Object
                //    - Any
                return 1 === e.nodeType || 9 === e.nodeType || !+e.nodeType;
            };
            g.uid = 1;
            g.prototype = {
                cache: function(e) {
                    // Check if the owner object already has a cache
                    var t = e[this.expando];
                    // If not, create one
                    if (!t) {
                        t = {};
                        // We can accept data for non-element nodes in modern browsers,
                        // but we should not, see #8335.
                        // Always return an empty object.
                        if (_e(e)) // If it is a node unlikely to be stringify-ed or looped over
                        // use plain assignment
                        if (e.nodeType) e[this.expando] = t; else Object.defineProperty(e, this.expando, {
                            value: t,
                            configurable: !0
                        });
                    }
                    return t;
                },
                set: function(e, t, n) {
                    var i, r = this.cache(e);
                    // Handle: [ owner, key, value ] args
                    // Always use camelCase key (gh-2257)
                    if ("string" === typeof t) r[be.camelCase(t)] = n; else // Copy the properties one-by-one to the cache object
                    for (i in t) r[be.camelCase(i)] = t[i];
                    return r;
                },
                get: function(e, t) {
                    // Always use camelCase key (gh-2257)
                    return t === undefined ? this.cache(e) : e[this.expando] && e[this.expando][be.camelCase(t)];
                },
                access: function(e, t, n) {
                    // In cases where either:
                    //
                    //   1. No key was specified
                    //   2. A string key was specified, but no value provided
                    //
                    // Take the "read" path and allow the get method to determine
                    // which value to return, respectively either:
                    //
                    //   1. The entire cache object
                    //   2. The data stored at the key
                    //
                    if (t === undefined || t && "string" === typeof t && n === undefined) return this.get(e, t);
                    // When the key is not a string, or both a key and value
                    // are specified, set or extend (existing objects) with either:
                    //
                    //   1. An object of properties
                    //   2. A key and value
                    //
                    this.set(e, t, n);
                    // Since the "set" path can have two possible entry points
                    // return the expected data based on which path was taken[*]
                    return n !== undefined ? n : t;
                },
                remove: function(e, t) {
                    var n, i = e[this.expando];
                    if (i === undefined) return;
                    if (t !== undefined) {
                        // Support array or space separated string of keys
                        if (Array.isArray(t)) // If key is an array of keys...
                        // We always set camelCase keys, so remove that.
                        t = t.map(be.camelCase); else {
                            t = be.camelCase(t);
                            // If a key with the spaces exists, use it.
                            // Otherwise, create an array by matching non-whitespace
                            t = t in i ? [ t ] : t.match(Me) || [];
                        }
                        n = t.length;
                        for (;n--; ) delete i[t[n]];
                    }
                    // Remove the expando if there's no more data
                    if (t === undefined || be.isEmptyObject(i)) // Support: Chrome <=35 - 45
                    // Webkit & Blink performance suffers when deleting properties
                    // from DOM nodes, so set to undefined instead
                    // https://bugs.chromium.org/p/chromium/issues/detail?id=378607 (bug restricted)
                    if (e.nodeType) e[this.expando] = undefined; else delete e[this.expando];
                },
                hasData: function(e) {
                    var t = e[this.expando];
                    return t !== undefined && !be.isEmptyObject(t);
                }
            };
            var Fe = new g();
            var Re = new g();
            //	Implementation Summary
            //
            //	1. Enforce API surface and semantic compatibility with 1.9.x branch
            //	2. Improve the module's maintainability by reducing the storage
            //		paths to a single mechanism.
            //	3. Use the same single mechanism to support "private" and "user" data.
            //	4. _Never_ expose "private" data to user code (TODO: Drop _data, _removeData)
            //	5. Avoid exposing implementation details on user objects (eg. expando properties)
            //	6. Provide a clear path for implementation upgrade to WeakMap in 2014
            var We = /^(?:\{[\w\W]*\}|\[[\w\W]*\])$/, $e = /[A-Z]/g;
            be.extend({
                hasData: function(e) {
                    return Re.hasData(e) || Fe.hasData(e);
                },
                data: function(e, t, n) {
                    return Re.access(e, t, n);
                },
                removeData: function(e, t) {
                    Re.remove(e, t);
                },
                // TODO: Now that all calls to _data and _removeData have been replaced
                // with direct calls to dataPriv methods, these can be deprecated.
                _data: function(e, t, n) {
                    return Fe.access(e, t, n);
                },
                _removeData: function(e, t) {
                    Fe.remove(e, t);
                }
            });
            be.fn.extend({
                data: function(e, t) {
                    var n, i, r, o = this[0], a = o && o.attributes;
                    // Gets all values
                    if (e === undefined) {
                        if (this.length) {
                            r = Re.get(o);
                            if (1 === o.nodeType && !Fe.get(o, "hasDataAttrs")) {
                                n = a.length;
                                for (;n--; ) // Support: IE 11 only
                                // The attrs elements can be null (#14894)
                                if (a[n]) {
                                    i = a[n].name;
                                    if (0 === i.indexOf("data-")) {
                                        i = be.camelCase(i.slice(5));
                                        y(o, i, r[i]);
                                    }
                                }
                                Fe.set(o, "hasDataAttrs", !0);
                            }
                        }
                        return r;
                    }
                    // Sets multiple values
                    if ("object" === typeof e) return this.each(function() {
                        Re.set(this, e);
                    });
                    return He(this, function(t) {
                        var n;
                        // The calling jQuery object (element matches) is not empty
                        // (and therefore has an element appears at this[ 0 ]) and the
                        // `value` parameter was not undefined. An empty jQuery object
                        // will result in `undefined` for elem = this[ 0 ] which will
                        // throw an exception if an attempt to read a data cache is made.
                        if (o && t === undefined) {
                            // Attempt to get data from the cache
                            // The key will always be camelCased in Data
                            n = Re.get(o, e);
                            if (n !== undefined) return n;
                            // Attempt to "discover" the data in
                            // HTML5 custom data-* attrs
                            n = y(o, e);
                            if (n !== undefined) return n;
                            // We tried really hard, but the data doesn't exist.
                            return;
                        }
                        // Set the data...
                        this.each(function() {
                            // We always store the camelCased key
                            Re.set(this, e, t);
                        });
                    }, null, t, arguments.length > 1, null, !0);
                },
                removeData: function(e) {
                    return this.each(function() {
                        Re.remove(this, e);
                    });
                }
            });
            be.extend({
                queue: function(e, t, n) {
                    var i;
                    if (e) {
                        t = (t || "fx") + "queue";
                        i = Fe.get(e, t);
                        // Speed up dequeue by getting out quickly if this is just a lookup
                        if (n) if (!i || Array.isArray(n)) i = Fe.access(e, t, be.makeArray(n)); else i.push(n);
                        return i || [];
                    }
                },
                dequeue: function(e, t) {
                    t = t || "fx";
                    var n = be.queue(e, t), i = n.length, r = n.shift(), o = be._queueHooks(e, t), a = function() {
                        be.dequeue(e, t);
                    };
                    // If the fx queue is dequeued, always remove the progress sentinel
                    if ("inprogress" === r) {
                        r = n.shift();
                        i--;
                    }
                    if (r) {
                        // Add a progress sentinel to prevent the fx queue from being
                        // automatically dequeued
                        if ("fx" === t) n.unshift("inprogress");
                        // Clear up the last queue stop function
                        delete o.stop;
                        r.call(e, a, o);
                    }
                    if (!i && o) o.empty.fire();
                },
                // Not public - generate a queueHooks object, or return the current one
                _queueHooks: function(e, t) {
                    var n = t + "queueHooks";
                    return Fe.get(e, n) || Fe.access(e, n, {
                        empty: be.Callbacks("once memory").add(function() {
                            Fe.remove(e, [ t + "queue", n ]);
                        })
                    });
                }
            });
            be.fn.extend({
                queue: function(e, t) {
                    var n = 2;
                    if ("string" !== typeof e) {
                        t = e;
                        e = "fx";
                        n--;
                    }
                    if (arguments.length < n) return be.queue(this[0], e);
                    return t === undefined ? this : this.each(function() {
                        var n = be.queue(this, e, t);
                        // Ensure a hooks for this queue
                        be._queueHooks(this, e);
                        if ("fx" === e && "inprogress" !== n[0]) be.dequeue(this, e);
                    });
                },
                dequeue: function(e) {
                    return this.each(function() {
                        be.dequeue(this, e);
                    });
                },
                clearQueue: function(e) {
                    return this.queue(e || "fx", []);
                },
                // Get a promise resolved when queues of a certain type
                // are emptied (fx is the type by default)
                promise: function(e, t) {
                    var n, i = 1, r = be.Deferred(), o = this, a = this.length, s = function() {
                        if (!--i) r.resolveWith(o, [ o ]);
                    };
                    if ("string" !== typeof e) {
                        t = e;
                        e = undefined;
                    }
                    e = e || "fx";
                    for (;a--; ) {
                        n = Fe.get(o[a], e + "queueHooks");
                        if (n && n.empty) {
                            i++;
                            n.empty.add(s);
                        }
                    }
                    s();
                    return r.promise(t);
                }
            });
            var ze = /[+-]?(?:\d*\.|)\d+(?:[eE][+-]?\d+|)/.source;
            var Ve = new RegExp("^(?:([+-])=|)(" + ze + ")([a-z%]*)$", "i");
            var Xe = [ "Top", "Right", "Bottom", "Left" ];
            var Be = function(e, t) {
                // isHiddenWithinTree might be called from jQuery#filter function;
                // in that case, element will be second argument
                e = t || e;
                // Inline style trumps all
                // Otherwise, check computed style
                // Support: Firefox <=43 - 45
                // Disconnected elements can have computed display: none, so first confirm that elem is
                // in the document.
                return "none" === e.style.display || "" === e.style.display && be.contains(e.ownerDocument, e) && "none" === be.css(e, "display");
            };
            var Ye = function(e, t, n, i) {
                var r, o, a = {};
                // Remember the old values, and insert the new ones
                for (o in t) {
                    a[o] = e.style[o];
                    e.style[o] = t[o];
                }
                r = n.apply(e, i || []);
                // Revert the old values
                for (o in t) e.style[o] = a[o];
                return r;
            };
            var Qe = {};
            be.fn.extend({
                show: function() {
                    return w(this, !0);
                },
                hide: function() {
                    return w(this);
                },
                toggle: function(e) {
                    if ("boolean" === typeof e) return e ? this.show() : this.hide();
                    return this.each(function() {
                        if (Be(this)) be(this).show(); else be(this).hide();
                    });
                }
            });
            var Ue = /^(?:checkbox|radio)$/i;
            var Ge = /<([a-z][^\/\0>\x20\t\r\n\f]+)/i;
            var Ze = /^$|\/(?:java|ecma)script/i;
            // We have to close these tags to support XHTML (#13200)
            var Je = {
                // Support: IE <=9 only
                option: [ 1, "<select multiple='multiple'>", "</select>" ],
                // XHTML parsers do not magically insert elements in the
                // same way that tag soup parsers do. So we cannot shorten
                // this by omitting <tbody> or other required elements.
                thead: [ 1, "<table>", "</table>" ],
                col: [ 2, "<table><colgroup>", "</colgroup></table>" ],
                tr: [ 2, "<table><tbody>", "</tbody></table>" ],
                td: [ 3, "<table><tbody><tr>", "</tr></tbody></table>" ],
                _default: [ 0, "", "" ]
            };
            // Support: IE <=9 only
            Je.optgroup = Je.option;
            Je.tbody = Je.tfoot = Je.colgroup = Je.caption = Je.thead;
            Je.th = Je.td;
            var Ke = /<|&#?\w+;/;
            !function() {
                var e = ae.createDocumentFragment(), t = e.appendChild(ae.createElement("div")), n = ae.createElement("input");
                // Support: Android 4.0 - 4.3 only
                // Check state lost if the name is set (#11217)
                // Support: Windows Web Apps (WWA)
                // `name` and `type` must use .setAttribute for WWA (#14901)
                n.setAttribute("type", "radio");
                n.setAttribute("checked", "checked");
                n.setAttribute("name", "t");
                t.appendChild(n);
                // Support: Android <=4.1 only
                // Older WebKit doesn't clone checked state correctly in fragments
                me.checkClone = t.cloneNode(!0).cloneNode(!0).lastChild.checked;
                // Support: IE <=11 only
                // Make sure textarea (and checkbox) defaultValue is properly cloned
                t.innerHTML = "<textarea>x</textarea>";
                me.noCloneChecked = !!t.cloneNode(!0).lastChild.defaultValue;
            }();
            var et = ae.documentElement;
            var tt = /^key/, nt = /^(?:mouse|pointer|contextmenu|drag|drop)|click/, it = /^([^.]*)(?:\.(.+)|)/;
            /*
 * Helper functions for managing events -- not part of the public interface.
 * Props to Dean Edwards' addEvent library for many of the ideas.
 */
            be.event = {
                global: {},
                add: function(e, t, n, i, r) {
                    var o, a, s, l, u, c, f, d, p, h, v, g = Fe.get(e);
                    // Don't attach events to noData or text/comment nodes (but allow plain objects)
                    if (!g) return;
                    // Caller can pass in an object of custom data in lieu of the handler
                    if (n.handler) {
                        o = n;
                        n = o.handler;
                        r = o.selector;
                    }
                    // Ensure that invalid selectors throw exceptions at attach time
                    // Evaluate against documentElement in case elem is a non-element node (e.g., document)
                    if (r) be.find.matchesSelector(et, r);
                    // Make sure that the handler has a unique ID, used to find/remove it later
                    if (!n.guid) n.guid = be.guid++;
                    // Init the element's event structure and main handler, if this is the first
                    if (!(l = g.events)) l = g.events = {};
                    if (!(a = g.handle)) a = g.handle = function(t) {
                        // Discard the second event of a jQuery.event.trigger() and
                        // when an event is called after a page has unloaded
                        return "undefined" !== typeof be && be.event.triggered !== t.type ? be.event.dispatch.apply(e, arguments) : undefined;
                    };
                    // Handle multiple events separated by a space
                    t = (t || "").match(Me) || [ "" ];
                    u = t.length;
                    for (;u--; ) {
                        s = it.exec(t[u]) || [];
                        p = v = s[1];
                        h = (s[2] || "").split(".").sort();
                        // There *must* be a type, no attaching namespace-only handlers
                        if (!p) continue;
                        // If event changes its type, use the special event handlers for the changed type
                        f = be.event.special[p] || {};
                        // If selector defined, determine special event api type, otherwise given type
                        p = (r ? f.delegateType : f.bindType) || p;
                        // Update special based on newly reset type
                        f = be.event.special[p] || {};
                        // handleObj is passed to all event handlers
                        c = be.extend({
                            type: p,
                            origType: v,
                            data: i,
                            handler: n,
                            guid: n.guid,
                            selector: r,
                            needsContext: r && be.expr.match.needsContext.test(r),
                            namespace: h.join(".")
                        }, o);
                        // Init the event handler queue if we're the first
                        if (!(d = l[p])) {
                            d = l[p] = [];
                            d.delegateCount = 0;
                            // Only use addEventListener if the special events handler returns false
                            if (!f.setup || !1 === f.setup.call(e, i, h, a)) if (e.addEventListener) e.addEventListener(p, a);
                        }
                        if (f.add) {
                            f.add.call(e, c);
                            if (!c.handler.guid) c.handler.guid = n.guid;
                        }
                        // Add to the element's handler list, delegates in front
                        if (r) d.splice(d.delegateCount++, 0, c); else d.push(c);
                        // Keep track of which events have ever been used, for event optimization
                        be.event.global[p] = !0;
                    }
                },
                // Detach an event or set of events from an element
                remove: function(e, t, n, i, r) {
                    var o, a, s, l, u, c, f, d, p, h, v, g = Fe.hasData(e) && Fe.get(e);
                    if (!g || !(l = g.events)) return;
                    // Once for each type.namespace in types; type may be omitted
                    t = (t || "").match(Me) || [ "" ];
                    u = t.length;
                    for (;u--; ) {
                        s = it.exec(t[u]) || [];
                        p = v = s[1];
                        h = (s[2] || "").split(".").sort();
                        // Unbind all events (on this namespace, if provided) for the element
                        if (!p) {
                            for (p in l) be.event.remove(e, p + t[u], n, i, !0);
                            continue;
                        }
                        f = be.event.special[p] || {};
                        p = (i ? f.delegateType : f.bindType) || p;
                        d = l[p] || [];
                        s = s[2] && new RegExp("(^|\\.)" + h.join("\\.(?:.*\\.|)") + "(\\.|$)");
                        // Remove matching events
                        a = o = d.length;
                        for (;o--; ) {
                            c = d[o];
                            if ((r || v === c.origType) && (!n || n.guid === c.guid) && (!s || s.test(c.namespace)) && (!i || i === c.selector || "**" === i && c.selector)) {
                                d.splice(o, 1);
                                if (c.selector) d.delegateCount--;
                                if (f.remove) f.remove.call(e, c);
                            }
                        }
                        // Remove generic event handler if we removed something and no more handlers exist
                        // (avoids potential for endless recursion during removal of special event handlers)
                        if (a && !d.length) {
                            if (!f.teardown || !1 === f.teardown.call(e, h, g.handle)) be.removeEvent(e, p, g.handle);
                            delete l[p];
                        }
                    }
                    // Remove data and the expando if it's no longer used
                    if (be.isEmptyObject(l)) Fe.remove(e, "handle events");
                },
                dispatch: function(e) {
                    // Make a writable jQuery.Event from the native event object
                    var t = be.event.fix(e);
                    var n, i, r, o, a, s, l = new Array(arguments.length), u = (Fe.get(this, "events") || {})[t.type] || [], c = be.event.special[t.type] || {};
                    // Use the fix-ed jQuery.Event rather than the (read-only) native event
                    l[0] = t;
                    for (n = 1; n < arguments.length; n++) l[n] = arguments[n];
                    t.delegateTarget = this;
                    // Call the preDispatch hook for the mapped type, and let it bail if desired
                    if (c.preDispatch && !1 === c.preDispatch.call(this, t)) return;
                    // Determine handlers
                    s = be.event.handlers.call(this, t, u);
                    // Run delegates first; they may want to stop propagation beneath us
                    n = 0;
                    for (;(o = s[n++]) && !t.isPropagationStopped(); ) {
                        t.currentTarget = o.elem;
                        i = 0;
                        for (;(a = o.handlers[i++]) && !t.isImmediatePropagationStopped(); ) // Triggered event must either 1) have no namespace, or 2) have namespace(s)
                        // a subset or equal to those in the bound event (both can have no namespace).
                        if (!t.rnamespace || t.rnamespace.test(a.namespace)) {
                            t.handleObj = a;
                            t.data = a.data;
                            r = ((be.event.special[a.origType] || {}).handle || a.handler).apply(o.elem, l);
                            if (r !== undefined) if (!1 === (t.result = r)) {
                                t.preventDefault();
                                t.stopPropagation();
                            }
                        }
                    }
                    // Call the postDispatch hook for the mapped type
                    if (c.postDispatch) c.postDispatch.call(this, t);
                    return t.result;
                },
                handlers: function(e, t) {
                    var n, i, r, o, a, s = [], l = t.delegateCount, u = e.target;
                    // Find delegate handlers
                    if (l && // Support: IE <=9
                    // Black-hole SVG <use> instance trees (trac-13180)
                    u.nodeType && // Support: Firefox <=42
                    // Suppress spec-violating clicks indicating a non-primary pointer button (trac-3861)
                    // https://www.w3.org/TR/DOM-Level-3-Events/#event-type-click
                    // Support: IE 11 only
                    // ...but not arrow key "clicks" of radio inputs, which can have `button` -1 (gh-2343)
                    !("click" === e.type && e.button >= 1)) for (;u !== this; u = u.parentNode || this) // Don't check non-elements (#13208)
                    // Don't process clicks on disabled elements (#6911, #8165, #11382, #11764)
                    if (1 === u.nodeType && ("click" !== e.type || !0 !== u.disabled)) {
                        o = [];
                        a = {};
                        for (n = 0; n < l; n++) {
                            i = t[n];
                            // Don't conflict with Object.prototype properties (#13203)
                            r = i.selector + " ";
                            if (a[r] === undefined) a[r] = i.needsContext ? be(r, this).index(u) > -1 : be.find(r, this, null, [ u ]).length;
                            if (a[r]) o.push(i);
                        }
                        if (o.length) s.push({
                            elem: u,
                            handlers: o
                        });
                    }
                    // Add the remaining (directly-bound) handlers
                    u = this;
                    if (l < t.length) s.push({
                        elem: u,
                        handlers: t.slice(l)
                    });
                    return s;
                },
                addProp: function(e, t) {
                    Object.defineProperty(be.Event.prototype, e, {
                        enumerable: !0,
                        configurable: !0,
                        get: be.isFunction(t) ? function() {
                            if (this.originalEvent) return t(this.originalEvent);
                        } : function() {
                            if (this.originalEvent) return this.originalEvent[e];
                        },
                        set: function(t) {
                            Object.defineProperty(this, e, {
                                enumerable: !0,
                                configurable: !0,
                                writable: !0,
                                value: t
                            });
                        }
                    });
                },
                fix: function(e) {
                    return e[be.expando] ? e : new be.Event(e);
                },
                special: {
                    load: {
                        // Prevent triggered image.load events from bubbling to window.load
                        noBubble: !0
                    },
                    focus: {
                        // Fire native event if possible so blur/focus sequence is correct
                        trigger: function() {
                            if (this !== A() && this.focus) {
                                this.focus();
                                return !1;
                            }
                        },
                        delegateType: "focusin"
                    },
                    blur: {
                        trigger: function() {
                            if (this === A() && this.blur) {
                                this.blur();
                                return !1;
                            }
                        },
                        delegateType: "focusout"
                    },
                    click: {
                        // For checkbox, fire native event so checked state will be right
                        trigger: function() {
                            if ("checkbox" === this.type && this.click && l(this, "input")) {
                                this.click();
                                return !1;
                            }
                        },
                        // For cross-browser consistency, don't fire native .click() on links
                        _default: function(e) {
                            return l(e.target, "a");
                        }
                    },
                    beforeunload: {
                        postDispatch: function(e) {
                            // Support: Firefox 20+
                            // Firefox doesn't alert if the returnValue field is not set.
                            if (e.result !== undefined && e.originalEvent) e.originalEvent.returnValue = e.result;
                        }
                    }
                }
            };
            be.removeEvent = function(e, t, n) {
                // This "if" is needed for plain objects
                if (e.removeEventListener) e.removeEventListener(t, n);
            };
            be.Event = function(e, t) {
                // Allow instantiation without the 'new' keyword
                if (!(this instanceof be.Event)) return new be.Event(e, t);
                // Event object
                if (e && e.type) {
                    this.originalEvent = e;
                    this.type = e.type;
                    // Events bubbling up the document may have been marked as prevented
                    // by a handler lower down the tree; reflect the correct value.
                    this.isDefaultPrevented = e.defaultPrevented || e.defaultPrevented === undefined && // Support: Android <=2.3 only
                    !1 === e.returnValue ? S : E;
                    // Create target properties
                    // Support: Safari <=6 - 7 only
                    // Target should not be a text node (#504, #13143)
                    this.target = e.target && 3 === e.target.nodeType ? e.target.parentNode : e.target;
                    this.currentTarget = e.currentTarget;
                    this.relatedTarget = e.relatedTarget;
                } else this.type = e;
                // Put explicitly provided properties onto the event object
                if (t) be.extend(this, t);
                // Create a timestamp if incoming event doesn't have one
                this.timeStamp = e && e.timeStamp || be.now();
                // Mark it as fixed
                this[be.expando] = !0;
            };
            // jQuery.Event is based on DOM3 Events as specified by the ECMAScript Language Binding
            // https://www.w3.org/TR/2003/WD-DOM-Level-3-Events-20030331/ecma-script-binding.html
            be.Event.prototype = {
                constructor: be.Event,
                isDefaultPrevented: E,
                isPropagationStopped: E,
                isImmediatePropagationStopped: E,
                isSimulated: !1,
                preventDefault: function() {
                    var e = this.originalEvent;
                    this.isDefaultPrevented = S;
                    if (e && !this.isSimulated) e.preventDefault();
                },
                stopPropagation: function() {
                    var e = this.originalEvent;
                    this.isPropagationStopped = S;
                    if (e && !this.isSimulated) e.stopPropagation();
                },
                stopImmediatePropagation: function() {
                    var e = this.originalEvent;
                    this.isImmediatePropagationStopped = S;
                    if (e && !this.isSimulated) e.stopImmediatePropagation();
                    this.stopPropagation();
                }
            };
            // Includes all common event props including KeyEvent and MouseEvent specific props
            be.each({
                altKey: !0,
                bubbles: !0,
                cancelable: !0,
                changedTouches: !0,
                ctrlKey: !0,
                detail: !0,
                eventPhase: !0,
                metaKey: !0,
                pageX: !0,
                pageY: !0,
                shiftKey: !0,
                view: !0,
                char: !0,
                charCode: !0,
                key: !0,
                keyCode: !0,
                button: !0,
                buttons: !0,
                clientX: !0,
                clientY: !0,
                offsetX: !0,
                offsetY: !0,
                pointerId: !0,
                pointerType: !0,
                screenX: !0,
                screenY: !0,
                targetTouches: !0,
                toElement: !0,
                touches: !0,
                which: function(e) {
                    var t = e.button;
                    // Add which for key events
                    if (null == e.which && tt.test(e.type)) return null != e.charCode ? e.charCode : e.keyCode;
                    // Add which for click: 1 === left; 2 === middle; 3 === right
                    if (!e.which && t !== undefined && nt.test(e.type)) {
                        if (1 & t) return 1;
                        if (2 & t) return 3;
                        if (4 & t) return 2;
                        return 0;
                    }
                    return e.which;
                }
            }, be.event.addProp);
            // Create mouseenter/leave events using mouseover/out and event-time checks
            // so that event delegation works in jQuery.
            // Do the same for pointerenter/pointerleave and pointerover/pointerout
            //
            // Support: Safari 7 only
            // Safari sends mouseenter too often; see:
            // https://bugs.chromium.org/p/chromium/issues/detail?id=470258
            // for the description of the bug (it existed in older Chrome versions as well).
            be.each({
                mouseenter: "mouseover",
                mouseleave: "mouseout",
                pointerenter: "pointerover",
                pointerleave: "pointerout"
            }, function(e, t) {
                be.event.special[e] = {
                    delegateType: t,
                    bindType: t,
                    handle: function(e) {
                        var n, i = this, r = e.relatedTarget, o = e.handleObj;
                        // For mouseenter/leave call the handler if related is outside the target.
                        // NB: No relatedTarget if the mouse left/entered the browser window
                        if (!r || r !== i && !be.contains(i, r)) {
                            e.type = o.origType;
                            n = o.handler.apply(this, arguments);
                            e.type = t;
                        }
                        return n;
                    }
                };
            });
            be.fn.extend({
                on: function(e, t, n, i) {
                    return P(this, e, t, n, i);
                },
                one: function(e, t, n, i) {
                    return P(this, e, t, n, i, 1);
                },
                off: function(e, t, n) {
                    var i, r;
                    if (e && e.preventDefault && e.handleObj) {
                        // ( event )  dispatched jQuery.Event
                        i = e.handleObj;
                        be(e.delegateTarget).off(i.namespace ? i.origType + "." + i.namespace : i.origType, i.selector, i.handler);
                        return this;
                    }
                    if ("object" === typeof e) {
                        // ( types-object [, selector] )
                        for (r in e) this.off(r, t, e[r]);
                        return this;
                    }
                    if (!1 === t || "function" === typeof t) {
                        // ( types [, fn] )
                        n = t;
                        t = undefined;
                    }
                    if (!1 === n) n = E;
                    return this.each(function() {
                        be.event.remove(this, e, n, t);
                    });
                }
            });
            var /* eslint-disable max-len */
            // See https://github.com/eslint/eslint/issues/3229
            rt = /<(?!area|br|col|embed|hr|img|input|link|meta|param)(([a-z][^\/\0>\x20\t\r\n\f]*)[^>]*)\/>/gi, /* eslint-enable */
            // Support: IE <=10 - 11, Edge 12 - 13
            // In IE/Edge using regex groups here causes severe slowdowns.
            // See https://connect.microsoft.com/IE/feedback/details/1736512/
            ot = /<script|<style|<link/i, // checked="checked" or checked
            at = /checked\s*(?:[^=]|=\s*.checked.)/i, st = /^true\/(.*)/, lt = /^\s*<!(?:\[CDATA\[|--)|(?:\]\]|--)>\s*$/g;
            be.extend({
                htmlPrefilter: function(e) {
                    return e.replace(rt, "<$1></$2>");
                },
                clone: function(e, t, n) {
                    var i, r, o, a, s = e.cloneNode(!0), l = be.contains(e.ownerDocument, e);
                    // Fix IE cloning issues
                    if (!me.noCloneChecked && (1 === e.nodeType || 11 === e.nodeType) && !be.isXMLDoc(e)) {
                        // We eschew Sizzle here for performance reasons: https://jsperf.com/getall-vs-sizzle/2
                        a = T(s);
                        o = T(e);
                        for (i = 0, r = o.length; i < r; i++) j(o[i], a[i]);
                    }
                    // Copy the events from the original to the clone
                    if (t) if (n) {
                        o = o || T(e);
                        a = a || T(s);
                        for (i = 0, r = o.length; i < r; i++) q(o[i], a[i]);
                    } else q(e, s);
                    // Preserve script evaluation history
                    a = T(s, "script");
                    if (a.length > 0) C(a, !l && T(e, "script"));
                    // Return the cloned set
                    return s;
                },
                cleanData: function(e) {
                    var t, n, i, r = be.event.special, o = 0;
                    for (;(n = e[o]) !== undefined; o++) if (_e(n)) {
                        if (t = n[Fe.expando]) {
                            if (t.events) for (i in t.events) if (r[i]) be.event.remove(n, i); else be.removeEvent(n, i, t.handle);
                            // Support: Chrome <=35 - 45+
                            // Assign undefined instead of using delete, see Data#remove
                            n[Fe.expando] = undefined;
                        }
                        if (n[Re.expando]) // Support: Chrome <=35 - 45+
                        // Assign undefined instead of using delete, see Data#remove
                        n[Re.expando] = undefined;
                    }
                }
            });
            be.fn.extend({
                detach: function(e) {
                    return L(this, e, !0);
                },
                remove: function(e) {
                    return L(this, e);
                },
                text: function(e) {
                    return He(this, function(e) {
                        return e === undefined ? be.text(this) : this.empty().each(function() {
                            if (1 === this.nodeType || 11 === this.nodeType || 9 === this.nodeType) this.textContent = e;
                        });
                    }, null, e, arguments.length);
                },
                append: function() {
                    return M(this, arguments, function(e) {
                        if (1 === this.nodeType || 11 === this.nodeType || 9 === this.nodeType) {
                            D(this, e).appendChild(e);
                        }
                    });
                },
                prepend: function() {
                    return M(this, arguments, function(e) {
                        if (1 === this.nodeType || 11 === this.nodeType || 9 === this.nodeType) {
                            var t = D(this, e);
                            t.insertBefore(e, t.firstChild);
                        }
                    });
                },
                before: function() {
                    return M(this, arguments, function(e) {
                        if (this.parentNode) this.parentNode.insertBefore(e, this);
                    });
                },
                after: function() {
                    return M(this, arguments, function(e) {
                        if (this.parentNode) this.parentNode.insertBefore(e, this.nextSibling);
                    });
                },
                empty: function() {
                    var e, t = 0;
                    for (;null != (e = this[t]); t++) if (1 === e.nodeType) {
                        // Prevent memory leaks
                        be.cleanData(T(e, !1));
                        // Remove any remaining nodes
                        e.textContent = "";
                    }
                    return this;
                },
                clone: function(e, t) {
                    e = null == e ? !1 : e;
                    t = null == t ? e : t;
                    return this.map(function() {
                        return be.clone(this, e, t);
                    });
                },
                html: function(e) {
                    return He(this, function(e) {
                        var t = this[0] || {}, n = 0, i = this.length;
                        if (e === undefined && 1 === t.nodeType) return t.innerHTML;
                        // See if we can take a shortcut and just use innerHTML
                        if ("string" === typeof e && !ot.test(e) && !Je[(Ge.exec(e) || [ "", "" ])[1].toLowerCase()]) {
                            e = be.htmlPrefilter(e);
                            try {
                                for (;n < i; n++) {
                                    t = this[n] || {};
                                    // Remove element nodes and prevent memory leaks
                                    if (1 === t.nodeType) {
                                        be.cleanData(T(t, !1));
                                        t.innerHTML = e;
                                    }
                                }
                                t = 0;
                            } catch (r) {}
                        }
                        if (t) this.empty().append(e);
                    }, null, e, arguments.length);
                },
                replaceWith: function() {
                    var e = [];
                    // Make the changes, replacing each non-ignored context element with the new content
                    return M(this, arguments, function(t) {
                        var n = this.parentNode;
                        if (be.inArray(this, e) < 0) {
                            be.cleanData(T(this));
                            if (n) n.replaceChild(t, this);
                        }
                    }, e);
                }
            });
            be.each({
                appendTo: "append",
                prependTo: "prepend",
                insertBefore: "before",
                insertAfter: "after",
                replaceAll: "replaceWith"
            }, function(e, t) {
                be.fn[e] = function(e) {
                    var n, i = [], r = be(e), o = r.length - 1, a = 0;
                    for (;a <= o; a++) {
                        n = a === o ? this : this.clone(!0);
                        be(r[a])[t](n);
                        // Support: Android <=4.0 only, PhantomJS 1 only
                        // .get() because push.apply(_, arraylike) throws on ancient WebKit
                        ce.apply(i, n.get());
                    }
                    return this.pushStack(i);
                };
            });
            var ut = /^margin/;
            var ct = new RegExp("^(" + ze + ")(?!px)[a-z%]+$", "i");
            var ft = function(e) {
                // Support: IE <=11 only, Firefox <=30 (#15098, #14150)
                // IE throws on elements created in popups
                // FF meanwhile throws on frame elements through "defaultView.getComputedStyle"
                var t = e.ownerDocument.defaultView;
                if (!t || !t.opener) t = n;
                return t.getComputedStyle(e);
            };
            !function() {
                // Executing both pixelPosition & boxSizingReliable tests require only one layout
                // so they're executed at the same time to save the second computation.
                function e() {
                    // This is a singleton, we need to execute it only once
                    if (!s) return;
                    s.style.cssText = "box-sizing:border-box;" + "position:relative;display:block;" + "margin:auto;border:1px;padding:1px;" + "top:1%;width:50%";
                    s.innerHTML = "";
                    et.appendChild(a);
                    var e = n.getComputedStyle(s);
                    t = "1%" !== e.top;
                    // Support: Android 4.0 - 4.3 only, Firefox <=3 - 44
                    o = "2px" === e.marginLeft;
                    i = "4px" === e.width;
                    // Support: Android 4.0 - 4.3 only
                    // Some styles come back with percentage values, even though they shouldn't
                    s.style.marginRight = "50%";
                    r = "4px" === e.marginRight;
                    et.removeChild(a);
                    // Nullify the div so it wouldn't be stored in the memory and
                    // it will also be a sign that checks already performed
                    s = null;
                }
                var t, i, r, o, a = ae.createElement("div"), s = ae.createElement("div");
                // Finish early in limited (non-browser) environments
                if (!s.style) return;
                // Support: IE <=9 - 11 only
                // Style of cloned element affects source element cloned (#8908)
                s.style.backgroundClip = "content-box";
                s.cloneNode(!0).style.backgroundClip = "";
                me.clearCloneStyle = "content-box" === s.style.backgroundClip;
                a.style.cssText = "border:0;width:8px;height:0;top:0;left:-9999px;" + "padding:0;margin-top:1px;position:absolute";
                a.appendChild(s);
                be.extend(me, {
                    pixelPosition: function() {
                        e();
                        return t;
                    },
                    boxSizingReliable: function() {
                        e();
                        return i;
                    },
                    pixelMarginRight: function() {
                        e();
                        return r;
                    },
                    reliableMarginLeft: function() {
                        e();
                        return o;
                    }
                });
            }();
            var // Swappable if display is none or starts with table
            // except "table", "table-cell", or "table-caption"
            // See here for display values: https://developer.mozilla.org/en-US/docs/CSS/display
            dt = /^(none|table(?!-c[ea]).+)/, pt = /^--/, ht = {
                position: "absolute",
                visibility: "hidden",
                display: "block"
            }, vt = {
                letterSpacing: "0",
                fontWeight: "400"
            }, gt = [ "Webkit", "Moz", "ms" ], mt = ae.createElement("div").style;
            be.extend({
                // Add in style property hooks for overriding the default
                // behavior of getting and setting a style property
                cssHooks: {
                    opacity: {
                        get: function(e, t) {
                            if (t) {
                                // We should always get a number back from opacity
                                var n = I(e, "opacity");
                                return "" === n ? "1" : n;
                            }
                        }
                    }
                },
                // Don't automatically add "px" to these possibly-unitless properties
                cssNumber: {
                    animationIterationCount: !0,
                    columnCount: !0,
                    fillOpacity: !0,
                    flexGrow: !0,
                    flexShrink: !0,
                    fontWeight: !0,
                    lineHeight: !0,
                    opacity: !0,
                    order: !0,
                    orphans: !0,
                    widows: !0,
                    zIndex: !0,
                    zoom: !0
                },
                // Add in properties whose names you wish to fix before
                // setting or getting the value
                cssProps: {
                    float: "cssFloat"
                },
                // Get and set the style property on a DOM Node
                style: function(e, t, n, i) {
                    // Don't set styles on text and comment nodes
                    if (!e || 3 === e.nodeType || 8 === e.nodeType || !e.style) return;
                    // Make sure that we're working with the right name
                    var r, o, a, s = be.camelCase(t), l = pt.test(t), u = e.style;
                    // Make sure that we're working with the right name. We don't
                    // want to query the value if it is a CSS custom property
                    // since they are user-defined.
                    if (!l) t = F(s);
                    // Gets hook for the prefixed version, then unprefixed version
                    a = be.cssHooks[t] || be.cssHooks[s];
                    // Check if we're setting a value
                    if (n !== undefined) {
                        o = typeof n;
                        // Convert "+=" or "-=" to relative numbers (#7345)
                        if ("string" === o && (r = Ve.exec(n)) && r[1]) {
                            n = b(e, t, r);
                            // Fixes bug #9237
                            o = "number";
                        }
                        // Make sure that null and NaN values aren't set (#7116)
                        if (null == n || n !== n) return;
                        // If a number was passed in, add the unit (except for certain CSS properties)
                        if ("number" === o) n += r && r[3] || (be.cssNumber[s] ? "" : "px");
                        // background-* props affect original clone's values
                        if (!me.clearCloneStyle && "" === n && 0 === t.indexOf("background")) u[t] = "inherit";
                        // If a hook was provided, use that value, otherwise just set the specified value
                        if (!a || !("set" in a) || (n = a.set(e, n, i)) !== undefined) if (l) u.setProperty(t, n); else u[t] = n;
                    } else {
                        // If a hook was provided get the non-computed value from there
                        if (a && "get" in a && (r = a.get(e, !1, i)) !== undefined) return r;
                        // Otherwise just get the value from the style object
                        return u[t];
                    }
                },
                css: function(e, t, n, i) {
                    var r, o, a, s = be.camelCase(t);
                    // Make sure that we're working with the right name. We don't
                    // want to modify the value if it is a CSS custom property
                    // since they are user-defined.
                    if (!pt.test(t)) t = F(s);
                    // Try prefixed name followed by the unprefixed name
                    a = be.cssHooks[t] || be.cssHooks[s];
                    // If a hook was provided get the computed value from there
                    if (a && "get" in a) r = a.get(e, !0, n);
                    // Otherwise, if a way to get the computed value exists, use that
                    if (r === undefined) r = I(e, t, i);
                    // Convert "normal" to computed value
                    if ("normal" === r && t in vt) r = vt[t];
                    // Make numeric if forced or a qualifier was provided and val looks numeric
                    if ("" === n || n) {
                        o = parseFloat(r);
                        return !0 === n || isFinite(o) ? o || 0 : r;
                    }
                    return r;
                }
            });
            be.each([ "height", "width" ], function(e, t) {
                be.cssHooks[t] = {
                    get: function(e, n, i) {
                        if (n) // Certain elements can have dimension info if we invisibly show them
                        // but it must have a current display style that would benefit
                        // Support: Safari 8+
                        // Table columns in Safari have non-zero offsetWidth & zero
                        // getBoundingClientRect().width unless display is changed.
                        // Support: IE <=11 only
                        // Running getBoundingClientRect on a disconnected node
                        // in IE throws an error.
                        return dt.test(be.css(e, "display")) && (!e.getClientRects().length || !e.getBoundingClientRect().width) ? Ye(e, ht, function() {
                            return $(e, t, i);
                        }) : $(e, t, i);
                    },
                    set: function(e, n, i) {
                        var r, o = i && ft(e), a = i && W(e, t, i, "border-box" === be.css(e, "boxSizing", !1, o), o);
                        // Convert to pixels if value adjustment is needed
                        if (a && (r = Ve.exec(n)) && "px" !== (r[3] || "px")) {
                            e.style[t] = n;
                            n = be.css(e, t);
                        }
                        return R(e, n, a);
                    }
                };
            });
            be.cssHooks.marginLeft = H(me.reliableMarginLeft, function(e, t) {
                if (t) return (parseFloat(I(e, "marginLeft")) || e.getBoundingClientRect().left - Ye(e, {
                    marginLeft: 0
                }, function() {
                    return e.getBoundingClientRect().left;
                })) + "px";
            });
            // These hooks are used by animate to expand properties
            be.each({
                margin: "",
                padding: "",
                border: "Width"
            }, function(e, t) {
                be.cssHooks[e + t] = {
                    expand: function(n) {
                        var i = 0, r = {}, // Assumes a single number if not a string
                        o = "string" === typeof n ? n.split(" ") : [ n ];
                        for (;i < 4; i++) r[e + Xe[i] + t] = o[i] || o[i - 2] || o[0];
                        return r;
                    }
                };
                if (!ut.test(e)) be.cssHooks[e + t].set = R;
            });
            be.fn.extend({
                css: function(e, t) {
                    return He(this, function(e, t, n) {
                        var i, r, o = {}, a = 0;
                        if (Array.isArray(t)) {
                            i = ft(e);
                            r = t.length;
                            for (;a < r; a++) o[t[a]] = be.css(e, t[a], !1, i);
                            return o;
                        }
                        return n !== undefined ? be.style(e, t, n) : be.css(e, t);
                    }, e, t, arguments.length > 1);
                }
            });
            be.Tween = z;
            z.prototype = {
                constructor: z,
                init: function(e, t, n, i, r, o) {
                    this.elem = e;
                    this.prop = n;
                    this.easing = r || be.easing._default;
                    this.options = t;
                    this.start = this.now = this.cur();
                    this.end = i;
                    this.unit = o || (be.cssNumber[n] ? "" : "px");
                },
                cur: function() {
                    var e = z.propHooks[this.prop];
                    return e && e.get ? e.get(this) : z.propHooks._default.get(this);
                },
                run: function(e) {
                    var t, n = z.propHooks[this.prop];
                    if (this.options.duration) this.pos = t = be.easing[this.easing](e, this.options.duration * e, 0, 1, this.options.duration); else this.pos = t = e;
                    this.now = (this.end - this.start) * t + this.start;
                    if (this.options.step) this.options.step.call(this.elem, this.now, this);
                    if (n && n.set) n.set(this); else z.propHooks._default.set(this);
                    return this;
                }
            };
            z.prototype.init.prototype = z.prototype;
            z.propHooks = {
                _default: {
                    get: function(e) {
                        var t;
                        // Use a property on the element directly when it is not a DOM element,
                        // or when there is no matching style property that exists.
                        if (1 !== e.elem.nodeType || null != e.elem[e.prop] && null == e.elem.style[e.prop]) return e.elem[e.prop];
                        // Passing an empty string as a 3rd parameter to .css will automatically
                        // attempt a parseFloat and fallback to a string if the parse fails.
                        // Simple values such as "10px" are parsed to Float;
                        // complex values such as "rotate(1rad)" are returned as-is.
                        t = be.css(e.elem, e.prop, "");
                        // Empty strings, null, undefined and "auto" are converted to 0.
                        return !t || "auto" === t ? 0 : t;
                    },
                    set: function(e) {
                        // Use step hook for back compat.
                        // Use cssHook if its there.
                        // Use .style if available and use plain properties where available.
                        if (be.fx.step[e.prop]) be.fx.step[e.prop](e); else if (1 === e.elem.nodeType && (null != e.elem.style[be.cssProps[e.prop]] || be.cssHooks[e.prop])) be.style(e.elem, e.prop, e.now + e.unit); else e.elem[e.prop] = e.now;
                    }
                }
            };
            // Support: IE <=9 only
            // Panic based approach to setting things on disconnected nodes
            z.propHooks.scrollTop = z.propHooks.scrollLeft = {
                set: function(e) {
                    if (e.elem.nodeType && e.elem.parentNode) e.elem[e.prop] = e.now;
                }
            };
            be.easing = {
                linear: function(e) {
                    return e;
                },
                swing: function(e) {
                    return .5 - Math.cos(e * Math.PI) / 2;
                },
                _default: "swing"
            };
            be.fx = z.prototype.init;
            // Back compat <1.8 extension point
            be.fx.step = {};
            var yt, bt, xt = /^(?:toggle|show|hide)$/, wt = /queueHooks$/;
            be.Animation = be.extend(G, {
                tweeners: {
                    "*": [ function(e, t) {
                        var n = this.createTween(e, t);
                        b(n.elem, e, Ve.exec(t), n);
                        return n;
                    } ]
                },
                tweener: function(e, t) {
                    if (be.isFunction(e)) {
                        t = e;
                        e = [ "*" ];
                    } else e = e.match(Me);
                    var n, i = 0, r = e.length;
                    for (;i < r; i++) {
                        n = e[i];
                        G.tweeners[n] = G.tweeners[n] || [];
                        G.tweeners[n].unshift(t);
                    }
                },
                prefilters: [ Q ],
                prefilter: function(e, t) {
                    if (t) G.prefilters.unshift(e); else G.prefilters.push(e);
                }
            });
            be.speed = function(e, t, n) {
                var i = e && "object" === typeof e ? be.extend({}, e) : {
                    complete: n || !n && t || be.isFunction(e) && e,
                    duration: e,
                    easing: n && t || t && !be.isFunction(t) && t
                };
                // Go to the end state if fx are off
                if (be.fx.off) i.duration = 0; else if ("number" !== typeof i.duration) if (i.duration in be.fx.speeds) i.duration = be.fx.speeds[i.duration]; else i.duration = be.fx.speeds._default;
                // Normalize opt.queue - true/undefined/null -> "fx"
                if (null == i.queue || !0 === i.queue) i.queue = "fx";
                // Queueing
                i.old = i.complete;
                i.complete = function() {
                    if (be.isFunction(i.old)) i.old.call(this);
                    if (i.queue) be.dequeue(this, i.queue);
                };
                return i;
            };
            be.fn.extend({
                fadeTo: function(e, t, n, i) {
                    // Show any hidden elements after setting opacity to 0
                    return this.filter(Be).css("opacity", 0).show().end().animate({
                        opacity: t
                    }, e, n, i);
                },
                animate: function(e, t, n, i) {
                    var r = be.isEmptyObject(e), o = be.speed(t, n, i), a = function() {
                        // Operate on a copy of prop so per-property easing won't be lost
                        var t = G(this, be.extend({}, e), o);
                        // Empty animations, or finishing resolves immediately
                        if (r || Fe.get(this, "finish")) t.stop(!0);
                    };
                    a.finish = a;
                    return r || !1 === o.queue ? this.each(a) : this.queue(o.queue, a);
                },
                stop: function(e, t, n) {
                    var i = function(e) {
                        var t = e.stop;
                        delete e.stop;
                        t(n);
                    };
                    if ("string" !== typeof e) {
                        n = t;
                        t = e;
                        e = undefined;
                    }
                    if (t && !1 !== e) this.queue(e || "fx", []);
                    return this.each(function() {
                        var t = !0, r = null != e && e + "queueHooks", o = be.timers, a = Fe.get(this);
                        if (r) {
                            if (a[r] && a[r].stop) i(a[r]);
                        } else for (r in a) if (a[r] && a[r].stop && wt.test(r)) i(a[r]);
                        for (r = o.length; r--; ) if (o[r].elem === this && (null == e || o[r].queue === e)) {
                            o[r].anim.stop(n);
                            t = !1;
                            o.splice(r, 1);
                        }
                        // Start the next in the queue if the last step wasn't forced.
                        // Timers currently will call their complete callbacks, which
                        // will dequeue but only if they were gotoEnd.
                        if (t || !n) be.dequeue(this, e);
                    });
                },
                finish: function(e) {
                    if (!1 !== e) e = e || "fx";
                    return this.each(function() {
                        var t, n = Fe.get(this), i = n[e + "queue"], r = n[e + "queueHooks"], o = be.timers, a = i ? i.length : 0;
                        // Enable finishing flag on private data
                        n.finish = !0;
                        // Empty the queue first
                        be.queue(this, e, []);
                        if (r && r.stop) r.stop.call(this, !0);
                        // Look for any active animations, and finish them
                        for (t = o.length; t--; ) if (o[t].elem === this && o[t].queue === e) {
                            o[t].anim.stop(!0);
                            o.splice(t, 1);
                        }
                        // Look for any animations in the old queue and finish them
                        for (t = 0; t < a; t++) if (i[t] && i[t].finish) i[t].finish.call(this);
                        // Turn off finishing flag
                        delete n.finish;
                    });
                }
            });
            be.each([ "toggle", "show", "hide" ], function(e, t) {
                var n = be.fn[t];
                be.fn[t] = function(e, i, r) {
                    return null == e || "boolean" === typeof e ? n.apply(this, arguments) : this.animate(B(t, !0), e, i, r);
                };
            });
            // Generate shortcuts for custom animations
            be.each({
                slideDown: B("show"),
                slideUp: B("hide"),
                slideToggle: B("toggle"),
                fadeIn: {
                    opacity: "show"
                },
                fadeOut: {
                    opacity: "hide"
                },
                fadeToggle: {
                    opacity: "toggle"
                }
            }, function(e, t) {
                be.fn[e] = function(e, n, i) {
                    return this.animate(t, e, n, i);
                };
            });
            be.timers = [];
            be.fx.tick = function() {
                var e, t = 0, n = be.timers;
                yt = be.now();
                for (;t < n.length; t++) {
                    e = n[t];
                    // Run the timer and safely remove it when done (allowing for external removal)
                    if (!e() && n[t] === e) n.splice(t--, 1);
                }
                if (!n.length) be.fx.stop();
                yt = undefined;
            };
            be.fx.timer = function(e) {
                be.timers.push(e);
                be.fx.start();
            };
            be.fx.interval = 13;
            be.fx.start = function() {
                if (bt) return;
                bt = !0;
                V();
            };
            be.fx.stop = function() {
                bt = null;
            };
            be.fx.speeds = {
                slow: 600,
                fast: 200,
                // Default speed
                _default: 400
            };
            // Based off of the plugin by Clint Helfers, with permission.
            // https://web.archive.org/web/20100324014747/http://blindsignals.com/index.php/2009/07/jquery-delay/
            be.fn.delay = function(e, t) {
                e = be.fx ? be.fx.speeds[e] || e : e;
                t = t || "fx";
                return this.queue(t, function(t, i) {
                    var r = n.setTimeout(t, e);
                    i.stop = function() {
                        n.clearTimeout(r);
                    };
                });
            };
            !function() {
                var e = ae.createElement("input"), t = ae.createElement("select"), n = t.appendChild(ae.createElement("option"));
                e.type = "checkbox";
                // Support: Android <=4.3 only
                // Default value for a checkbox should be "on"
                me.checkOn = "" !== e.value;
                // Support: IE <=11 only
                // Must access selectedIndex to make default options select
                me.optSelected = n.selected;
                // Support: IE <=11 only
                // An input loses its value after becoming a radio
                e = ae.createElement("input");
                e.value = "t";
                e.type = "radio";
                me.radioValue = "t" === e.value;
            }();
            var Tt, Ct = be.expr.attrHandle;
            be.fn.extend({
                attr: function(e, t) {
                    return He(this, be.attr, e, t, arguments.length > 1);
                },
                removeAttr: function(e) {
                    return this.each(function() {
                        be.removeAttr(this, e);
                    });
                }
            });
            be.extend({
                attr: function(e, t, n) {
                    var i, r, o = e.nodeType;
                    // Don't get/set attributes on text, comment and attribute nodes
                    if (3 === o || 8 === o || 2 === o) return;
                    // Fallback to prop when attributes are not supported
                    if ("undefined" === typeof e.getAttribute) return be.prop(e, t, n);
                    // Attribute hooks are determined by the lowercase version
                    // Grab necessary hook if one is defined
                    if (1 !== o || !be.isXMLDoc(e)) r = be.attrHooks[t.toLowerCase()] || (be.expr.match.bool.test(t) ? Tt : undefined);
                    if (n !== undefined) {
                        if (null === n) {
                            be.removeAttr(e, t);
                            return;
                        }
                        if (r && "set" in r && (i = r.set(e, n, t)) !== undefined) return i;
                        e.setAttribute(t, n + "");
                        return n;
                    }
                    if (r && "get" in r && null !== (i = r.get(e, t))) return i;
                    i = be.find.attr(e, t);
                    // Non-existent attributes return null, we normalize to undefined
                    return null == i ? undefined : i;
                },
                attrHooks: {
                    type: {
                        set: function(e, t) {
                            if (!me.radioValue && "radio" === t && l(e, "input")) {
                                var n = e.value;
                                e.setAttribute("type", t);
                                if (n) e.value = n;
                                return t;
                            }
                        }
                    }
                },
                removeAttr: function(e, t) {
                    var n, i = 0, // Attribute names can contain non-HTML whitespace characters
                    // https://html.spec.whatwg.org/multipage/syntax.html#attributes-2
                    r = t && t.match(Me);
                    if (r && 1 === e.nodeType) for (;n = r[i++]; ) e.removeAttribute(n);
                }
            });
            // Hooks for boolean attributes
            Tt = {
                set: function(e, t, n) {
                    if (!1 === t) // Remove boolean attributes when set to false
                    be.removeAttr(e, n); else e.setAttribute(n, n);
                    return n;
                }
            };
            be.each(be.expr.match.bool.source.match(/\w+/g), function(e, t) {
                var n = Ct[t] || be.find.attr;
                Ct[t] = function(e, t, i) {
                    var r, o, a = t.toLowerCase();
                    if (!i) {
                        // Avoid an infinite loop by temporarily removing this function from the getter
                        o = Ct[a];
                        Ct[a] = r;
                        r = null != n(e, t, i) ? a : null;
                        Ct[a] = o;
                    }
                    return r;
                };
            });
            var kt = /^(?:input|select|textarea|button)$/i, St = /^(?:a|area)$/i;
            be.fn.extend({
                prop: function(e, t) {
                    return He(this, be.prop, e, t, arguments.length > 1);
                },
                removeProp: function(e) {
                    return this.each(function() {
                        delete this[be.propFix[e] || e];
                    });
                }
            });
            be.extend({
                prop: function(e, t, n) {
                    var i, r, o = e.nodeType;
                    // Don't get/set properties on text, comment and attribute nodes
                    if (3 === o || 8 === o || 2 === o) return;
                    if (1 !== o || !be.isXMLDoc(e)) {
                        // Fix name and attach hooks
                        t = be.propFix[t] || t;
                        r = be.propHooks[t];
                    }
                    if (n !== undefined) {
                        if (r && "set" in r && (i = r.set(e, n, t)) !== undefined) return i;
                        return e[t] = n;
                    }
                    if (r && "get" in r && null !== (i = r.get(e, t))) return i;
                    return e[t];
                },
                propHooks: {
                    tabIndex: {
                        get: function(e) {
                            // Support: IE <=9 - 11 only
                            // elem.tabIndex doesn't always return the
                            // correct value when it hasn't been explicitly set
                            // https://web.archive.org/web/20141116233347/http://fluidproject.org/blog/2008/01/09/getting-setting-and-removing-tabindex-values-with-javascript/
                            // Use proper attribute retrieval(#12072)
                            var t = be.find.attr(e, "tabindex");
                            if (t) return parseInt(t, 10);
                            if (kt.test(e.nodeName) || St.test(e.nodeName) && e.href) return 0;
                            return -1;
                        }
                    }
                },
                propFix: {
                    for: "htmlFor",
                    class: "className"
                }
            });
            // Support: IE <=11 only
            // Accessing the selectedIndex property
            // forces the browser to respect setting selected
            // on the option
            // The getter ensures a default option is selected
            // when in an optgroup
            // eslint rule "no-unused-expressions" is disabled for this code
            // since it considers such accessions noop
            if (!me.optSelected) be.propHooks.selected = {
                get: function(e) {
                    /* eslint no-unused-expressions: "off" */
                    var t = e.parentNode;
                    if (t && t.parentNode) t.parentNode.selectedIndex;
                    return null;
                },
                set: function(e) {
                    /* eslint no-unused-expressions: "off" */
                    var t = e.parentNode;
                    if (t) {
                        t.selectedIndex;
                        if (t.parentNode) t.parentNode.selectedIndex;
                    }
                }
            };
            be.each([ "tabIndex", "readOnly", "maxLength", "cellSpacing", "cellPadding", "rowSpan", "colSpan", "useMap", "frameBorder", "contentEditable" ], function() {
                be.propFix[this.toLowerCase()] = this;
            });
            be.fn.extend({
                addClass: function(e) {
                    var t, n, i, r, o, a, s, l = 0;
                    if (be.isFunction(e)) return this.each(function(t) {
                        be(this).addClass(e.call(this, t, J(this)));
                    });
                    if ("string" === typeof e && e) {
                        t = e.match(Me) || [];
                        for (;n = this[l++]; ) {
                            r = J(n);
                            i = 1 === n.nodeType && " " + Z(r) + " ";
                            if (i) {
                                a = 0;
                                for (;o = t[a++]; ) if (i.indexOf(" " + o + " ") < 0) i += o + " ";
                                // Only assign if different to avoid unneeded rendering.
                                s = Z(i);
                                if (r !== s) n.setAttribute("class", s);
                            }
                        }
                    }
                    return this;
                },
                removeClass: function(e) {
                    var t, n, i, r, o, a, s, l = 0;
                    if (be.isFunction(e)) return this.each(function(t) {
                        be(this).removeClass(e.call(this, t, J(this)));
                    });
                    if (!arguments.length) return this.attr("class", "");
                    if ("string" === typeof e && e) {
                        t = e.match(Me) || [];
                        for (;n = this[l++]; ) {
                            r = J(n);
                            // This expression is here for better compressibility (see addClass)
                            i = 1 === n.nodeType && " " + Z(r) + " ";
                            if (i) {
                                a = 0;
                                for (;o = t[a++]; ) // Remove *all* instances
                                for (;i.indexOf(" " + o + " ") > -1; ) i = i.replace(" " + o + " ", " ");
                                // Only assign if different to avoid unneeded rendering.
                                s = Z(i);
                                if (r !== s) n.setAttribute("class", s);
                            }
                        }
                    }
                    return this;
                },
                toggleClass: function(e, t) {
                    var n = typeof e;
                    if ("boolean" === typeof t && "string" === n) return t ? this.addClass(e) : this.removeClass(e);
                    if (be.isFunction(e)) return this.each(function(n) {
                        be(this).toggleClass(e.call(this, n, J(this), t), t);
                    });
                    return this.each(function() {
                        var t, i, r, o;
                        if ("string" === n) {
                            // Toggle individual class names
                            i = 0;
                            r = be(this);
                            o = e.match(Me) || [];
                            for (;t = o[i++]; ) // Check each className given, space separated list
                            if (r.hasClass(t)) r.removeClass(t); else r.addClass(t);
                        } else if (e === undefined || "boolean" === n) {
                            t = J(this);
                            if (t) // Store className if set
                            Fe.set(this, "__className__", t);
                            // If the element has a class name or if we're passed `false`,
                            // then remove the whole classname (if there was one, the above saved it).
                            // Otherwise bring back whatever was previously saved (if anything),
                            // falling back to the empty string if nothing was stored.
                            if (this.setAttribute) this.setAttribute("class", t || !1 === e ? "" : Fe.get(this, "__className__") || "");
                        }
                    });
                },
                hasClass: function(e) {
                    var t, n, i = 0;
                    t = " " + e + " ";
                    for (;n = this[i++]; ) if (1 === n.nodeType && (" " + Z(J(n)) + " ").indexOf(t) > -1) return !0;
                    return !1;
                }
            });
            var Et = /\r/g;
            be.fn.extend({
                val: function(e) {
                    var t, n, i, r = this[0];
                    if (!arguments.length) {
                        if (r) {
                            t = be.valHooks[r.type] || be.valHooks[r.nodeName.toLowerCase()];
                            if (t && "get" in t && (n = t.get(r, "value")) !== undefined) return n;
                            n = r.value;
                            // Handle most common string cases
                            if ("string" === typeof n) return n.replace(Et, "");
                            // Handle cases where value is null/undef or number
                            return null == n ? "" : n;
                        }
                        return;
                    }
                    i = be.isFunction(e);
                    return this.each(function(n) {
                        var r;
                        if (1 !== this.nodeType) return;
                        if (i) r = e.call(this, n, be(this).val()); else r = e;
                        // Treat null/undefined as ""; convert numbers to string
                        if (null == r) r = ""; else if ("number" === typeof r) r += ""; else if (Array.isArray(r)) r = be.map(r, function(e) {
                            return null == e ? "" : e + "";
                        });
                        t = be.valHooks[this.type] || be.valHooks[this.nodeName.toLowerCase()];
                        // If set returns undefined, fall back to normal setting
                        if (!t || !("set" in t) || t.set(this, r, "value") === undefined) this.value = r;
                    });
                }
            });
            be.extend({
                valHooks: {
                    option: {
                        get: function(e) {
                            var t = be.find.attr(e, "value");
                            // Support: IE <=10 - 11 only
                            // option.text throws exceptions (#14686, #14858)
                            // Strip and collapse whitespace
                            // https://html.spec.whatwg.org/#strip-and-collapse-whitespace
                            return null != t ? t : Z(be.text(e));
                        }
                    },
                    select: {
                        get: function(e) {
                            var t, n, i, r = e.options, o = e.selectedIndex, a = "select-one" === e.type, s = a ? null : [], u = a ? o + 1 : r.length;
                            if (o < 0) i = u; else i = a ? o : 0;
                            // Loop through all the selected options
                            for (;i < u; i++) {
                                n = r[i];
                                // Support: IE <=9 only
                                // IE8-9 doesn't update selected after form reset (#2551)
                                if ((n.selected || i === o) && // Don't return options that are disabled or in a disabled optgroup
                                !n.disabled && (!n.parentNode.disabled || !l(n.parentNode, "optgroup"))) {
                                    // Get the specific value for the option
                                    t = be(n).val();
                                    // We don't need an array for one selects
                                    if (a) return t;
                                    // Multi-Selects return an array
                                    s.push(t);
                                }
                            }
                            return s;
                        },
                        set: function(e, t) {
                            var n, i, r = e.options, o = be.makeArray(t), a = r.length;
                            for (;a--; ) {
                                i = r[a];
                                /* eslint-disable no-cond-assign */
                                if (i.selected = be.inArray(be.valHooks.option.get(i), o) > -1) n = !0;
                            }
                            // Force browsers to behave consistently when non-matching value is set
                            if (!n) e.selectedIndex = -1;
                            return o;
                        }
                    }
                }
            });
            // Radios and checkboxes getter/setter
            be.each([ "radio", "checkbox" ], function() {
                be.valHooks[this] = {
                    set: function(e, t) {
                        if (Array.isArray(t)) return e.checked = be.inArray(be(e).val(), t) > -1;
                    }
                };
                if (!me.checkOn) be.valHooks[this].get = function(e) {
                    return null === e.getAttribute("value") ? "on" : e.value;
                };
            });
            // Return jQuery for attributes-only inclusion
            var At = /^(?:focusinfocus|focusoutblur)$/;
            be.extend(be.event, {
                trigger: function(e, t, i, r) {
                    var o, a, s, l, u, c, f, d = [ i || ae ], p = he.call(e, "type") ? e.type : e, h = he.call(e, "namespace") ? e.namespace.split(".") : [];
                    a = s = i = i || ae;
                    // Don't do events on text and comment nodes
                    if (3 === i.nodeType || 8 === i.nodeType) return;
                    // focus/blur morphs to focusin/out; ensure we're not firing them right now
                    if (At.test(p + be.event.triggered)) return;
                    if (p.indexOf(".") > -1) {
                        // Namespaced trigger; create a regexp to match event type in handle()
                        h = p.split(".");
                        p = h.shift();
                        h.sort();
                    }
                    u = p.indexOf(":") < 0 && "on" + p;
                    // Caller can pass in a jQuery.Event object, Object, or just an event type string
                    e = e[be.expando] ? e : new be.Event(p, "object" === typeof e && e);
                    // Trigger bitmask: & 1 for native handlers; & 2 for jQuery (always true)
                    e.isTrigger = r ? 2 : 3;
                    e.namespace = h.join(".");
                    e.rnamespace = e.namespace ? new RegExp("(^|\\.)" + h.join("\\.(?:.*\\.|)") + "(\\.|$)") : null;
                    // Clean up the event in case it is being reused
                    e.result = undefined;
                    if (!e.target) e.target = i;
                    // Clone any incoming data and prepend the event, creating the handler arg list
                    t = null == t ? [ e ] : be.makeArray(t, [ e ]);
                    // Allow special events to draw outside the lines
                    f = be.event.special[p] || {};
                    if (!r && f.trigger && !1 === f.trigger.apply(i, t)) return;
                    // Determine event propagation path in advance, per W3C events spec (#9951)
                    // Bubble up to document, then to window; watch for a global ownerDocument var (#9724)
                    if (!r && !f.noBubble && !be.isWindow(i)) {
                        l = f.delegateType || p;
                        if (!At.test(l + p)) a = a.parentNode;
                        for (;a; a = a.parentNode) {
                            d.push(a);
                            s = a;
                        }
                        // Only add window if we got to document (e.g., not plain obj or detached DOM)
                        if (s === (i.ownerDocument || ae)) d.push(s.defaultView || s.parentWindow || n);
                    }
                    // Fire handlers on the event path
                    o = 0;
                    for (;(a = d[o++]) && !e.isPropagationStopped(); ) {
                        e.type = o > 1 ? l : f.bindType || p;
                        // jQuery handler
                        c = (Fe.get(a, "events") || {})[e.type] && Fe.get(a, "handle");
                        if (c) c.apply(a, t);
                        // Native handler
                        c = u && a[u];
                        if (c && c.apply && _e(a)) {
                            e.result = c.apply(a, t);
                            if (!1 === e.result) e.preventDefault();
                        }
                    }
                    e.type = p;
                    // If nobody prevented the default action, do it now
                    if (!r && !e.isDefaultPrevented()) if ((!f._default || !1 === f._default.apply(d.pop(), t)) && _e(i)) // Call a native DOM method on the target with the same name as the event.
                    // Don't do default actions on window, that's where global variables be (#6170)
                    if (u && be.isFunction(i[p]) && !be.isWindow(i)) {
                        // Don't re-trigger an onFOO event when we call its FOO() method
                        s = i[u];
                        if (s) i[u] = null;
                        // Prevent re-triggering of the same event, since we already bubbled it above
                        be.event.triggered = p;
                        i[p]();
                        be.event.triggered = undefined;
                        if (s) i[u] = s;
                    }
                    return e.result;
                },
                // Piggyback on a donor event to simulate a different one
                // Used only for `focus(in | out)` events
                simulate: function(e, t, n) {
                    var i = be.extend(new be.Event(), n, {
                        type: e,
                        isSimulated: !0
                    });
                    be.event.trigger(i, null, t);
                }
            });
            be.fn.extend({
                trigger: function(e, t) {
                    return this.each(function() {
                        be.event.trigger(e, t, this);
                    });
                },
                triggerHandler: function(e, t) {
                    var n = this[0];
                    if (n) return be.event.trigger(e, t, n, !0);
                }
            });
            be.each(("blur focus focusin focusout resize scroll click dblclick " + "mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave " + "change select submit keydown keypress keyup contextmenu").split(" "), function(e, t) {
                // Handle event binding
                be.fn[t] = function(e, n) {
                    return arguments.length > 0 ? this.on(t, null, e, n) : this.trigger(t);
                };
            });
            be.fn.extend({
                hover: function(e, t) {
                    return this.mouseenter(e).mouseleave(t || e);
                }
            });
            me.focusin = "onfocusin" in n;
            // Support: Firefox <=44
            // Firefox doesn't have focus(in | out) events
            // Related ticket - https://bugzilla.mozilla.org/show_bug.cgi?id=687787
            //
            // Support: Chrome <=48 - 49, Safari <=9.0 - 9.1
            // focus(in | out) events fire after focus & blur events,
            // which is spec violation - http://www.w3.org/TR/DOM-Level-3-Events/#events-focusevent-event-order
            // Related ticket - https://bugs.chromium.org/p/chromium/issues/detail?id=449857
            if (!me.focusin) be.each({
                focus: "focusin",
                blur: "focusout"
            }, function(e, t) {
                // Attach a single capturing handler on the document while someone wants focusin/focusout
                var n = function(e) {
                    be.event.simulate(t, e.target, be.event.fix(e));
                };
                be.event.special[t] = {
                    setup: function() {
                        var i = this.ownerDocument || this, r = Fe.access(i, t);
                        if (!r) i.addEventListener(e, n, !0);
                        Fe.access(i, t, (r || 0) + 1);
                    },
                    teardown: function() {
                        var i = this.ownerDocument || this, r = Fe.access(i, t) - 1;
                        if (!r) {
                            i.removeEventListener(e, n, !0);
                            Fe.remove(i, t);
                        } else Fe.access(i, t, r);
                    }
                };
            });
            var Pt = n.location;
            var Dt = be.now();
            var Ot = /\?/;
            // Cross-browser xml parsing
            be.parseXML = function(e) {
                var t;
                if (!e || "string" !== typeof e) return null;
                // Support: IE 9 - 11 only
                // IE throws on parseFromString with invalid input.
                try {
                    t = new n.DOMParser().parseFromString(e, "text/xml");
                } catch (i) {
                    t = undefined;
                }
                if (!t || t.getElementsByTagName("parsererror").length) be.error("Invalid XML: " + e);
                return t;
            };
            var Nt = /\[\]$/, qt = /\r?\n/g, jt = /^(?:submit|button|image|reset|file)$/i, Mt = /^(?:input|select|textarea|keygen)/i;
            // Serialize an array of form elements or a set of
            // key/values into a query string
            be.param = function(e, t) {
                var n, i = [], r = function(e, t) {
                    // If value is a function, invoke it and use its return value
                    var n = be.isFunction(t) ? t() : t;
                    i[i.length] = encodeURIComponent(e) + "=" + encodeURIComponent(null == n ? "" : n);
                };
                // If an array was passed in, assume that it is an array of form elements.
                if (Array.isArray(e) || e.jquery && !be.isPlainObject(e)) // Serialize the form elements
                be.each(e, function() {
                    r(this.name, this.value);
                }); else // If traditional, encode the "old" way (the way 1.3.2 or older
                // did it), otherwise encode params recursively.
                for (n in e) K(n, e[n], t, r);
                // Return the resulting serialization
                return i.join("&");
            };
            be.fn.extend({
                serialize: function() {
                    return be.param(this.serializeArray());
                },
                serializeArray: function() {
                    return this.map(function() {
                        // Can add propHook for "elements" to filter or add form elements
                        var e = be.prop(this, "elements");
                        return e ? be.makeArray(e) : this;
                    }).filter(function() {
                        var e = this.type;
                        // Use .is( ":disabled" ) so that fieldset[disabled] works
                        return this.name && !be(this).is(":disabled") && Mt.test(this.nodeName) && !jt.test(e) && (this.checked || !Ue.test(e));
                    }).map(function(e, t) {
                        var n = be(this).val();
                        if (null == n) return null;
                        if (Array.isArray(n)) return be.map(n, function(e) {
                            return {
                                name: t.name,
                                value: e.replace(qt, "\r\n")
                            };
                        });
                        return {
                            name: t.name,
                            value: n.replace(qt, "\r\n")
                        };
                    }).get();
                }
            });
            var Lt = /%20/g, It = /#.*$/, Ht = /([?&])_=[^&]*/, _t = /^(.*?):[ \t]*([^\r\n]*)$/gm, // #7653, #8125, #8152: local protocol detection
            Ft = /^(?:about|app|app-storage|.+-extension|file|res|widget):$/, Rt = /^(?:GET|HEAD)$/, Wt = /^\/\//, /* Prefilters
	 * 1) They are useful to introduce custom dataTypes (see ajax/jsonp.js for an example)
	 * 2) These are called:
	 *    - BEFORE asking for a transport
	 *    - AFTER param serialization (s.data is a string if s.processData is true)
	 * 3) key is the dataType
	 * 4) the catchall symbol "*" can be used
	 * 5) execution will start with transport dataType and THEN continue down to "*" if needed
	 */
            $t = {}, /* Transports bindings
	 * 1) key is the dataType
	 * 2) the catchall symbol "*" can be used
	 * 3) selection will start with transport dataType and THEN go to "*" if needed
	 */
            zt = {}, // Avoid comment-prolog char sequence (#10098); must appease lint and evade compression
            Vt = "*/".concat("*"), // Anchor tag for parsing the document origin
            Xt = ae.createElement("a");
            Xt.href = Pt.href;
            be.extend({
                // Counter for holding the number of active queries
                active: 0,
                // Last-Modified header cache for next request
                lastModified: {},
                etag: {},
                ajaxSettings: {
                    url: Pt.href,
                    type: "GET",
                    isLocal: Ft.test(Pt.protocol),
                    global: !0,
                    processData: !0,
                    async: !0,
                    contentType: "application/x-www-form-urlencoded; charset=UTF-8",
                    /*
		timeout: 0,
		data: null,
		dataType: null,
		username: null,
		password: null,
		cache: null,
		throws: false,
		traditional: false,
		headers: {},
		*/
                    accepts: {
                        "*": Vt,
                        text: "text/plain",
                        html: "text/html",
                        xml: "application/xml, text/xml",
                        json: "application/json, text/javascript"
                    },
                    contents: {
                        xml: /\bxml\b/,
                        html: /\bhtml/,
                        json: /\bjson\b/
                    },
                    responseFields: {
                        xml: "responseXML",
                        text: "responseText",
                        json: "responseJSON"
                    },
                    // Data converters
                    // Keys separate source (or catchall "*") and destination types with a single space
                    converters: {
                        // Convert anything to text
                        "* text": String,
                        // Text to html (true = no transformation)
                        "text html": !0,
                        // Evaluate text as a json expression
                        "text json": JSON.parse,
                        // Parse text as xml
                        "text xml": be.parseXML
                    },
                    // For options that shouldn't be deep extended:
                    // you can add your own custom options here if
                    // and when you create one that shouldn't be
                    // deep extended (see ajaxExtend)
                    flatOptions: {
                        url: !0,
                        context: !0
                    }
                },
                // Creates a full fledged settings object into target
                // with both ajaxSettings and settings fields.
                // If target is omitted, writes into ajaxSettings.
                ajaxSetup: function(e, t) {
                    // Building a settings object
                    // Extending ajaxSettings
                    return t ? ne(ne(e, be.ajaxSettings), t) : ne(be.ajaxSettings, e);
                },
                ajaxPrefilter: ee($t),
                ajaxTransport: ee(zt),
                // Main method
                ajax: function(e, t) {
                    // Callback for when everything is done
                    function i(e, t, i, s) {
                        var u, d, p, x, w, T = t;
                        // Ignore repeat invocations
                        if (c) return;
                        c = !0;
                        // Clear timeout if it exists
                        if (l) n.clearTimeout(l);
                        // Dereference transport for early garbage collection
                        // (no matter how long the jqXHR object will be used)
                        r = undefined;
                        // Cache response headers
                        a = s || "";
                        // Set readyState
                        C.readyState = e > 0 ? 4 : 0;
                        // Determine if successful
                        u = e >= 200 && e < 300 || 304 === e;
                        // Get response data
                        if (i) x = ie(h, C, i);
                        // Convert no matter what (that way responseXXX fields are always set)
                        x = re(h, x, C, u);
                        // If successful, handle type chaining
                        if (u) {
                            // Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.
                            if (h.ifModified) {
                                w = C.getResponseHeader("Last-Modified");
                                if (w) be.lastModified[o] = w;
                                w = C.getResponseHeader("etag");
                                if (w) be.etag[o] = w;
                            }
                            // if no content
                            if (204 === e || "HEAD" === h.type) T = "nocontent"; else if (304 === e) T = "notmodified"; else {
                                T = x.state;
                                d = x.data;
                                p = x.error;
                                u = !p;
                            }
                        } else {
                            // Extract error from statusText and normalize for non-aborts
                            p = T;
                            if (e || !T) {
                                T = "error";
                                if (e < 0) e = 0;
                            }
                        }
                        // Set data for the fake xhr object
                        C.status = e;
                        C.statusText = (t || T) + "";
                        // Success/Error
                        if (u) m.resolveWith(v, [ d, T, C ]); else m.rejectWith(v, [ C, T, p ]);
                        // Status-dependent callbacks
                        C.statusCode(b);
                        b = undefined;
                        if (f) g.trigger(u ? "ajaxSuccess" : "ajaxError", [ C, h, u ? d : p ]);
                        // Complete
                        y.fireWith(v, [ C, T ]);
                        if (f) {
                            g.trigger("ajaxComplete", [ C, h ]);
                            // Handle the global AJAX counter
                            if (!--be.active) be.event.trigger("ajaxStop");
                        }
                    }
                    // If url is an object, simulate pre-1.5 signature
                    if ("object" === typeof e) {
                        t = e;
                        e = undefined;
                    }
                    // Force options to be an object
                    t = t || {};
                    var r, // URL without anti-cache param
                    o, // Response headers
                    a, s, // timeout handle
                    l, // Url cleanup var
                    u, // Request state (becomes false upon send and true upon completion)
                    c, // To know if global events are to be dispatched
                    f, // Loop variable
                    d, // uncached part of the url
                    p, // Create the final options object
                    h = be.ajaxSetup({}, t), // Callbacks context
                    v = h.context || h, // Context for global events is callbackContext if it is a DOM node or jQuery collection
                    g = h.context && (v.nodeType || v.jquery) ? be(v) : be.event, // Deferreds
                    m = be.Deferred(), y = be.Callbacks("once memory"), // Status-dependent callbacks
                    b = h.statusCode || {}, // Headers (they are sent all at once)
                    x = {}, w = {}, // Default abort message
                    T = "canceled", // Fake xhr
                    C = {
                        readyState: 0,
                        // Builds headers hashtable if needed
                        getResponseHeader: function(e) {
                            var t;
                            if (c) {
                                if (!s) {
                                    s = {};
                                    for (;t = _t.exec(a); ) s[t[1].toLowerCase()] = t[2];
                                }
                                t = s[e.toLowerCase()];
                            }
                            return null == t ? null : t;
                        },
                        // Raw string
                        getAllResponseHeaders: function() {
                            return c ? a : null;
                        },
                        // Caches the header
                        setRequestHeader: function(e, t) {
                            if (null == c) {
                                e = w[e.toLowerCase()] = w[e.toLowerCase()] || e;
                                x[e] = t;
                            }
                            return this;
                        },
                        // Overrides response content-type header
                        overrideMimeType: function(e) {
                            if (null == c) h.mimeType = e;
                            return this;
                        },
                        // Status-dependent callbacks
                        statusCode: function(e) {
                            var t;
                            if (e) if (c) // Execute the appropriate callbacks
                            C.always(e[C.status]); else // Lazy-add the new callbacks in a way that preserves old ones
                            for (t in e) b[t] = [ b[t], e[t] ];
                            return this;
                        },
                        // Cancel the request
                        abort: function(e) {
                            var t = e || T;
                            if (r) r.abort(t);
                            i(0, t);
                            return this;
                        }
                    };
                    // Attach deferreds
                    m.promise(C);
                    // Add protocol if not provided (prefilters might expect it)
                    // Handle falsy url in the settings object (#10093: consistency with old signature)
                    // We also use the url parameter if available
                    h.url = ((e || h.url || Pt.href) + "").replace(Wt, Pt.protocol + "//");
                    // Alias method option to type as per ticket #12004
                    h.type = t.method || t.type || h.method || h.type;
                    // Extract dataTypes list
                    h.dataTypes = (h.dataType || "*").toLowerCase().match(Me) || [ "" ];
                    // A cross-domain request is in order when the origin doesn't match the current origin.
                    if (null == h.crossDomain) {
                        u = ae.createElement("a");
                        // Support: IE <=8 - 11, Edge 12 - 13
                        // IE throws exception on accessing the href property if url is malformed,
                        // e.g. http://example.com:80x/
                        try {
                            u.href = h.url;
                            // Support: IE <=8 - 11 only
                            // Anchor's host property isn't correctly set when s.url is relative
                            u.href = u.href;
                            h.crossDomain = Xt.protocol + "//" + Xt.host !== u.protocol + "//" + u.host;
                        } catch (k) {
                            // If there is an error parsing the URL, assume it is crossDomain,
                            // it can be rejected by the transport if it is invalid
                            h.crossDomain = !0;
                        }
                    }
                    // Convert data if not already a string
                    if (h.data && h.processData && "string" !== typeof h.data) h.data = be.param(h.data, h.traditional);
                    // Apply prefilters
                    te($t, h, t, C);
                    // If request was aborted inside a prefilter, stop there
                    if (c) return C;
                    // We can fire global events as of now if asked to
                    // Don't fire events if jQuery.event is undefined in an AMD-usage scenario (#15118)
                    f = be.event && h.global;
                    // Watch for a new set of requests
                    if (f && 0 === be.active++) be.event.trigger("ajaxStart");
                    // Uppercase the type
                    h.type = h.type.toUpperCase();
                    // Determine if request has content
                    h.hasContent = !Rt.test(h.type);
                    // Save the URL in case we're toying with the If-Modified-Since
                    // and/or If-None-Match header later on
                    // Remove hash to simplify url manipulation
                    o = h.url.replace(It, "");
                    // More options handling for requests with no content
                    if (!h.hasContent) {
                        // Remember the hash so we can put it back
                        p = h.url.slice(o.length);
                        // If data is available, append data to url
                        if (h.data) {
                            o += (Ot.test(o) ? "&" : "?") + h.data;
                            // #9682: remove data so that it's not used in an eventual retry
                            delete h.data;
                        }
                        // Add or update anti-cache param if needed
                        if (!1 === h.cache) {
                            o = o.replace(Ht, "$1");
                            p = (Ot.test(o) ? "&" : "?") + "_=" + Dt++ + p;
                        }
                        // Put hash and anti-cache on the URL that will be requested (gh-1732)
                        h.url = o + p;
                    } else if (h.data && h.processData && 0 === (h.contentType || "").indexOf("application/x-www-form-urlencoded")) h.data = h.data.replace(Lt, "+");
                    // Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.
                    if (h.ifModified) {
                        if (be.lastModified[o]) C.setRequestHeader("If-Modified-Since", be.lastModified[o]);
                        if (be.etag[o]) C.setRequestHeader("If-None-Match", be.etag[o]);
                    }
                    // Set the correct header, if data is being sent
                    if (h.data && h.hasContent && !1 !== h.contentType || t.contentType) C.setRequestHeader("Content-Type", h.contentType);
                    // Set the Accepts header for the server, depending on the dataType
                    C.setRequestHeader("Accept", h.dataTypes[0] && h.accepts[h.dataTypes[0]] ? h.accepts[h.dataTypes[0]] + ("*" !== h.dataTypes[0] ? ", " + Vt + "; q=0.01" : "") : h.accepts["*"]);
                    // Check for headers option
                    for (d in h.headers) C.setRequestHeader(d, h.headers[d]);
                    // Allow custom headers/mimetypes and early abort
                    if (h.beforeSend && (!1 === h.beforeSend.call(v, C, h) || c)) // Abort if not done already and return
                    return C.abort();
                    // Aborting is no longer a cancellation
                    T = "abort";
                    // Install callbacks on deferreds
                    y.add(h.complete);
                    C.done(h.success);
                    C.fail(h.error);
                    // Get transport
                    r = te(zt, h, t, C);
                    // If no transport, we auto-abort
                    if (!r) i(-1, "No Transport"); else {
                        C.readyState = 1;
                        // Send global event
                        if (f) g.trigger("ajaxSend", [ C, h ]);
                        // If request was aborted inside ajaxSend, stop there
                        if (c) return C;
                        // Timeout
                        if (h.async && h.timeout > 0) l = n.setTimeout(function() {
                            C.abort("timeout");
                        }, h.timeout);
                        try {
                            c = !1;
                            r.send(x, i);
                        } catch (k) {
                            // Rethrow post-completion exceptions
                            if (c) throw k;
                            // Propagate others as results
                            i(-1, k);
                        }
                    }
                    return C;
                },
                getJSON: function(e, t, n) {
                    return be.get(e, t, n, "json");
                },
                getScript: function(e, t) {
                    return be.get(e, undefined, t, "script");
                }
            });
            be.each([ "get", "post" ], function(e, t) {
                be[t] = function(e, n, i, r) {
                    // Shift arguments if data argument was omitted
                    if (be.isFunction(n)) {
                        r = r || i;
                        i = n;
                        n = undefined;
                    }
                    // The url can be an options object (which then must have .url)
                    return be.ajax(be.extend({
                        url: e,
                        type: t,
                        dataType: r,
                        data: n,
                        success: i
                    }, be.isPlainObject(e) && e));
                };
            });
            be._evalUrl = function(e) {
                return be.ajax({
                    url: e,
                    // Make this explicit, since user can override this through ajaxSetup (#11264)
                    type: "GET",
                    dataType: "script",
                    cache: !0,
                    async: !1,
                    global: !1,
                    throws: !0
                });
            };
            be.fn.extend({
                wrapAll: function(e) {
                    var t;
                    if (this[0]) {
                        if (be.isFunction(e)) e = e.call(this[0]);
                        // The elements to wrap the target around
                        t = be(e, this[0].ownerDocument).eq(0).clone(!0);
                        if (this[0].parentNode) t.insertBefore(this[0]);
                        t.map(function() {
                            var e = this;
                            for (;e.firstElementChild; ) e = e.firstElementChild;
                            return e;
                        }).append(this);
                    }
                    return this;
                },
                wrapInner: function(e) {
                    if (be.isFunction(e)) return this.each(function(t) {
                        be(this).wrapInner(e.call(this, t));
                    });
                    return this.each(function() {
                        var t = be(this), n = t.contents();
                        if (n.length) n.wrapAll(e); else t.append(e);
                    });
                },
                wrap: function(e) {
                    var t = be.isFunction(e);
                    return this.each(function(n) {
                        be(this).wrapAll(t ? e.call(this, n) : e);
                    });
                },
                unwrap: function(e) {
                    this.parent(e).not("body").each(function() {
                        be(this).replaceWith(this.childNodes);
                    });
                    return this;
                }
            });
            be.expr.pseudos.hidden = function(e) {
                return !be.expr.pseudos.visible(e);
            };
            be.expr.pseudos.visible = function(e) {
                return !!(e.offsetWidth || e.offsetHeight || e.getClientRects().length);
            };
            be.ajaxSettings.xhr = function() {
                try {
                    return new n.XMLHttpRequest();
                } catch (e) {}
            };
            var Bt = {
                // File protocol always yields status code 0, assume 200
                0: 200,
                // Support: IE <=9 only
                // #1450: sometimes IE returns 1223 when it should be 204
                1223: 204
            }, Yt = be.ajaxSettings.xhr();
            me.cors = !!Yt && "withCredentials" in Yt;
            me.ajax = Yt = !!Yt;
            be.ajaxTransport(function(e) {
                var t, i;
                // Cross domain only allowed if supported through XMLHttpRequest
                if (me.cors || Yt && !e.crossDomain) return {
                    send: function(r, o) {
                        var a, s = e.xhr();
                        s.open(e.type, e.url, e.async, e.username, e.password);
                        // Apply custom fields if provided
                        if (e.xhrFields) for (a in e.xhrFields) s[a] = e.xhrFields[a];
                        // Override mime type if needed
                        if (e.mimeType && s.overrideMimeType) s.overrideMimeType(e.mimeType);
                        // X-Requested-With header
                        // For cross-domain requests, seeing as conditions for a preflight are
                        // akin to a jigsaw puzzle, we simply never set it to be sure.
                        // (it can always be set on a per-request basis or even using ajaxSetup)
                        // For same-domain requests, won't change header if already provided.
                        if (!e.crossDomain && !r["X-Requested-With"]) r["X-Requested-With"] = "XMLHttpRequest";
                        // Set headers
                        for (a in r) s.setRequestHeader(a, r[a]);
                        // Callback
                        t = function(e) {
                            return function() {
                                if (t) {
                                    t = i = s.onload = s.onerror = s.onabort = s.onreadystatechange = null;
                                    if ("abort" === e) s.abort(); else if ("error" === e) // Support: IE <=9 only
                                    // On a manual native abort, IE9 throws
                                    // errors on any property access that is not readyState
                                    if ("number" !== typeof s.status) o(0, "error"); else o(// File: protocol always yields status 0; see #8605, #14207
                                    s.status, s.statusText); else o(Bt[s.status] || s.status, s.statusText, // Support: IE <=9 only
                                    // IE9 has no XHR2 but throws on binary (trac-11426)
                                    // For XHR2 non-text, let the caller handle it (gh-2498)
                                    "text" !== (s.responseType || "text") || "string" !== typeof s.responseText ? {
                                        binary: s.response
                                    } : {
                                        text: s.responseText
                                    }, s.getAllResponseHeaders());
                                }
                            };
                        };
                        // Listen to events
                        s.onload = t();
                        i = s.onerror = t("error");
                        // Support: IE 9 only
                        // Use onreadystatechange to replace onabort
                        // to handle uncaught aborts
                        if (s.onabort !== undefined) s.onabort = i; else s.onreadystatechange = function() {
                            // Check readyState before timeout as it changes
                            if (4 === s.readyState) // Allow onerror to be called first,
                            // but that will not handle a native abort
                            // Also, save errorCallback to a variable
                            // as xhr.onerror cannot be accessed
                            n.setTimeout(function() {
                                if (t) i();
                            });
                        };
                        // Create the abort callback
                        t = t("abort");
                        try {
                            // Do send the request (this may raise an exception)
                            s.send(e.hasContent && e.data || null);
                        } catch (l) {
                            // #14683: Only rethrow if this hasn't been notified as an error yet
                            if (t) throw l;
                        }
                    },
                    abort: function() {
                        if (t) t();
                    }
                };
            });
            // Prevent auto-execution of scripts when no explicit dataType was provided (See gh-2432)
            be.ajaxPrefilter(function(e) {
                if (e.crossDomain) e.contents.script = !1;
            });
            // Install script dataType
            be.ajaxSetup({
                accepts: {
                    script: "text/javascript, application/javascript, " + "application/ecmascript, application/x-ecmascript"
                },
                contents: {
                    script: /\b(?:java|ecma)script\b/
                },
                converters: {
                    "text script": function(e) {
                        be.globalEval(e);
                        return e;
                    }
                }
            });
            // Handle cache's special case and crossDomain
            be.ajaxPrefilter("script", function(e) {
                if (e.cache === undefined) e.cache = !1;
                if (e.crossDomain) e.type = "GET";
            });
            // Bind script tag hack transport
            be.ajaxTransport("script", function(e) {
                // This transport only deals with cross domain requests
                if (e.crossDomain) {
                    var t, n;
                    return {
                        send: function(i, r) {
                            t = be("<script>").prop({
                                charset: e.scriptCharset,
                                src: e.url
                            }).on("load error", n = function(e) {
                                t.remove();
                                n = null;
                                if (e) r("error" === e.type ? 404 : 200, e.type);
                            });
                            // Use native DOM manipulation to avoid our domManip AJAX trickery
                            ae.head.appendChild(t[0]);
                        },
                        abort: function() {
                            if (n) n();
                        }
                    };
                }
            });
            var Qt = [], Ut = /(=)\?(?=&|$)|\?\?/;
            // Default jsonp settings
            be.ajaxSetup({
                jsonp: "callback",
                jsonpCallback: function() {
                    var e = Qt.pop() || be.expando + "_" + Dt++;
                    this[e] = !0;
                    return e;
                }
            });
            // Detect, normalize options and install callbacks for jsonp requests
            be.ajaxPrefilter("json jsonp", function(e, t, i) {
                var r, o, a, s = !1 !== e.jsonp && (Ut.test(e.url) ? "url" : "string" === typeof e.data && 0 === (e.contentType || "").indexOf("application/x-www-form-urlencoded") && Ut.test(e.data) && "data");
                // Handle iff the expected data type is "jsonp" or we have a parameter to set
                if (s || "jsonp" === e.dataTypes[0]) {
                    // Get callback name, remembering preexisting value associated with it
                    r = e.jsonpCallback = be.isFunction(e.jsonpCallback) ? e.jsonpCallback() : e.jsonpCallback;
                    // Insert callback into url or form data
                    if (s) e[s] = e[s].replace(Ut, "$1" + r); else if (!1 !== e.jsonp) e.url += (Ot.test(e.url) ? "&" : "?") + e.jsonp + "=" + r;
                    // Use data converter to retrieve json after script execution
                    e.converters["script json"] = function() {
                        if (!a) be.error(r + " was not called");
                        return a[0];
                    };
                    // Force json dataType
                    e.dataTypes[0] = "json";
                    // Install callback
                    o = n[r];
                    n[r] = function() {
                        a = arguments;
                    };
                    // Clean-up function (fires after converters)
                    i.always(function() {
                        // If previous value didn't exist - remove it
                        if (o === undefined) be(n).removeProp(r); else n[r] = o;
                        // Save back as free
                        if (e[r]) {
                            // Make sure that re-using the options doesn't screw things around
                            e.jsonpCallback = t.jsonpCallback;
                            // Save the callback name for future use
                            Qt.push(r);
                        }
                        // Call if it was a function and we have a response
                        if (a && be.isFunction(o)) o(a[0]);
                        a = o = undefined;
                    });
                    // Delegate to script
                    return "script";
                }
            });
            // Support: Safari 8 only
            // In Safari 8 documents created via document.implementation.createHTMLDocument
            // collapse sibling forms: the second one becomes a child of the first one.
            // Because of that, this security measure has to be disabled in Safari 8.
            // https://bugs.webkit.org/show_bug.cgi?id=137337
            me.createHTMLDocument = function() {
                var e = ae.implementation.createHTMLDocument("").body;
                e.innerHTML = "<form></form><form></form>";
                return 2 === e.childNodes.length;
            }();
            // Argument "data" should be string of html
            // context (optional): If specified, the fragment will be created in this context,
            // defaults to document
            // keepScripts (optional): If true, will include scripts passed in the html string
            be.parseHTML = function(e, t, n) {
                if ("string" !== typeof e) return [];
                if ("boolean" === typeof t) {
                    n = t;
                    t = !1;
                }
                var i, r, o;
                if (!t) // Stop scripts or inline event handlers from being executed immediately
                // by using document.implementation
                if (me.createHTMLDocument) {
                    t = ae.implementation.createHTMLDocument("");
                    // Set the base href for the created document
                    // so any parsed elements with URLs
                    // are based on the document's URL (gh-2965)
                    i = t.createElement("base");
                    i.href = ae.location.href;
                    t.head.appendChild(i);
                } else t = ae;
                r = Pe.exec(e);
                o = !n && [];
                // Single tag
                if (r) return [ t.createElement(r[1]) ];
                r = k([ e ], t, o);
                if (o && o.length) be(o).remove();
                return be.merge([], r.childNodes);
            };
            /**
 * Load a url into a page
 */
            be.fn.load = function(e, t, n) {
                var i, r, o, a = this, s = e.indexOf(" ");
                if (s > -1) {
                    i = Z(e.slice(s));
                    e = e.slice(0, s);
                }
                // If it's a function
                if (be.isFunction(t)) {
                    // We assume that it's the callback
                    n = t;
                    t = undefined;
                } else if (t && "object" === typeof t) r = "POST";
                // If we have elements to modify, make the request
                if (a.length > 0) be.ajax({
                    url: e,
                    // If "type" variable is undefined, then "GET" method will be used.
                    // Make value of this field explicit since
                    // user can override it through ajaxSetup method
                    type: r || "GET",
                    dataType: "html",
                    data: t
                }).done(function(e) {
                    // Save response for use in complete callback
                    o = arguments;
                    a.html(i ? // If a selector was specified, locate the right elements in a dummy div
                    // Exclude scripts to avoid IE 'Permission Denied' errors
                    be("<div>").append(be.parseHTML(e)).find(i) : // Otherwise use the full result
                    e);
                }).always(n && function(e, t) {
                    a.each(function() {
                        n.apply(this, o || [ e.responseText, t, e ]);
                    });
                });
                return this;
            };
            // Attach a bunch of functions for handling common AJAX events
            be.each([ "ajaxStart", "ajaxStop", "ajaxComplete", "ajaxError", "ajaxSuccess", "ajaxSend" ], function(e, t) {
                be.fn[t] = function(e) {
                    return this.on(t, e);
                };
            });
            be.expr.pseudos.animated = function(e) {
                return be.grep(be.timers, function(t) {
                    return e === t.elem;
                }).length;
            };
            be.offset = {
                setOffset: function(e, t, n) {
                    var i, r, o, a, s, l, u, c = be.css(e, "position"), f = be(e), d = {};
                    // Set position first, in-case top/left are set even on static elem
                    if ("static" === c) e.style.position = "relative";
                    s = f.offset();
                    o = be.css(e, "top");
                    l = be.css(e, "left");
                    u = ("absolute" === c || "fixed" === c) && (o + l).indexOf("auto") > -1;
                    // Need to be able to calculate position if either
                    // top or left is auto and position is either absolute or fixed
                    if (u) {
                        i = f.position();
                        a = i.top;
                        r = i.left;
                    } else {
                        a = parseFloat(o) || 0;
                        r = parseFloat(l) || 0;
                    }
                    if (be.isFunction(t)) // Use jQuery.extend here to allow modification of coordinates argument (gh-1848)
                    t = t.call(e, n, be.extend({}, s));
                    if (null != t.top) d.top = t.top - s.top + a;
                    if (null != t.left) d.left = t.left - s.left + r;
                    if ("using" in t) t.using.call(e, d); else f.css(d);
                }
            };
            be.fn.extend({
                offset: function(e) {
                    // Preserve chaining for setter
                    if (arguments.length) return e === undefined ? this : this.each(function(t) {
                        be.offset.setOffset(this, e, t);
                    });
                    var t, n, i, r, o = this[0];
                    if (!o) return;
                    // Return zeros for disconnected and hidden (display: none) elements (gh-2310)
                    // Support: IE <=11 only
                    // Running getBoundingClientRect on a
                    // disconnected node in IE throws an error
                    if (!o.getClientRects().length) return {
                        top: 0,
                        left: 0
                    };
                    i = o.getBoundingClientRect();
                    t = o.ownerDocument;
                    n = t.documentElement;
                    r = t.defaultView;
                    return {
                        top: i.top + r.pageYOffset - n.clientTop,
                        left: i.left + r.pageXOffset - n.clientLeft
                    };
                },
                position: function() {
                    if (!this[0]) return;
                    var e, t, n = this[0], i = {
                        top: 0,
                        left: 0
                    };
                    // Fixed elements are offset from window (parentOffset = {top:0, left: 0},
                    // because it is its only offset parent
                    if ("fixed" === be.css(n, "position")) // Assume getBoundingClientRect is there when computed position is fixed
                    t = n.getBoundingClientRect(); else {
                        // Get *real* offsetParent
                        e = this.offsetParent();
                        // Get correct offsets
                        t = this.offset();
                        if (!l(e[0], "html")) i = e.offset();
                        // Add offsetParent borders
                        i = {
                            top: i.top + be.css(e[0], "borderTopWidth", !0),
                            left: i.left + be.css(e[0], "borderLeftWidth", !0)
                        };
                    }
                    // Subtract parent offsets and element margins
                    return {
                        top: t.top - i.top - be.css(n, "marginTop", !0),
                        left: t.left - i.left - be.css(n, "marginLeft", !0)
                    };
                },
                // This method will return documentElement in the following cases:
                // 1) For the element inside the iframe without offsetParent, this method will return
                //    documentElement of the parent window
                // 2) For the hidden or detached element
                // 3) For body or html element, i.e. in case of the html node - it will return itself
                //
                // but those exceptions were never presented as a real life use-cases
                // and might be considered as more preferable results.
                //
                // This logic, however, is not guaranteed and can change at any point in the future
                offsetParent: function() {
                    return this.map(function() {
                        var e = this.offsetParent;
                        for (;e && "static" === be.css(e, "position"); ) e = e.offsetParent;
                        return e || et;
                    });
                }
            });
            // Create scrollLeft and scrollTop methods
            be.each({
                scrollLeft: "pageXOffset",
                scrollTop: "pageYOffset"
            }, function(e, t) {
                var n = "pageYOffset" === t;
                be.fn[e] = function(i) {
                    return He(this, function(e, i, r) {
                        // Coalesce documents and windows
                        var o;
                        if (be.isWindow(e)) o = e; else if (9 === e.nodeType) o = e.defaultView;
                        if (r === undefined) return o ? o[t] : e[i];
                        if (o) o.scrollTo(!n ? r : o.pageXOffset, n ? r : o.pageYOffset); else e[i] = r;
                    }, e, i, arguments.length);
                };
            });
            // Support: Safari <=7 - 9.1, Chrome <=37 - 49
            // Add the top/left cssHooks using jQuery.fn.position
            // Webkit bug: https://bugs.webkit.org/show_bug.cgi?id=29084
            // Blink bug: https://bugs.chromium.org/p/chromium/issues/detail?id=589347
            // getComputedStyle returns percent when specified for top/left/bottom/right;
            // rather than make the css module depend on the offset module, just check for it here
            be.each([ "top", "left" ], function(e, t) {
                be.cssHooks[t] = H(me.pixelPosition, function(e, n) {
                    if (n) {
                        n = I(e, t);
                        // If curCSS returns percentage, fallback to offset
                        return ct.test(n) ? be(e).position()[t] + "px" : n;
                    }
                });
            });
            // Create innerHeight, innerWidth, height, width, outerHeight and outerWidth methods
            be.each({
                Height: "height",
                Width: "width"
            }, function(e, t) {
                be.each({
                    padding: "inner" + e,
                    content: t,
                    "": "outer" + e
                }, function(n, i) {
                    // Margin is only for outerHeight, outerWidth
                    be.fn[i] = function(r, o) {
                        var a = arguments.length && (n || "boolean" !== typeof r), s = n || (!0 === r || !0 === o ? "margin" : "border");
                        return He(this, function(t, n, r) {
                            var o;
                            if (be.isWindow(t)) // $( window ).outerWidth/Height return w/h including scrollbars (gh-1729)
                            return 0 === i.indexOf("outer") ? t["inner" + e] : t.document.documentElement["client" + e];
                            // Get document width or height
                            if (9 === t.nodeType) {
                                o = t.documentElement;
                                // Either scroll[Width/Height] or offset[Width/Height] or client[Width/Height],
                                // whichever is greatest
                                return Math.max(t.body["scroll" + e], o["scroll" + e], t.body["offset" + e], o["offset" + e], o["client" + e]);
                            }
                            // Get width or height on the element, requesting but not forcing parseFloat
                            // Set width or height on the element
                            return r === undefined ? be.css(t, n, s) : be.style(t, n, r, s);
                        }, t, a ? r : undefined, a);
                    };
                });
            });
            be.fn.extend({
                bind: function(e, t, n) {
                    return this.on(e, null, t, n);
                },
                unbind: function(e, t) {
                    return this.off(e, null, t);
                },
                delegate: function(e, t, n, i) {
                    return this.on(t, e, n, i);
                },
                undelegate: function(e, t, n) {
                    // ( namespace ) or ( selector, types [, fn] )
                    return 1 === arguments.length ? this.off(e, "**") : this.off(t, e || "**", n);
                }
            });
            be.holdReady = function(e) {
                if (e) be.readyWait++; else be.ready(!0);
            };
            be.isArray = Array.isArray;
            be.parseJSON = JSON.parse;
            be.nodeName = l;
            // Register as a named AMD module, since jQuery can be concatenated with other
            // files that may use define, but not via a proper concatenation script that
            // understands anonymous AMD modules. A named AMD is safest and most robust
            // way to register. Lowercase jquery is used because AMD module names are
            // derived from file names, and jQuery is normally delivered in a lowercase
            // file name. Do this after creating the global so that if an AMD module wants
            // to call noConflict to hide this version of jQuery, it will work.
            // Note that for maximum portability, libraries that are not jQuery should
            // declare themselves as anonymous modules, and avoid setting a global if an
            // AMD loader is present. jQuery is a special case. For more information, see
            // https://github.com/jrburke/requirejs/wiki/Updating-existing-libraries#wiki-anon
            if (!0) i = [], (r = function() {
                return be;
            }.apply(t, i)) !== undefined && (e.exports = r);
            var // Map over jQuery in case of overwrite
            Gt = n.jQuery, // Map over the $ in case of overwrite
            Zt = n.$;
            be.noConflict = function(e) {
                if (n.$ === be) n.$ = Zt;
                if (e && n.jQuery === be) n.jQuery = Gt;
                return be;
            };
            // Expose jQuery and $ identifiers, even in AMD
            // (#7102#comment:10, https://github.com/jquery/jquery/pull/557)
            // and CommonJS for browser emulators (#13566)
            if (!o) n.jQuery = n.$ = be;
            return be;
        });
    },
    /***/
    39: /***/
    function(e, t, n) {
        /* WEBPACK VAR INJECTION */
        (function(t) {
            e.exports = t.$ = n(113);
        }).call(t, n(23));
    }
}, [ 109 ]);